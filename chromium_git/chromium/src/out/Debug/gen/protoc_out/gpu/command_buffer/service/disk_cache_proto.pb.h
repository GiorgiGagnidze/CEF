// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: disk_cache_proto.proto

#ifndef PROTOBUF_disk_5fcache_5fproto_2eproto__INCLUDED
#define PROTOBUF_disk_5fcache_5fproto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

class ShaderVariableProto;
class ShaderAttributeProto;
class ShaderUniformProto;
class ShaderVaryingProto;
class ShaderOutputVariableProto;
class ShaderProto;
class GpuProgramProto;

// ===================================================================

class ShaderVariableProto : public ::google::protobuf::MessageLite {
 public:
  ShaderVariableProto();
  virtual ~ShaderVariableProto();

  ShaderVariableProto(const ShaderVariableProto& from);

  inline ShaderVariableProto& operator=(const ShaderVariableProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShaderVariableProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShaderVariableProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShaderVariableProto* other);

  // implements Message ----------------------------------------------

  ShaderVariableProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShaderVariableProto& from);
  void MergeFrom(const ShaderVariableProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 precision = 2;
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 2;
  inline ::google::protobuf::uint32 precision() const;
  inline void set_precision(::google::protobuf::uint32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string mapped_name = 4;
  inline bool has_mapped_name() const;
  inline void clear_mapped_name();
  static const int kMappedNameFieldNumber = 4;
  inline const ::std::string& mapped_name() const;
  inline void set_mapped_name(const ::std::string& value);
  inline void set_mapped_name(const char* value);
  inline void set_mapped_name(const char* value, size_t size);
  inline ::std::string* mutable_mapped_name();
  inline ::std::string* release_mapped_name();
  inline void set_allocated_mapped_name(::std::string* mapped_name);

  // optional uint32 array_size = 5;
  inline bool has_array_size() const;
  inline void clear_array_size();
  static const int kArraySizeFieldNumber = 5;
  inline ::google::protobuf::uint32 array_size() const;
  inline void set_array_size(::google::protobuf::uint32 value);

  // optional bool static_use = 6;
  inline bool has_static_use() const;
  inline void clear_static_use();
  static const int kStaticUseFieldNumber = 6;
  inline bool static_use() const;
  inline void set_static_use(bool value);

  // repeated .ShaderVariableProto fields = 7;
  inline int fields_size() const;
  inline void clear_fields();
  static const int kFieldsFieldNumber = 7;
  inline const ::ShaderVariableProto& fields(int index) const;
  inline ::ShaderVariableProto* mutable_fields(int index);
  inline ::ShaderVariableProto* add_fields();
  inline const ::google::protobuf::RepeatedPtrField< ::ShaderVariableProto >&
      fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::ShaderVariableProto >*
      mutable_fields();

  // optional string struct_name = 8;
  inline bool has_struct_name() const;
  inline void clear_struct_name();
  static const int kStructNameFieldNumber = 8;
  inline const ::std::string& struct_name() const;
  inline void set_struct_name(const ::std::string& value);
  inline void set_struct_name(const char* value);
  inline void set_struct_name(const char* value, size_t size);
  inline ::std::string* mutable_struct_name();
  inline ::std::string* release_struct_name();
  inline void set_allocated_struct_name(::std::string* struct_name);

  // @@protoc_insertion_point(class_scope:ShaderVariableProto)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_mapped_name();
  inline void clear_has_mapped_name();
  inline void set_has_array_size();
  inline void clear_has_array_size();
  inline void set_has_static_use();
  inline void clear_has_static_use();
  inline void set_has_struct_name();
  inline void clear_has_struct_name();

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 precision_;
  ::std::string* name_;
  ::std::string* mapped_name_;
  ::google::protobuf::uint32 array_size_;
  bool static_use_;
  ::google::protobuf::RepeatedPtrField< ::ShaderVariableProto > fields_;
  ::std::string* struct_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
  #endif
  friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
  friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

  void InitAsDefaultInstance();
  static ShaderVariableProto* default_instance_;
};
// -------------------------------------------------------------------

class ShaderAttributeProto : public ::google::protobuf::MessageLite {
 public:
  ShaderAttributeProto();
  virtual ~ShaderAttributeProto();

  ShaderAttributeProto(const ShaderAttributeProto& from);

  inline ShaderAttributeProto& operator=(const ShaderAttributeProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShaderAttributeProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShaderAttributeProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShaderAttributeProto* other);

  // implements Message ----------------------------------------------

  ShaderAttributeProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShaderAttributeProto& from);
  void MergeFrom(const ShaderAttributeProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ShaderVariableProto basic = 1;
  inline bool has_basic() const;
  inline void clear_basic();
  static const int kBasicFieldNumber = 1;
  inline const ::ShaderVariableProto& basic() const;
  inline ::ShaderVariableProto* mutable_basic();
  inline ::ShaderVariableProto* release_basic();
  inline void set_allocated_basic(::ShaderVariableProto* basic);

  // optional int32 location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline ::google::protobuf::int32 location() const;
  inline void set_location(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ShaderAttributeProto)
 private:
  inline void set_has_basic();
  inline void clear_has_basic();
  inline void set_has_location();
  inline void clear_has_location();

  ::ShaderVariableProto* basic_;
  ::google::protobuf::int32 location_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
  #endif
  friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
  friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

  void InitAsDefaultInstance();
  static ShaderAttributeProto* default_instance_;
};
// -------------------------------------------------------------------

class ShaderUniformProto : public ::google::protobuf::MessageLite {
 public:
  ShaderUniformProto();
  virtual ~ShaderUniformProto();

  ShaderUniformProto(const ShaderUniformProto& from);

  inline ShaderUniformProto& operator=(const ShaderUniformProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShaderUniformProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShaderUniformProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShaderUniformProto* other);

  // implements Message ----------------------------------------------

  ShaderUniformProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShaderUniformProto& from);
  void MergeFrom(const ShaderUniformProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ShaderVariableProto basic = 1;
  inline bool has_basic() const;
  inline void clear_basic();
  static const int kBasicFieldNumber = 1;
  inline const ::ShaderVariableProto& basic() const;
  inline ::ShaderVariableProto* mutable_basic();
  inline ::ShaderVariableProto* release_basic();
  inline void set_allocated_basic(::ShaderVariableProto* basic);

  // @@protoc_insertion_point(class_scope:ShaderUniformProto)
 private:
  inline void set_has_basic();
  inline void clear_has_basic();

  ::ShaderVariableProto* basic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
  #endif
  friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
  friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

  void InitAsDefaultInstance();
  static ShaderUniformProto* default_instance_;
};
// -------------------------------------------------------------------

class ShaderVaryingProto : public ::google::protobuf::MessageLite {
 public:
  ShaderVaryingProto();
  virtual ~ShaderVaryingProto();

  ShaderVaryingProto(const ShaderVaryingProto& from);

  inline ShaderVaryingProto& operator=(const ShaderVaryingProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShaderVaryingProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShaderVaryingProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShaderVaryingProto* other);

  // implements Message ----------------------------------------------

  ShaderVaryingProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShaderVaryingProto& from);
  void MergeFrom(const ShaderVaryingProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ShaderVariableProto basic = 1;
  inline bool has_basic() const;
  inline void clear_basic();
  static const int kBasicFieldNumber = 1;
  inline const ::ShaderVariableProto& basic() const;
  inline ::ShaderVariableProto* mutable_basic();
  inline ::ShaderVariableProto* release_basic();
  inline void set_allocated_basic(::ShaderVariableProto* basic);

  // optional int32 interpolation = 2;
  inline bool has_interpolation() const;
  inline void clear_interpolation();
  static const int kInterpolationFieldNumber = 2;
  inline ::google::protobuf::int32 interpolation() const;
  inline void set_interpolation(::google::protobuf::int32 value);

  // optional bool is_invariant = 3;
  inline bool has_is_invariant() const;
  inline void clear_is_invariant();
  static const int kIsInvariantFieldNumber = 3;
  inline bool is_invariant() const;
  inline void set_is_invariant(bool value);

  // @@protoc_insertion_point(class_scope:ShaderVaryingProto)
 private:
  inline void set_has_basic();
  inline void clear_has_basic();
  inline void set_has_interpolation();
  inline void clear_has_interpolation();
  inline void set_has_is_invariant();
  inline void clear_has_is_invariant();

  ::ShaderVariableProto* basic_;
  ::google::protobuf::int32 interpolation_;
  bool is_invariant_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
  #endif
  friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
  friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

  void InitAsDefaultInstance();
  static ShaderVaryingProto* default_instance_;
};
// -------------------------------------------------------------------

class ShaderOutputVariableProto : public ::google::protobuf::MessageLite {
 public:
  ShaderOutputVariableProto();
  virtual ~ShaderOutputVariableProto();

  ShaderOutputVariableProto(const ShaderOutputVariableProto& from);

  inline ShaderOutputVariableProto& operator=(const ShaderOutputVariableProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShaderOutputVariableProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShaderOutputVariableProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShaderOutputVariableProto* other);

  // implements Message ----------------------------------------------

  ShaderOutputVariableProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShaderOutputVariableProto& from);
  void MergeFrom(const ShaderOutputVariableProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ShaderVariableProto basic = 1;
  inline bool has_basic() const;
  inline void clear_basic();
  static const int kBasicFieldNumber = 1;
  inline const ::ShaderVariableProto& basic() const;
  inline ::ShaderVariableProto* mutable_basic();
  inline ::ShaderVariableProto* release_basic();
  inline void set_allocated_basic(::ShaderVariableProto* basic);

  // optional int32 location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline ::google::protobuf::int32 location() const;
  inline void set_location(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ShaderOutputVariableProto)
 private:
  inline void set_has_basic();
  inline void clear_has_basic();
  inline void set_has_location();
  inline void clear_has_location();

  ::ShaderVariableProto* basic_;
  ::google::protobuf::int32 location_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
  #endif
  friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
  friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

  void InitAsDefaultInstance();
  static ShaderOutputVariableProto* default_instance_;
};
// -------------------------------------------------------------------

class ShaderProto : public ::google::protobuf::MessageLite {
 public:
  ShaderProto();
  virtual ~ShaderProto();

  ShaderProto(const ShaderProto& from);

  inline ShaderProto& operator=(const ShaderProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShaderProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShaderProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShaderProto* other);

  // implements Message ----------------------------------------------

  ShaderProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShaderProto& from);
  void MergeFrom(const ShaderProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sha = 1;
  inline bool has_sha() const;
  inline void clear_sha();
  static const int kShaFieldNumber = 1;
  inline const ::std::string& sha() const;
  inline void set_sha(const ::std::string& value);
  inline void set_sha(const char* value);
  inline void set_sha(const void* value, size_t size);
  inline ::std::string* mutable_sha();
  inline ::std::string* release_sha();
  inline void set_allocated_sha(::std::string* sha);

  // repeated .ShaderAttributeProto attribs = 2;
  inline int attribs_size() const;
  inline void clear_attribs();
  static const int kAttribsFieldNumber = 2;
  inline const ::ShaderAttributeProto& attribs(int index) const;
  inline ::ShaderAttributeProto* mutable_attribs(int index);
  inline ::ShaderAttributeProto* add_attribs();
  inline const ::google::protobuf::RepeatedPtrField< ::ShaderAttributeProto >&
      attribs() const;
  inline ::google::protobuf::RepeatedPtrField< ::ShaderAttributeProto >*
      mutable_attribs();

  // repeated .ShaderUniformProto uniforms = 3;
  inline int uniforms_size() const;
  inline void clear_uniforms();
  static const int kUniformsFieldNumber = 3;
  inline const ::ShaderUniformProto& uniforms(int index) const;
  inline ::ShaderUniformProto* mutable_uniforms(int index);
  inline ::ShaderUniformProto* add_uniforms();
  inline const ::google::protobuf::RepeatedPtrField< ::ShaderUniformProto >&
      uniforms() const;
  inline ::google::protobuf::RepeatedPtrField< ::ShaderUniformProto >*
      mutable_uniforms();

  // repeated .ShaderVaryingProto varyings = 4;
  inline int varyings_size() const;
  inline void clear_varyings();
  static const int kVaryingsFieldNumber = 4;
  inline const ::ShaderVaryingProto& varyings(int index) const;
  inline ::ShaderVaryingProto* mutable_varyings(int index);
  inline ::ShaderVaryingProto* add_varyings();
  inline const ::google::protobuf::RepeatedPtrField< ::ShaderVaryingProto >&
      varyings() const;
  inline ::google::protobuf::RepeatedPtrField< ::ShaderVaryingProto >*
      mutable_varyings();

  // repeated .ShaderOutputVariableProto output_variables = 5;
  inline int output_variables_size() const;
  inline void clear_output_variables();
  static const int kOutputVariablesFieldNumber = 5;
  inline const ::ShaderOutputVariableProto& output_variables(int index) const;
  inline ::ShaderOutputVariableProto* mutable_output_variables(int index);
  inline ::ShaderOutputVariableProto* add_output_variables();
  inline const ::google::protobuf::RepeatedPtrField< ::ShaderOutputVariableProto >&
      output_variables() const;
  inline ::google::protobuf::RepeatedPtrField< ::ShaderOutputVariableProto >*
      mutable_output_variables();

  // @@protoc_insertion_point(class_scope:ShaderProto)
 private:
  inline void set_has_sha();
  inline void clear_has_sha();

  ::std::string* sha_;
  ::google::protobuf::RepeatedPtrField< ::ShaderAttributeProto > attribs_;
  ::google::protobuf::RepeatedPtrField< ::ShaderUniformProto > uniforms_;
  ::google::protobuf::RepeatedPtrField< ::ShaderVaryingProto > varyings_;
  ::google::protobuf::RepeatedPtrField< ::ShaderOutputVariableProto > output_variables_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
  #endif
  friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
  friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

  void InitAsDefaultInstance();
  static ShaderProto* default_instance_;
};
// -------------------------------------------------------------------

class GpuProgramProto : public ::google::protobuf::MessageLite {
 public:
  GpuProgramProto();
  virtual ~GpuProgramProto();

  GpuProgramProto(const GpuProgramProto& from);

  inline GpuProgramProto& operator=(const GpuProgramProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const GpuProgramProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GpuProgramProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GpuProgramProto* other);

  // implements Message ----------------------------------------------

  GpuProgramProto* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GpuProgramProto& from);
  void MergeFrom(const GpuProgramProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sha = 1;
  inline bool has_sha() const;
  inline void clear_sha();
  static const int kShaFieldNumber = 1;
  inline const ::std::string& sha() const;
  inline void set_sha(const ::std::string& value);
  inline void set_sha(const char* value);
  inline void set_sha(const void* value, size_t size);
  inline ::std::string* mutable_sha();
  inline ::std::string* release_sha();
  inline void set_allocated_sha(::std::string* sha);

  // optional uint32 format = 2;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 2;
  inline ::google::protobuf::uint32 format() const;
  inline void set_format(::google::protobuf::uint32 value);

  // optional bytes program = 3;
  inline bool has_program() const;
  inline void clear_program();
  static const int kProgramFieldNumber = 3;
  inline const ::std::string& program() const;
  inline void set_program(const ::std::string& value);
  inline void set_program(const char* value);
  inline void set_program(const void* value, size_t size);
  inline ::std::string* mutable_program();
  inline ::std::string* release_program();
  inline void set_allocated_program(::std::string* program);

  // optional .ShaderProto vertex_shader = 4;
  inline bool has_vertex_shader() const;
  inline void clear_vertex_shader();
  static const int kVertexShaderFieldNumber = 4;
  inline const ::ShaderProto& vertex_shader() const;
  inline ::ShaderProto* mutable_vertex_shader();
  inline ::ShaderProto* release_vertex_shader();
  inline void set_allocated_vertex_shader(::ShaderProto* vertex_shader);

  // optional .ShaderProto fragment_shader = 5;
  inline bool has_fragment_shader() const;
  inline void clear_fragment_shader();
  static const int kFragmentShaderFieldNumber = 5;
  inline const ::ShaderProto& fragment_shader() const;
  inline ::ShaderProto* mutable_fragment_shader();
  inline ::ShaderProto* release_fragment_shader();
  inline void set_allocated_fragment_shader(::ShaderProto* fragment_shader);

  // @@protoc_insertion_point(class_scope:GpuProgramProto)
 private:
  inline void set_has_sha();
  inline void clear_has_sha();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_program();
  inline void clear_has_program();
  inline void set_has_vertex_shader();
  inline void clear_has_vertex_shader();
  inline void set_has_fragment_shader();
  inline void clear_has_fragment_shader();

  ::std::string* sha_;
  ::std::string* program_;
  ::ShaderProto* vertex_shader_;
  ::ShaderProto* fragment_shader_;
  ::google::protobuf::uint32 format_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_disk_5fcache_5fproto_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_disk_5fcache_5fproto_2eproto();
  #endif
  friend void protobuf_AssignDesc_disk_5fcache_5fproto_2eproto();
  friend void protobuf_ShutdownFile_disk_5fcache_5fproto_2eproto();

  void InitAsDefaultInstance();
  static GpuProgramProto* default_instance_;
};
// ===================================================================


// ===================================================================

// ShaderVariableProto

// optional uint32 type = 1;
inline bool ShaderVariableProto::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderVariableProto::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShaderVariableProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderVariableProto::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ShaderVariableProto::type() const {
  return type_;
}
inline void ShaderVariableProto::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 precision = 2;
inline bool ShaderVariableProto::has_precision() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderVariableProto::set_has_precision() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShaderVariableProto::clear_has_precision() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderVariableProto::clear_precision() {
  precision_ = 0u;
  clear_has_precision();
}
inline ::google::protobuf::uint32 ShaderVariableProto::precision() const {
  return precision_;
}
inline void ShaderVariableProto::set_precision(::google::protobuf::uint32 value) {
  set_has_precision();
  precision_ = value;
}

// optional string name = 3;
inline bool ShaderVariableProto::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShaderVariableProto::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShaderVariableProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShaderVariableProto::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ShaderVariableProto::name() const {
  return *name_;
}
inline void ShaderVariableProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ShaderVariableProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ShaderVariableProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShaderVariableProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ShaderVariableProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ShaderVariableProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string mapped_name = 4;
inline bool ShaderVariableProto::has_mapped_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShaderVariableProto::set_has_mapped_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShaderVariableProto::clear_has_mapped_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShaderVariableProto::clear_mapped_name() {
  if (mapped_name_ != &::google::protobuf::internal::GetEmptyString()) {
    mapped_name_->clear();
  }
  clear_has_mapped_name();
}
inline const ::std::string& ShaderVariableProto::mapped_name() const {
  return *mapped_name_;
}
inline void ShaderVariableProto::set_mapped_name(const ::std::string& value) {
  set_has_mapped_name();
  if (mapped_name_ == &::google::protobuf::internal::GetEmptyString()) {
    mapped_name_ = new ::std::string;
  }
  mapped_name_->assign(value);
}
inline void ShaderVariableProto::set_mapped_name(const char* value) {
  set_has_mapped_name();
  if (mapped_name_ == &::google::protobuf::internal::GetEmptyString()) {
    mapped_name_ = new ::std::string;
  }
  mapped_name_->assign(value);
}
inline void ShaderVariableProto::set_mapped_name(const char* value, size_t size) {
  set_has_mapped_name();
  if (mapped_name_ == &::google::protobuf::internal::GetEmptyString()) {
    mapped_name_ = new ::std::string;
  }
  mapped_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShaderVariableProto::mutable_mapped_name() {
  set_has_mapped_name();
  if (mapped_name_ == &::google::protobuf::internal::GetEmptyString()) {
    mapped_name_ = new ::std::string;
  }
  return mapped_name_;
}
inline ::std::string* ShaderVariableProto::release_mapped_name() {
  clear_has_mapped_name();
  if (mapped_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = mapped_name_;
    mapped_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ShaderVariableProto::set_allocated_mapped_name(::std::string* mapped_name) {
  if (mapped_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete mapped_name_;
  }
  if (mapped_name) {
    set_has_mapped_name();
    mapped_name_ = mapped_name;
  } else {
    clear_has_mapped_name();
    mapped_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional uint32 array_size = 5;
inline bool ShaderVariableProto::has_array_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShaderVariableProto::set_has_array_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShaderVariableProto::clear_has_array_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShaderVariableProto::clear_array_size() {
  array_size_ = 0u;
  clear_has_array_size();
}
inline ::google::protobuf::uint32 ShaderVariableProto::array_size() const {
  return array_size_;
}
inline void ShaderVariableProto::set_array_size(::google::protobuf::uint32 value) {
  set_has_array_size();
  array_size_ = value;
}

// optional bool static_use = 6;
inline bool ShaderVariableProto::has_static_use() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ShaderVariableProto::set_has_static_use() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ShaderVariableProto::clear_has_static_use() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ShaderVariableProto::clear_static_use() {
  static_use_ = false;
  clear_has_static_use();
}
inline bool ShaderVariableProto::static_use() const {
  return static_use_;
}
inline void ShaderVariableProto::set_static_use(bool value) {
  set_has_static_use();
  static_use_ = value;
}

// repeated .ShaderVariableProto fields = 7;
inline int ShaderVariableProto::fields_size() const {
  return fields_.size();
}
inline void ShaderVariableProto::clear_fields() {
  fields_.Clear();
}
inline const ::ShaderVariableProto& ShaderVariableProto::fields(int index) const {
  return fields_.Get(index);
}
inline ::ShaderVariableProto* ShaderVariableProto::mutable_fields(int index) {
  return fields_.Mutable(index);
}
inline ::ShaderVariableProto* ShaderVariableProto::add_fields() {
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShaderVariableProto >&
ShaderVariableProto::fields() const {
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::ShaderVariableProto >*
ShaderVariableProto::mutable_fields() {
  return &fields_;
}

// optional string struct_name = 8;
inline bool ShaderVariableProto::has_struct_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ShaderVariableProto::set_has_struct_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ShaderVariableProto::clear_has_struct_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ShaderVariableProto::clear_struct_name() {
  if (struct_name_ != &::google::protobuf::internal::GetEmptyString()) {
    struct_name_->clear();
  }
  clear_has_struct_name();
}
inline const ::std::string& ShaderVariableProto::struct_name() const {
  return *struct_name_;
}
inline void ShaderVariableProto::set_struct_name(const ::std::string& value) {
  set_has_struct_name();
  if (struct_name_ == &::google::protobuf::internal::GetEmptyString()) {
    struct_name_ = new ::std::string;
  }
  struct_name_->assign(value);
}
inline void ShaderVariableProto::set_struct_name(const char* value) {
  set_has_struct_name();
  if (struct_name_ == &::google::protobuf::internal::GetEmptyString()) {
    struct_name_ = new ::std::string;
  }
  struct_name_->assign(value);
}
inline void ShaderVariableProto::set_struct_name(const char* value, size_t size) {
  set_has_struct_name();
  if (struct_name_ == &::google::protobuf::internal::GetEmptyString()) {
    struct_name_ = new ::std::string;
  }
  struct_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShaderVariableProto::mutable_struct_name() {
  set_has_struct_name();
  if (struct_name_ == &::google::protobuf::internal::GetEmptyString()) {
    struct_name_ = new ::std::string;
  }
  return struct_name_;
}
inline ::std::string* ShaderVariableProto::release_struct_name() {
  clear_has_struct_name();
  if (struct_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = struct_name_;
    struct_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ShaderVariableProto::set_allocated_struct_name(::std::string* struct_name) {
  if (struct_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete struct_name_;
  }
  if (struct_name) {
    set_has_struct_name();
    struct_name_ = struct_name;
  } else {
    clear_has_struct_name();
    struct_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// ShaderAttributeProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderAttributeProto::has_basic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderAttributeProto::set_has_basic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShaderAttributeProto::clear_has_basic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderAttributeProto::clear_basic() {
  if (basic_ != NULL) basic_->::ShaderVariableProto::Clear();
  clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderAttributeProto::basic() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
  return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
inline ::ShaderVariableProto* ShaderAttributeProto::mutable_basic() {
  set_has_basic();
  if (basic_ == NULL) basic_ = new ::ShaderVariableProto;
  return basic_;
}
inline ::ShaderVariableProto* ShaderAttributeProto::release_basic() {
  clear_has_basic();
  ::ShaderVariableProto* temp = basic_;
  basic_ = NULL;
  return temp;
}
inline void ShaderAttributeProto::set_allocated_basic(::ShaderVariableProto* basic) {
  delete basic_;
  basic_ = basic;
  if (basic) {
    set_has_basic();
  } else {
    clear_has_basic();
  }
}

// optional int32 location = 2;
inline bool ShaderAttributeProto::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderAttributeProto::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShaderAttributeProto::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderAttributeProto::clear_location() {
  location_ = 0;
  clear_has_location();
}
inline ::google::protobuf::int32 ShaderAttributeProto::location() const {
  return location_;
}
inline void ShaderAttributeProto::set_location(::google::protobuf::int32 value) {
  set_has_location();
  location_ = value;
}

// -------------------------------------------------------------------

// ShaderUniformProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderUniformProto::has_basic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderUniformProto::set_has_basic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShaderUniformProto::clear_has_basic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderUniformProto::clear_basic() {
  if (basic_ != NULL) basic_->::ShaderVariableProto::Clear();
  clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderUniformProto::basic() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
  return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
inline ::ShaderVariableProto* ShaderUniformProto::mutable_basic() {
  set_has_basic();
  if (basic_ == NULL) basic_ = new ::ShaderVariableProto;
  return basic_;
}
inline ::ShaderVariableProto* ShaderUniformProto::release_basic() {
  clear_has_basic();
  ::ShaderVariableProto* temp = basic_;
  basic_ = NULL;
  return temp;
}
inline void ShaderUniformProto::set_allocated_basic(::ShaderVariableProto* basic) {
  delete basic_;
  basic_ = basic;
  if (basic) {
    set_has_basic();
  } else {
    clear_has_basic();
  }
}

// -------------------------------------------------------------------

// ShaderVaryingProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderVaryingProto::has_basic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderVaryingProto::set_has_basic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShaderVaryingProto::clear_has_basic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderVaryingProto::clear_basic() {
  if (basic_ != NULL) basic_->::ShaderVariableProto::Clear();
  clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderVaryingProto::basic() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
  return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
inline ::ShaderVariableProto* ShaderVaryingProto::mutable_basic() {
  set_has_basic();
  if (basic_ == NULL) basic_ = new ::ShaderVariableProto;
  return basic_;
}
inline ::ShaderVariableProto* ShaderVaryingProto::release_basic() {
  clear_has_basic();
  ::ShaderVariableProto* temp = basic_;
  basic_ = NULL;
  return temp;
}
inline void ShaderVaryingProto::set_allocated_basic(::ShaderVariableProto* basic) {
  delete basic_;
  basic_ = basic;
  if (basic) {
    set_has_basic();
  } else {
    clear_has_basic();
  }
}

// optional int32 interpolation = 2;
inline bool ShaderVaryingProto::has_interpolation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderVaryingProto::set_has_interpolation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShaderVaryingProto::clear_has_interpolation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderVaryingProto::clear_interpolation() {
  interpolation_ = 0;
  clear_has_interpolation();
}
inline ::google::protobuf::int32 ShaderVaryingProto::interpolation() const {
  return interpolation_;
}
inline void ShaderVaryingProto::set_interpolation(::google::protobuf::int32 value) {
  set_has_interpolation();
  interpolation_ = value;
}

// optional bool is_invariant = 3;
inline bool ShaderVaryingProto::has_is_invariant() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShaderVaryingProto::set_has_is_invariant() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShaderVaryingProto::clear_has_is_invariant() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShaderVaryingProto::clear_is_invariant() {
  is_invariant_ = false;
  clear_has_is_invariant();
}
inline bool ShaderVaryingProto::is_invariant() const {
  return is_invariant_;
}
inline void ShaderVaryingProto::set_is_invariant(bool value) {
  set_has_is_invariant();
  is_invariant_ = value;
}

// -------------------------------------------------------------------

// ShaderOutputVariableProto

// optional .ShaderVariableProto basic = 1;
inline bool ShaderOutputVariableProto::has_basic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderOutputVariableProto::set_has_basic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShaderOutputVariableProto::clear_has_basic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderOutputVariableProto::clear_basic() {
  if (basic_ != NULL) basic_->::ShaderVariableProto::Clear();
  clear_has_basic();
}
inline const ::ShaderVariableProto& ShaderOutputVariableProto::basic() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return basic_ != NULL ? *basic_ : *default_instance().basic_;
#else
  return basic_ != NULL ? *basic_ : *default_instance_->basic_;
#endif
}
inline ::ShaderVariableProto* ShaderOutputVariableProto::mutable_basic() {
  set_has_basic();
  if (basic_ == NULL) basic_ = new ::ShaderVariableProto;
  return basic_;
}
inline ::ShaderVariableProto* ShaderOutputVariableProto::release_basic() {
  clear_has_basic();
  ::ShaderVariableProto* temp = basic_;
  basic_ = NULL;
  return temp;
}
inline void ShaderOutputVariableProto::set_allocated_basic(::ShaderVariableProto* basic) {
  delete basic_;
  basic_ = basic;
  if (basic) {
    set_has_basic();
  } else {
    clear_has_basic();
  }
}

// optional int32 location = 2;
inline bool ShaderOutputVariableProto::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShaderOutputVariableProto::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShaderOutputVariableProto::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShaderOutputVariableProto::clear_location() {
  location_ = 0;
  clear_has_location();
}
inline ::google::protobuf::int32 ShaderOutputVariableProto::location() const {
  return location_;
}
inline void ShaderOutputVariableProto::set_location(::google::protobuf::int32 value) {
  set_has_location();
  location_ = value;
}

// -------------------------------------------------------------------

// ShaderProto

// optional bytes sha = 1;
inline bool ShaderProto::has_sha() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShaderProto::set_has_sha() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShaderProto::clear_has_sha() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShaderProto::clear_sha() {
  if (sha_ != &::google::protobuf::internal::GetEmptyString()) {
    sha_->clear();
  }
  clear_has_sha();
}
inline const ::std::string& ShaderProto::sha() const {
  return *sha_;
}
inline void ShaderProto::set_sha(const ::std::string& value) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
    sha_ = new ::std::string;
  }
  sha_->assign(value);
}
inline void ShaderProto::set_sha(const char* value) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
    sha_ = new ::std::string;
  }
  sha_->assign(value);
}
inline void ShaderProto::set_sha(const void* value, size_t size) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
    sha_ = new ::std::string;
  }
  sha_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShaderProto::mutable_sha() {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
    sha_ = new ::std::string;
  }
  return sha_;
}
inline ::std::string* ShaderProto::release_sha() {
  clear_has_sha();
  if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = sha_;
    sha_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ShaderProto::set_allocated_sha(::std::string* sha) {
  if (sha_ != &::google::protobuf::internal::GetEmptyString()) {
    delete sha_;
  }
  if (sha) {
    set_has_sha();
    sha_ = sha;
  } else {
    clear_has_sha();
    sha_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .ShaderAttributeProto attribs = 2;
inline int ShaderProto::attribs_size() const {
  return attribs_.size();
}
inline void ShaderProto::clear_attribs() {
  attribs_.Clear();
}
inline const ::ShaderAttributeProto& ShaderProto::attribs(int index) const {
  return attribs_.Get(index);
}
inline ::ShaderAttributeProto* ShaderProto::mutable_attribs(int index) {
  return attribs_.Mutable(index);
}
inline ::ShaderAttributeProto* ShaderProto::add_attribs() {
  return attribs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShaderAttributeProto >&
ShaderProto::attribs() const {
  return attribs_;
}
inline ::google::protobuf::RepeatedPtrField< ::ShaderAttributeProto >*
ShaderProto::mutable_attribs() {
  return &attribs_;
}

// repeated .ShaderUniformProto uniforms = 3;
inline int ShaderProto::uniforms_size() const {
  return uniforms_.size();
}
inline void ShaderProto::clear_uniforms() {
  uniforms_.Clear();
}
inline const ::ShaderUniformProto& ShaderProto::uniforms(int index) const {
  return uniforms_.Get(index);
}
inline ::ShaderUniformProto* ShaderProto::mutable_uniforms(int index) {
  return uniforms_.Mutable(index);
}
inline ::ShaderUniformProto* ShaderProto::add_uniforms() {
  return uniforms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShaderUniformProto >&
ShaderProto::uniforms() const {
  return uniforms_;
}
inline ::google::protobuf::RepeatedPtrField< ::ShaderUniformProto >*
ShaderProto::mutable_uniforms() {
  return &uniforms_;
}

// repeated .ShaderVaryingProto varyings = 4;
inline int ShaderProto::varyings_size() const {
  return varyings_.size();
}
inline void ShaderProto::clear_varyings() {
  varyings_.Clear();
}
inline const ::ShaderVaryingProto& ShaderProto::varyings(int index) const {
  return varyings_.Get(index);
}
inline ::ShaderVaryingProto* ShaderProto::mutable_varyings(int index) {
  return varyings_.Mutable(index);
}
inline ::ShaderVaryingProto* ShaderProto::add_varyings() {
  return varyings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShaderVaryingProto >&
ShaderProto::varyings() const {
  return varyings_;
}
inline ::google::protobuf::RepeatedPtrField< ::ShaderVaryingProto >*
ShaderProto::mutable_varyings() {
  return &varyings_;
}

// repeated .ShaderOutputVariableProto output_variables = 5;
inline int ShaderProto::output_variables_size() const {
  return output_variables_.size();
}
inline void ShaderProto::clear_output_variables() {
  output_variables_.Clear();
}
inline const ::ShaderOutputVariableProto& ShaderProto::output_variables(int index) const {
  return output_variables_.Get(index);
}
inline ::ShaderOutputVariableProto* ShaderProto::mutable_output_variables(int index) {
  return output_variables_.Mutable(index);
}
inline ::ShaderOutputVariableProto* ShaderProto::add_output_variables() {
  return output_variables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShaderOutputVariableProto >&
ShaderProto::output_variables() const {
  return output_variables_;
}
inline ::google::protobuf::RepeatedPtrField< ::ShaderOutputVariableProto >*
ShaderProto::mutable_output_variables() {
  return &output_variables_;
}

// -------------------------------------------------------------------

// GpuProgramProto

// optional bytes sha = 1;
inline bool GpuProgramProto::has_sha() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuProgramProto::set_has_sha() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpuProgramProto::clear_has_sha() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpuProgramProto::clear_sha() {
  if (sha_ != &::google::protobuf::internal::GetEmptyString()) {
    sha_->clear();
  }
  clear_has_sha();
}
inline const ::std::string& GpuProgramProto::sha() const {
  return *sha_;
}
inline void GpuProgramProto::set_sha(const ::std::string& value) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
    sha_ = new ::std::string;
  }
  sha_->assign(value);
}
inline void GpuProgramProto::set_sha(const char* value) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
    sha_ = new ::std::string;
  }
  sha_->assign(value);
}
inline void GpuProgramProto::set_sha(const void* value, size_t size) {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
    sha_ = new ::std::string;
  }
  sha_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GpuProgramProto::mutable_sha() {
  set_has_sha();
  if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
    sha_ = new ::std::string;
  }
  return sha_;
}
inline ::std::string* GpuProgramProto::release_sha() {
  clear_has_sha();
  if (sha_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = sha_;
    sha_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GpuProgramProto::set_allocated_sha(::std::string* sha) {
  if (sha_ != &::google::protobuf::internal::GetEmptyString()) {
    delete sha_;
  }
  if (sha) {
    set_has_sha();
    sha_ = sha;
  } else {
    clear_has_sha();
    sha_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional uint32 format = 2;
inline bool GpuProgramProto::has_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpuProgramProto::set_has_format() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpuProgramProto::clear_has_format() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpuProgramProto::clear_format() {
  format_ = 0u;
  clear_has_format();
}
inline ::google::protobuf::uint32 GpuProgramProto::format() const {
  return format_;
}
inline void GpuProgramProto::set_format(::google::protobuf::uint32 value) {
  set_has_format();
  format_ = value;
}

// optional bytes program = 3;
inline bool GpuProgramProto::has_program() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpuProgramProto::set_has_program() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpuProgramProto::clear_has_program() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpuProgramProto::clear_program() {
  if (program_ != &::google::protobuf::internal::GetEmptyString()) {
    program_->clear();
  }
  clear_has_program();
}
inline const ::std::string& GpuProgramProto::program() const {
  return *program_;
}
inline void GpuProgramProto::set_program(const ::std::string& value) {
  set_has_program();
  if (program_ == &::google::protobuf::internal::GetEmptyString()) {
    program_ = new ::std::string;
  }
  program_->assign(value);
}
inline void GpuProgramProto::set_program(const char* value) {
  set_has_program();
  if (program_ == &::google::protobuf::internal::GetEmptyString()) {
    program_ = new ::std::string;
  }
  program_->assign(value);
}
inline void GpuProgramProto::set_program(const void* value, size_t size) {
  set_has_program();
  if (program_ == &::google::protobuf::internal::GetEmptyString()) {
    program_ = new ::std::string;
  }
  program_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GpuProgramProto::mutable_program() {
  set_has_program();
  if (program_ == &::google::protobuf::internal::GetEmptyString()) {
    program_ = new ::std::string;
  }
  return program_;
}
inline ::std::string* GpuProgramProto::release_program() {
  clear_has_program();
  if (program_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = program_;
    program_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GpuProgramProto::set_allocated_program(::std::string* program) {
  if (program_ != &::google::protobuf::internal::GetEmptyString()) {
    delete program_;
  }
  if (program) {
    set_has_program();
    program_ = program;
  } else {
    clear_has_program();
    program_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .ShaderProto vertex_shader = 4;
inline bool GpuProgramProto::has_vertex_shader() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GpuProgramProto::set_has_vertex_shader() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GpuProgramProto::clear_has_vertex_shader() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GpuProgramProto::clear_vertex_shader() {
  if (vertex_shader_ != NULL) vertex_shader_->::ShaderProto::Clear();
  clear_has_vertex_shader();
}
inline const ::ShaderProto& GpuProgramProto::vertex_shader() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return vertex_shader_ != NULL ? *vertex_shader_ : *default_instance().vertex_shader_;
#else
  return vertex_shader_ != NULL ? *vertex_shader_ : *default_instance_->vertex_shader_;
#endif
}
inline ::ShaderProto* GpuProgramProto::mutable_vertex_shader() {
  set_has_vertex_shader();
  if (vertex_shader_ == NULL) vertex_shader_ = new ::ShaderProto;
  return vertex_shader_;
}
inline ::ShaderProto* GpuProgramProto::release_vertex_shader() {
  clear_has_vertex_shader();
  ::ShaderProto* temp = vertex_shader_;
  vertex_shader_ = NULL;
  return temp;
}
inline void GpuProgramProto::set_allocated_vertex_shader(::ShaderProto* vertex_shader) {
  delete vertex_shader_;
  vertex_shader_ = vertex_shader;
  if (vertex_shader) {
    set_has_vertex_shader();
  } else {
    clear_has_vertex_shader();
  }
}

// optional .ShaderProto fragment_shader = 5;
inline bool GpuProgramProto::has_fragment_shader() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GpuProgramProto::set_has_fragment_shader() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GpuProgramProto::clear_has_fragment_shader() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GpuProgramProto::clear_fragment_shader() {
  if (fragment_shader_ != NULL) fragment_shader_->::ShaderProto::Clear();
  clear_has_fragment_shader();
}
inline const ::ShaderProto& GpuProgramProto::fragment_shader() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fragment_shader_ != NULL ? *fragment_shader_ : *default_instance().fragment_shader_;
#else
  return fragment_shader_ != NULL ? *fragment_shader_ : *default_instance_->fragment_shader_;
#endif
}
inline ::ShaderProto* GpuProgramProto::mutable_fragment_shader() {
  set_has_fragment_shader();
  if (fragment_shader_ == NULL) fragment_shader_ = new ::ShaderProto;
  return fragment_shader_;
}
inline ::ShaderProto* GpuProgramProto::release_fragment_shader() {
  clear_has_fragment_shader();
  ::ShaderProto* temp = fragment_shader_;
  fragment_shader_ = NULL;
  return temp;
}
inline void GpuProgramProto::set_allocated_fragment_shader(::ShaderProto* fragment_shader) {
  delete fragment_shader_;
  fragment_shader_ = fragment_shader;
  if (fragment_shader) {
    set_has_fragment_shader();
  } else {
    clear_has_fragment_shader();
  }
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_disk_5fcache_5fproto_2eproto__INCLUDED
