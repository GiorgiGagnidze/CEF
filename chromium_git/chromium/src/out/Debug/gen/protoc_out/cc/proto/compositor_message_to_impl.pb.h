// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: compositor_message_to_impl.proto

#ifndef PROTOBUF_compositor_5fmessage_5fto_5fimpl_2eproto__INCLUDED
#define PROTOBUF_compositor_5fmessage_5fto_5fimpl_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "commit_earlyout_reason.pb.h"
#include "layer_tree_host.pb.h"
#include "layer_tree_settings.pb.h"
#include "rect.pb.h"
// @@protoc_insertion_point(includes)
#include "cc/proto/cc_proto_export.h"

namespace cc {
namespace proto {

// Internal implementation detail -- do not call these.
void CC_PROTO_EXPORT protobuf_AddDesc_compositor_5fmessage_5fto_5fimpl_2eproto();
void protobuf_AssignDesc_compositor_5fmessage_5fto_5fimpl_2eproto();
void protobuf_ShutdownFile_compositor_5fmessage_5fto_5fimpl_2eproto();

class CompositorMessageToImpl;
class InitializeImpl;
class SetDeferCommits;
class StartCommit;
class BeginMainFrameAborted;
class SetNeedsRedraw;

enum CompositorMessageToImpl_Type {
  CompositorMessageToImpl_Type_UNKNOWN = 0,
  CompositorMessageToImpl_Type_INITIALIZE_IMPL = 1,
  CompositorMessageToImpl_Type_CLOSE_IMPL = 2,
  CompositorMessageToImpl_Type_MAIN_THREAD_HAS_STOPPED_FLINGING_ON_IMPL = 3,
  CompositorMessageToImpl_Type_SET_NEEDS_COMMIT = 4,
  CompositorMessageToImpl_Type_SET_DEFER_COMMITS = 5,
  CompositorMessageToImpl_Type_START_COMMIT = 6,
  CompositorMessageToImpl_Type_BEGIN_MAIN_FRAME_ABORTED = 7,
  CompositorMessageToImpl_Type_SET_NEEDS_REDRAW = 8
};
CC_PROTO_EXPORT bool CompositorMessageToImpl_Type_IsValid(int value);
const CompositorMessageToImpl_Type CompositorMessageToImpl_Type_Type_MIN = CompositorMessageToImpl_Type_UNKNOWN;
const CompositorMessageToImpl_Type CompositorMessageToImpl_Type_Type_MAX = CompositorMessageToImpl_Type_SET_NEEDS_REDRAW;
const int CompositorMessageToImpl_Type_Type_ARRAYSIZE = CompositorMessageToImpl_Type_Type_MAX + 1;

// ===================================================================

class CC_PROTO_EXPORT CompositorMessageToImpl : public ::google::protobuf::MessageLite {
 public:
  CompositorMessageToImpl();
  virtual ~CompositorMessageToImpl();

  CompositorMessageToImpl(const CompositorMessageToImpl& from);

  inline CompositorMessageToImpl& operator=(const CompositorMessageToImpl& from) {
    CopyFrom(from);
    return *this;
  }

  static const CompositorMessageToImpl& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CompositorMessageToImpl* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CompositorMessageToImpl* other);

  // implements Message ----------------------------------------------

  CompositorMessageToImpl* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CompositorMessageToImpl& from);
  void MergeFrom(const CompositorMessageToImpl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CompositorMessageToImpl_Type Type;
  static const Type UNKNOWN = CompositorMessageToImpl_Type_UNKNOWN;
  static const Type INITIALIZE_IMPL = CompositorMessageToImpl_Type_INITIALIZE_IMPL;
  static const Type CLOSE_IMPL = CompositorMessageToImpl_Type_CLOSE_IMPL;
  static const Type MAIN_THREAD_HAS_STOPPED_FLINGING_ON_IMPL = CompositorMessageToImpl_Type_MAIN_THREAD_HAS_STOPPED_FLINGING_ON_IMPL;
  static const Type SET_NEEDS_COMMIT = CompositorMessageToImpl_Type_SET_NEEDS_COMMIT;
  static const Type SET_DEFER_COMMITS = CompositorMessageToImpl_Type_SET_DEFER_COMMITS;
  static const Type START_COMMIT = CompositorMessageToImpl_Type_START_COMMIT;
  static const Type BEGIN_MAIN_FRAME_ABORTED = CompositorMessageToImpl_Type_BEGIN_MAIN_FRAME_ABORTED;
  static const Type SET_NEEDS_REDRAW = CompositorMessageToImpl_Type_SET_NEEDS_REDRAW;
  static inline bool Type_IsValid(int value) {
    return CompositorMessageToImpl_Type_IsValid(value);
  }
  static const Type Type_MIN =
    CompositorMessageToImpl_Type_Type_MIN;
  static const Type Type_MAX =
    CompositorMessageToImpl_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    CompositorMessageToImpl_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .cc.proto.CompositorMessageToImpl.Type message_type = 1;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  inline ::cc::proto::CompositorMessageToImpl_Type message_type() const;
  inline void set_message_type(::cc::proto::CompositorMessageToImpl_Type value);

  // optional .cc.proto.InitializeImpl initialize_impl_message = 2;
  inline bool has_initialize_impl_message() const;
  inline void clear_initialize_impl_message();
  static const int kInitializeImplMessageFieldNumber = 2;
  inline const ::cc::proto::InitializeImpl& initialize_impl_message() const;
  inline ::cc::proto::InitializeImpl* mutable_initialize_impl_message();
  inline ::cc::proto::InitializeImpl* release_initialize_impl_message();
  inline void set_allocated_initialize_impl_message(::cc::proto::InitializeImpl* initialize_impl_message);

  // optional .cc.proto.SetDeferCommits defer_commits_message = 3;
  inline bool has_defer_commits_message() const;
  inline void clear_defer_commits_message();
  static const int kDeferCommitsMessageFieldNumber = 3;
  inline const ::cc::proto::SetDeferCommits& defer_commits_message() const;
  inline ::cc::proto::SetDeferCommits* mutable_defer_commits_message();
  inline ::cc::proto::SetDeferCommits* release_defer_commits_message();
  inline void set_allocated_defer_commits_message(::cc::proto::SetDeferCommits* defer_commits_message);

  // optional .cc.proto.StartCommit start_commit_message = 4;
  inline bool has_start_commit_message() const;
  inline void clear_start_commit_message();
  static const int kStartCommitMessageFieldNumber = 4;
  inline const ::cc::proto::StartCommit& start_commit_message() const;
  inline ::cc::proto::StartCommit* mutable_start_commit_message();
  inline ::cc::proto::StartCommit* release_start_commit_message();
  inline void set_allocated_start_commit_message(::cc::proto::StartCommit* start_commit_message);

  // optional .cc.proto.BeginMainFrameAborted begin_main_frame_aborted_message = 5;
  inline bool has_begin_main_frame_aborted_message() const;
  inline void clear_begin_main_frame_aborted_message();
  static const int kBeginMainFrameAbortedMessageFieldNumber = 5;
  inline const ::cc::proto::BeginMainFrameAborted& begin_main_frame_aborted_message() const;
  inline ::cc::proto::BeginMainFrameAborted* mutable_begin_main_frame_aborted_message();
  inline ::cc::proto::BeginMainFrameAborted* release_begin_main_frame_aborted_message();
  inline void set_allocated_begin_main_frame_aborted_message(::cc::proto::BeginMainFrameAborted* begin_main_frame_aborted_message);

  // optional .cc.proto.SetNeedsRedraw set_needs_redraw_message = 6;
  inline bool has_set_needs_redraw_message() const;
  inline void clear_set_needs_redraw_message();
  static const int kSetNeedsRedrawMessageFieldNumber = 6;
  inline const ::cc::proto::SetNeedsRedraw& set_needs_redraw_message() const;
  inline ::cc::proto::SetNeedsRedraw* mutable_set_needs_redraw_message();
  inline ::cc::proto::SetNeedsRedraw* release_set_needs_redraw_message();
  inline void set_allocated_set_needs_redraw_message(::cc::proto::SetNeedsRedraw* set_needs_redraw_message);

  // @@protoc_insertion_point(class_scope:cc.proto.CompositorMessageToImpl)
 private:
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_initialize_impl_message();
  inline void clear_has_initialize_impl_message();
  inline void set_has_defer_commits_message();
  inline void clear_has_defer_commits_message();
  inline void set_has_start_commit_message();
  inline void clear_has_start_commit_message();
  inline void set_has_begin_main_frame_aborted_message();
  inline void clear_has_begin_main_frame_aborted_message();
  inline void set_has_set_needs_redraw_message();
  inline void clear_has_set_needs_redraw_message();

  ::cc::proto::InitializeImpl* initialize_impl_message_;
  ::cc::proto::SetDeferCommits* defer_commits_message_;
  ::cc::proto::StartCommit* start_commit_message_;
  ::cc::proto::BeginMainFrameAborted* begin_main_frame_aborted_message_;
  ::cc::proto::SetNeedsRedraw* set_needs_redraw_message_;
  int message_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_compositor_5fmessage_5fto_5fimpl_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_compositor_5fmessage_5fto_5fimpl_2eproto();
  #endif
  friend void protobuf_AssignDesc_compositor_5fmessage_5fto_5fimpl_2eproto();
  friend void protobuf_ShutdownFile_compositor_5fmessage_5fto_5fimpl_2eproto();

  void InitAsDefaultInstance();
  static CompositorMessageToImpl* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT InitializeImpl : public ::google::protobuf::MessageLite {
 public:
  InitializeImpl();
  virtual ~InitializeImpl();

  InitializeImpl(const InitializeImpl& from);

  inline InitializeImpl& operator=(const InitializeImpl& from) {
    CopyFrom(from);
    return *this;
  }

  static const InitializeImpl& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InitializeImpl* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InitializeImpl* other);

  // implements Message ----------------------------------------------

  InitializeImpl* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InitializeImpl& from);
  void MergeFrom(const InitializeImpl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cc.proto.LayerTreeSettings layer_tree_settings = 1;
  inline bool has_layer_tree_settings() const;
  inline void clear_layer_tree_settings();
  static const int kLayerTreeSettingsFieldNumber = 1;
  inline const ::cc::proto::LayerTreeSettings& layer_tree_settings() const;
  inline ::cc::proto::LayerTreeSettings* mutable_layer_tree_settings();
  inline ::cc::proto::LayerTreeSettings* release_layer_tree_settings();
  inline void set_allocated_layer_tree_settings(::cc::proto::LayerTreeSettings* layer_tree_settings);

  // @@protoc_insertion_point(class_scope:cc.proto.InitializeImpl)
 private:
  inline void set_has_layer_tree_settings();
  inline void clear_has_layer_tree_settings();

  ::cc::proto::LayerTreeSettings* layer_tree_settings_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_compositor_5fmessage_5fto_5fimpl_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_compositor_5fmessage_5fto_5fimpl_2eproto();
  #endif
  friend void protobuf_AssignDesc_compositor_5fmessage_5fto_5fimpl_2eproto();
  friend void protobuf_ShutdownFile_compositor_5fmessage_5fto_5fimpl_2eproto();

  void InitAsDefaultInstance();
  static InitializeImpl* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT SetDeferCommits : public ::google::protobuf::MessageLite {
 public:
  SetDeferCommits();
  virtual ~SetDeferCommits();

  SetDeferCommits(const SetDeferCommits& from);

  inline SetDeferCommits& operator=(const SetDeferCommits& from) {
    CopyFrom(from);
    return *this;
  }

  static const SetDeferCommits& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetDeferCommits* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SetDeferCommits* other);

  // implements Message ----------------------------------------------

  SetDeferCommits* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetDeferCommits& from);
  void MergeFrom(const SetDeferCommits& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool defer_commits = 1;
  inline bool has_defer_commits() const;
  inline void clear_defer_commits();
  static const int kDeferCommitsFieldNumber = 1;
  inline bool defer_commits() const;
  inline void set_defer_commits(bool value);

  // @@protoc_insertion_point(class_scope:cc.proto.SetDeferCommits)
 private:
  inline void set_has_defer_commits();
  inline void clear_has_defer_commits();

  bool defer_commits_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_compositor_5fmessage_5fto_5fimpl_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_compositor_5fmessage_5fto_5fimpl_2eproto();
  #endif
  friend void protobuf_AssignDesc_compositor_5fmessage_5fto_5fimpl_2eproto();
  friend void protobuf_ShutdownFile_compositor_5fmessage_5fto_5fimpl_2eproto();

  void InitAsDefaultInstance();
  static SetDeferCommits* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT StartCommit : public ::google::protobuf::MessageLite {
 public:
  StartCommit();
  virtual ~StartCommit();

  StartCommit(const StartCommit& from);

  inline StartCommit& operator=(const StartCommit& from) {
    CopyFrom(from);
    return *this;
  }

  static const StartCommit& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartCommit* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartCommit* other);

  // implements Message ----------------------------------------------

  StartCommit* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartCommit& from);
  void MergeFrom(const StartCommit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cc.proto.LayerTreeHost layer_tree_host = 1;
  inline bool has_layer_tree_host() const;
  inline void clear_layer_tree_host();
  static const int kLayerTreeHostFieldNumber = 1;
  inline const ::cc::proto::LayerTreeHost& layer_tree_host() const;
  inline ::cc::proto::LayerTreeHost* mutable_layer_tree_host();
  inline ::cc::proto::LayerTreeHost* release_layer_tree_host();
  inline void set_allocated_layer_tree_host(::cc::proto::LayerTreeHost* layer_tree_host);

  // @@protoc_insertion_point(class_scope:cc.proto.StartCommit)
 private:
  inline void set_has_layer_tree_host();
  inline void clear_has_layer_tree_host();

  ::cc::proto::LayerTreeHost* layer_tree_host_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_compositor_5fmessage_5fto_5fimpl_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_compositor_5fmessage_5fto_5fimpl_2eproto();
  #endif
  friend void protobuf_AssignDesc_compositor_5fmessage_5fto_5fimpl_2eproto();
  friend void protobuf_ShutdownFile_compositor_5fmessage_5fto_5fimpl_2eproto();

  void InitAsDefaultInstance();
  static StartCommit* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT BeginMainFrameAborted : public ::google::protobuf::MessageLite {
 public:
  BeginMainFrameAborted();
  virtual ~BeginMainFrameAborted();

  BeginMainFrameAborted(const BeginMainFrameAborted& from);

  inline BeginMainFrameAborted& operator=(const BeginMainFrameAborted& from) {
    CopyFrom(from);
    return *this;
  }

  static const BeginMainFrameAborted& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BeginMainFrameAborted* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BeginMainFrameAborted* other);

  // implements Message ----------------------------------------------

  BeginMainFrameAborted* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BeginMainFrameAborted& from);
  void MergeFrom(const BeginMainFrameAborted& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cc.proto.CommitEarlyOutReason reason = 1;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 1;
  inline const ::cc::proto::CommitEarlyOutReason& reason() const;
  inline ::cc::proto::CommitEarlyOutReason* mutable_reason();
  inline ::cc::proto::CommitEarlyOutReason* release_reason();
  inline void set_allocated_reason(::cc::proto::CommitEarlyOutReason* reason);

  // @@protoc_insertion_point(class_scope:cc.proto.BeginMainFrameAborted)
 private:
  inline void set_has_reason();
  inline void clear_has_reason();

  ::cc::proto::CommitEarlyOutReason* reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_compositor_5fmessage_5fto_5fimpl_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_compositor_5fmessage_5fto_5fimpl_2eproto();
  #endif
  friend void protobuf_AssignDesc_compositor_5fmessage_5fto_5fimpl_2eproto();
  friend void protobuf_ShutdownFile_compositor_5fmessage_5fto_5fimpl_2eproto();

  void InitAsDefaultInstance();
  static BeginMainFrameAborted* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT SetNeedsRedraw : public ::google::protobuf::MessageLite {
 public:
  SetNeedsRedraw();
  virtual ~SetNeedsRedraw();

  SetNeedsRedraw(const SetNeedsRedraw& from);

  inline SetNeedsRedraw& operator=(const SetNeedsRedraw& from) {
    CopyFrom(from);
    return *this;
  }

  static const SetNeedsRedraw& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetNeedsRedraw* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SetNeedsRedraw* other);

  // implements Message ----------------------------------------------

  SetNeedsRedraw* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetNeedsRedraw& from);
  void MergeFrom(const SetNeedsRedraw& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cc.proto.Rect damaged_rect = 1;
  inline bool has_damaged_rect() const;
  inline void clear_damaged_rect();
  static const int kDamagedRectFieldNumber = 1;
  inline const ::cc::proto::Rect& damaged_rect() const;
  inline ::cc::proto::Rect* mutable_damaged_rect();
  inline ::cc::proto::Rect* release_damaged_rect();
  inline void set_allocated_damaged_rect(::cc::proto::Rect* damaged_rect);

  // @@protoc_insertion_point(class_scope:cc.proto.SetNeedsRedraw)
 private:
  inline void set_has_damaged_rect();
  inline void clear_has_damaged_rect();

  ::cc::proto::Rect* damaged_rect_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_compositor_5fmessage_5fto_5fimpl_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_compositor_5fmessage_5fto_5fimpl_2eproto();
  #endif
  friend void protobuf_AssignDesc_compositor_5fmessage_5fto_5fimpl_2eproto();
  friend void protobuf_ShutdownFile_compositor_5fmessage_5fto_5fimpl_2eproto();

  void InitAsDefaultInstance();
  static SetNeedsRedraw* default_instance_;
};
// ===================================================================


// ===================================================================

// CompositorMessageToImpl

// optional .cc.proto.CompositorMessageToImpl.Type message_type = 1;
inline bool CompositorMessageToImpl::has_message_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompositorMessageToImpl::set_has_message_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompositorMessageToImpl::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompositorMessageToImpl::clear_message_type() {
  message_type_ = 0;
  clear_has_message_type();
}
inline ::cc::proto::CompositorMessageToImpl_Type CompositorMessageToImpl::message_type() const {
  return static_cast< ::cc::proto::CompositorMessageToImpl_Type >(message_type_);
}
inline void CompositorMessageToImpl::set_message_type(::cc::proto::CompositorMessageToImpl_Type value) {
  assert(::cc::proto::CompositorMessageToImpl_Type_IsValid(value));
  set_has_message_type();
  message_type_ = value;
}

// optional .cc.proto.InitializeImpl initialize_impl_message = 2;
inline bool CompositorMessageToImpl::has_initialize_impl_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompositorMessageToImpl::set_has_initialize_impl_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompositorMessageToImpl::clear_has_initialize_impl_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompositorMessageToImpl::clear_initialize_impl_message() {
  if (initialize_impl_message_ != NULL) initialize_impl_message_->::cc::proto::InitializeImpl::Clear();
  clear_has_initialize_impl_message();
}
inline const ::cc::proto::InitializeImpl& CompositorMessageToImpl::initialize_impl_message() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return initialize_impl_message_ != NULL ? *initialize_impl_message_ : *default_instance().initialize_impl_message_;
#else
  return initialize_impl_message_ != NULL ? *initialize_impl_message_ : *default_instance_->initialize_impl_message_;
#endif
}
inline ::cc::proto::InitializeImpl* CompositorMessageToImpl::mutable_initialize_impl_message() {
  set_has_initialize_impl_message();
  if (initialize_impl_message_ == NULL) initialize_impl_message_ = new ::cc::proto::InitializeImpl;
  return initialize_impl_message_;
}
inline ::cc::proto::InitializeImpl* CompositorMessageToImpl::release_initialize_impl_message() {
  clear_has_initialize_impl_message();
  ::cc::proto::InitializeImpl* temp = initialize_impl_message_;
  initialize_impl_message_ = NULL;
  return temp;
}
inline void CompositorMessageToImpl::set_allocated_initialize_impl_message(::cc::proto::InitializeImpl* initialize_impl_message) {
  delete initialize_impl_message_;
  initialize_impl_message_ = initialize_impl_message;
  if (initialize_impl_message) {
    set_has_initialize_impl_message();
  } else {
    clear_has_initialize_impl_message();
  }
}

// optional .cc.proto.SetDeferCommits defer_commits_message = 3;
inline bool CompositorMessageToImpl::has_defer_commits_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CompositorMessageToImpl::set_has_defer_commits_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CompositorMessageToImpl::clear_has_defer_commits_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CompositorMessageToImpl::clear_defer_commits_message() {
  if (defer_commits_message_ != NULL) defer_commits_message_->::cc::proto::SetDeferCommits::Clear();
  clear_has_defer_commits_message();
}
inline const ::cc::proto::SetDeferCommits& CompositorMessageToImpl::defer_commits_message() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return defer_commits_message_ != NULL ? *defer_commits_message_ : *default_instance().defer_commits_message_;
#else
  return defer_commits_message_ != NULL ? *defer_commits_message_ : *default_instance_->defer_commits_message_;
#endif
}
inline ::cc::proto::SetDeferCommits* CompositorMessageToImpl::mutable_defer_commits_message() {
  set_has_defer_commits_message();
  if (defer_commits_message_ == NULL) defer_commits_message_ = new ::cc::proto::SetDeferCommits;
  return defer_commits_message_;
}
inline ::cc::proto::SetDeferCommits* CompositorMessageToImpl::release_defer_commits_message() {
  clear_has_defer_commits_message();
  ::cc::proto::SetDeferCommits* temp = defer_commits_message_;
  defer_commits_message_ = NULL;
  return temp;
}
inline void CompositorMessageToImpl::set_allocated_defer_commits_message(::cc::proto::SetDeferCommits* defer_commits_message) {
  delete defer_commits_message_;
  defer_commits_message_ = defer_commits_message;
  if (defer_commits_message) {
    set_has_defer_commits_message();
  } else {
    clear_has_defer_commits_message();
  }
}

// optional .cc.proto.StartCommit start_commit_message = 4;
inline bool CompositorMessageToImpl::has_start_commit_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CompositorMessageToImpl::set_has_start_commit_message() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CompositorMessageToImpl::clear_has_start_commit_message() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CompositorMessageToImpl::clear_start_commit_message() {
  if (start_commit_message_ != NULL) start_commit_message_->::cc::proto::StartCommit::Clear();
  clear_has_start_commit_message();
}
inline const ::cc::proto::StartCommit& CompositorMessageToImpl::start_commit_message() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return start_commit_message_ != NULL ? *start_commit_message_ : *default_instance().start_commit_message_;
#else
  return start_commit_message_ != NULL ? *start_commit_message_ : *default_instance_->start_commit_message_;
#endif
}
inline ::cc::proto::StartCommit* CompositorMessageToImpl::mutable_start_commit_message() {
  set_has_start_commit_message();
  if (start_commit_message_ == NULL) start_commit_message_ = new ::cc::proto::StartCommit;
  return start_commit_message_;
}
inline ::cc::proto::StartCommit* CompositorMessageToImpl::release_start_commit_message() {
  clear_has_start_commit_message();
  ::cc::proto::StartCommit* temp = start_commit_message_;
  start_commit_message_ = NULL;
  return temp;
}
inline void CompositorMessageToImpl::set_allocated_start_commit_message(::cc::proto::StartCommit* start_commit_message) {
  delete start_commit_message_;
  start_commit_message_ = start_commit_message;
  if (start_commit_message) {
    set_has_start_commit_message();
  } else {
    clear_has_start_commit_message();
  }
}

// optional .cc.proto.BeginMainFrameAborted begin_main_frame_aborted_message = 5;
inline bool CompositorMessageToImpl::has_begin_main_frame_aborted_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CompositorMessageToImpl::set_has_begin_main_frame_aborted_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CompositorMessageToImpl::clear_has_begin_main_frame_aborted_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CompositorMessageToImpl::clear_begin_main_frame_aborted_message() {
  if (begin_main_frame_aborted_message_ != NULL) begin_main_frame_aborted_message_->::cc::proto::BeginMainFrameAborted::Clear();
  clear_has_begin_main_frame_aborted_message();
}
inline const ::cc::proto::BeginMainFrameAborted& CompositorMessageToImpl::begin_main_frame_aborted_message() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return begin_main_frame_aborted_message_ != NULL ? *begin_main_frame_aborted_message_ : *default_instance().begin_main_frame_aborted_message_;
#else
  return begin_main_frame_aborted_message_ != NULL ? *begin_main_frame_aborted_message_ : *default_instance_->begin_main_frame_aborted_message_;
#endif
}
inline ::cc::proto::BeginMainFrameAborted* CompositorMessageToImpl::mutable_begin_main_frame_aborted_message() {
  set_has_begin_main_frame_aborted_message();
  if (begin_main_frame_aborted_message_ == NULL) begin_main_frame_aborted_message_ = new ::cc::proto::BeginMainFrameAborted;
  return begin_main_frame_aborted_message_;
}
inline ::cc::proto::BeginMainFrameAborted* CompositorMessageToImpl::release_begin_main_frame_aborted_message() {
  clear_has_begin_main_frame_aborted_message();
  ::cc::proto::BeginMainFrameAborted* temp = begin_main_frame_aborted_message_;
  begin_main_frame_aborted_message_ = NULL;
  return temp;
}
inline void CompositorMessageToImpl::set_allocated_begin_main_frame_aborted_message(::cc::proto::BeginMainFrameAborted* begin_main_frame_aborted_message) {
  delete begin_main_frame_aborted_message_;
  begin_main_frame_aborted_message_ = begin_main_frame_aborted_message;
  if (begin_main_frame_aborted_message) {
    set_has_begin_main_frame_aborted_message();
  } else {
    clear_has_begin_main_frame_aborted_message();
  }
}

// optional .cc.proto.SetNeedsRedraw set_needs_redraw_message = 6;
inline bool CompositorMessageToImpl::has_set_needs_redraw_message() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CompositorMessageToImpl::set_has_set_needs_redraw_message() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CompositorMessageToImpl::clear_has_set_needs_redraw_message() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CompositorMessageToImpl::clear_set_needs_redraw_message() {
  if (set_needs_redraw_message_ != NULL) set_needs_redraw_message_->::cc::proto::SetNeedsRedraw::Clear();
  clear_has_set_needs_redraw_message();
}
inline const ::cc::proto::SetNeedsRedraw& CompositorMessageToImpl::set_needs_redraw_message() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return set_needs_redraw_message_ != NULL ? *set_needs_redraw_message_ : *default_instance().set_needs_redraw_message_;
#else
  return set_needs_redraw_message_ != NULL ? *set_needs_redraw_message_ : *default_instance_->set_needs_redraw_message_;
#endif
}
inline ::cc::proto::SetNeedsRedraw* CompositorMessageToImpl::mutable_set_needs_redraw_message() {
  set_has_set_needs_redraw_message();
  if (set_needs_redraw_message_ == NULL) set_needs_redraw_message_ = new ::cc::proto::SetNeedsRedraw;
  return set_needs_redraw_message_;
}
inline ::cc::proto::SetNeedsRedraw* CompositorMessageToImpl::release_set_needs_redraw_message() {
  clear_has_set_needs_redraw_message();
  ::cc::proto::SetNeedsRedraw* temp = set_needs_redraw_message_;
  set_needs_redraw_message_ = NULL;
  return temp;
}
inline void CompositorMessageToImpl::set_allocated_set_needs_redraw_message(::cc::proto::SetNeedsRedraw* set_needs_redraw_message) {
  delete set_needs_redraw_message_;
  set_needs_redraw_message_ = set_needs_redraw_message;
  if (set_needs_redraw_message) {
    set_has_set_needs_redraw_message();
  } else {
    clear_has_set_needs_redraw_message();
  }
}

// -------------------------------------------------------------------

// InitializeImpl

// optional .cc.proto.LayerTreeSettings layer_tree_settings = 1;
inline bool InitializeImpl::has_layer_tree_settings() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitializeImpl::set_has_layer_tree_settings() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitializeImpl::clear_has_layer_tree_settings() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitializeImpl::clear_layer_tree_settings() {
  if (layer_tree_settings_ != NULL) layer_tree_settings_->::cc::proto::LayerTreeSettings::Clear();
  clear_has_layer_tree_settings();
}
inline const ::cc::proto::LayerTreeSettings& InitializeImpl::layer_tree_settings() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return layer_tree_settings_ != NULL ? *layer_tree_settings_ : *default_instance().layer_tree_settings_;
#else
  return layer_tree_settings_ != NULL ? *layer_tree_settings_ : *default_instance_->layer_tree_settings_;
#endif
}
inline ::cc::proto::LayerTreeSettings* InitializeImpl::mutable_layer_tree_settings() {
  set_has_layer_tree_settings();
  if (layer_tree_settings_ == NULL) layer_tree_settings_ = new ::cc::proto::LayerTreeSettings;
  return layer_tree_settings_;
}
inline ::cc::proto::LayerTreeSettings* InitializeImpl::release_layer_tree_settings() {
  clear_has_layer_tree_settings();
  ::cc::proto::LayerTreeSettings* temp = layer_tree_settings_;
  layer_tree_settings_ = NULL;
  return temp;
}
inline void InitializeImpl::set_allocated_layer_tree_settings(::cc::proto::LayerTreeSettings* layer_tree_settings) {
  delete layer_tree_settings_;
  layer_tree_settings_ = layer_tree_settings;
  if (layer_tree_settings) {
    set_has_layer_tree_settings();
  } else {
    clear_has_layer_tree_settings();
  }
}

// -------------------------------------------------------------------

// SetDeferCommits

// optional bool defer_commits = 1;
inline bool SetDeferCommits::has_defer_commits() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetDeferCommits::set_has_defer_commits() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetDeferCommits::clear_has_defer_commits() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetDeferCommits::clear_defer_commits() {
  defer_commits_ = false;
  clear_has_defer_commits();
}
inline bool SetDeferCommits::defer_commits() const {
  return defer_commits_;
}
inline void SetDeferCommits::set_defer_commits(bool value) {
  set_has_defer_commits();
  defer_commits_ = value;
}

// -------------------------------------------------------------------

// StartCommit

// optional .cc.proto.LayerTreeHost layer_tree_host = 1;
inline bool StartCommit::has_layer_tree_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartCommit::set_has_layer_tree_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartCommit::clear_has_layer_tree_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartCommit::clear_layer_tree_host() {
  if (layer_tree_host_ != NULL) layer_tree_host_->::cc::proto::LayerTreeHost::Clear();
  clear_has_layer_tree_host();
}
inline const ::cc::proto::LayerTreeHost& StartCommit::layer_tree_host() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return layer_tree_host_ != NULL ? *layer_tree_host_ : *default_instance().layer_tree_host_;
#else
  return layer_tree_host_ != NULL ? *layer_tree_host_ : *default_instance_->layer_tree_host_;
#endif
}
inline ::cc::proto::LayerTreeHost* StartCommit::mutable_layer_tree_host() {
  set_has_layer_tree_host();
  if (layer_tree_host_ == NULL) layer_tree_host_ = new ::cc::proto::LayerTreeHost;
  return layer_tree_host_;
}
inline ::cc::proto::LayerTreeHost* StartCommit::release_layer_tree_host() {
  clear_has_layer_tree_host();
  ::cc::proto::LayerTreeHost* temp = layer_tree_host_;
  layer_tree_host_ = NULL;
  return temp;
}
inline void StartCommit::set_allocated_layer_tree_host(::cc::proto::LayerTreeHost* layer_tree_host) {
  delete layer_tree_host_;
  layer_tree_host_ = layer_tree_host;
  if (layer_tree_host) {
    set_has_layer_tree_host();
  } else {
    clear_has_layer_tree_host();
  }
}

// -------------------------------------------------------------------

// BeginMainFrameAborted

// optional .cc.proto.CommitEarlyOutReason reason = 1;
inline bool BeginMainFrameAborted::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BeginMainFrameAborted::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BeginMainFrameAborted::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BeginMainFrameAborted::clear_reason() {
  if (reason_ != NULL) reason_->::cc::proto::CommitEarlyOutReason::Clear();
  clear_has_reason();
}
inline const ::cc::proto::CommitEarlyOutReason& BeginMainFrameAborted::reason() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return reason_ != NULL ? *reason_ : *default_instance().reason_;
#else
  return reason_ != NULL ? *reason_ : *default_instance_->reason_;
#endif
}
inline ::cc::proto::CommitEarlyOutReason* BeginMainFrameAborted::mutable_reason() {
  set_has_reason();
  if (reason_ == NULL) reason_ = new ::cc::proto::CommitEarlyOutReason;
  return reason_;
}
inline ::cc::proto::CommitEarlyOutReason* BeginMainFrameAborted::release_reason() {
  clear_has_reason();
  ::cc::proto::CommitEarlyOutReason* temp = reason_;
  reason_ = NULL;
  return temp;
}
inline void BeginMainFrameAborted::set_allocated_reason(::cc::proto::CommitEarlyOutReason* reason) {
  delete reason_;
  reason_ = reason;
  if (reason) {
    set_has_reason();
  } else {
    clear_has_reason();
  }
}

// -------------------------------------------------------------------

// SetNeedsRedraw

// optional .cc.proto.Rect damaged_rect = 1;
inline bool SetNeedsRedraw::has_damaged_rect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetNeedsRedraw::set_has_damaged_rect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetNeedsRedraw::clear_has_damaged_rect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetNeedsRedraw::clear_damaged_rect() {
  if (damaged_rect_ != NULL) damaged_rect_->::cc::proto::Rect::Clear();
  clear_has_damaged_rect();
}
inline const ::cc::proto::Rect& SetNeedsRedraw::damaged_rect() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return damaged_rect_ != NULL ? *damaged_rect_ : *default_instance().damaged_rect_;
#else
  return damaged_rect_ != NULL ? *damaged_rect_ : *default_instance_->damaged_rect_;
#endif
}
inline ::cc::proto::Rect* SetNeedsRedraw::mutable_damaged_rect() {
  set_has_damaged_rect();
  if (damaged_rect_ == NULL) damaged_rect_ = new ::cc::proto::Rect;
  return damaged_rect_;
}
inline ::cc::proto::Rect* SetNeedsRedraw::release_damaged_rect() {
  clear_has_damaged_rect();
  ::cc::proto::Rect* temp = damaged_rect_;
  damaged_rect_ = NULL;
  return temp;
}
inline void SetNeedsRedraw::set_allocated_damaged_rect(::cc::proto::Rect* damaged_rect) {
  delete damaged_rect_;
  damaged_rect_ = damaged_rect;
  if (damaged_rect) {
    set_has_damaged_rect();
  } else {
    clear_has_damaged_rect();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_compositor_5fmessage_5fto_5fimpl_2eproto__INCLUDED
