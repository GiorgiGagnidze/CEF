// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: layer_tree_settings.proto

#ifndef PROTOBUF_layer_5ftree_5fsettings_2eproto__INCLUDED
#define PROTOBUF_layer_5ftree_5fsettings_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "layer_tree_debug_state.pb.h"
#include "managed_memory_policy.pb.h"
#include "renderer_settings.pb.h"
#include "size.pb.h"
// @@protoc_insertion_point(includes)
#include "cc/proto/cc_proto_export.h"

namespace cc {
namespace proto {

// Internal implementation detail -- do not call these.
void CC_PROTO_EXPORT protobuf_AddDesc_layer_5ftree_5fsettings_2eproto();
void protobuf_AssignDesc_layer_5ftree_5fsettings_2eproto();
void protobuf_ShutdownFile_layer_5ftree_5fsettings_2eproto();

class LayerTreeSettings;

enum LayerTreeSettings_ScrollbarAnimator {
  LayerTreeSettings_ScrollbarAnimator_UNKNOWN = 0,
  LayerTreeSettings_ScrollbarAnimator_NO_ANIMATOR = 1,
  LayerTreeSettings_ScrollbarAnimator_LINEAR_FADE = 2,
  LayerTreeSettings_ScrollbarAnimator_THINNING = 3
};
CC_PROTO_EXPORT bool LayerTreeSettings_ScrollbarAnimator_IsValid(int value);
const LayerTreeSettings_ScrollbarAnimator LayerTreeSettings_ScrollbarAnimator_ScrollbarAnimator_MIN = LayerTreeSettings_ScrollbarAnimator_UNKNOWN;
const LayerTreeSettings_ScrollbarAnimator LayerTreeSettings_ScrollbarAnimator_ScrollbarAnimator_MAX = LayerTreeSettings_ScrollbarAnimator_THINNING;
const int LayerTreeSettings_ScrollbarAnimator_ScrollbarAnimator_ARRAYSIZE = LayerTreeSettings_ScrollbarAnimator_ScrollbarAnimator_MAX + 1;

// ===================================================================

class CC_PROTO_EXPORT LayerTreeSettings : public ::google::protobuf::MessageLite {
 public:
  LayerTreeSettings();
  virtual ~LayerTreeSettings();

  LayerTreeSettings(const LayerTreeSettings& from);

  inline LayerTreeSettings& operator=(const LayerTreeSettings& from) {
    CopyFrom(from);
    return *this;
  }

  static const LayerTreeSettings& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LayerTreeSettings* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LayerTreeSettings* other);

  // implements Message ----------------------------------------------

  LayerTreeSettings* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LayerTreeSettings& from);
  void MergeFrom(const LayerTreeSettings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LayerTreeSettings_ScrollbarAnimator ScrollbarAnimator;
  static const ScrollbarAnimator UNKNOWN = LayerTreeSettings_ScrollbarAnimator_UNKNOWN;
  static const ScrollbarAnimator NO_ANIMATOR = LayerTreeSettings_ScrollbarAnimator_NO_ANIMATOR;
  static const ScrollbarAnimator LINEAR_FADE = LayerTreeSettings_ScrollbarAnimator_LINEAR_FADE;
  static const ScrollbarAnimator THINNING = LayerTreeSettings_ScrollbarAnimator_THINNING;
  static inline bool ScrollbarAnimator_IsValid(int value) {
    return LayerTreeSettings_ScrollbarAnimator_IsValid(value);
  }
  static const ScrollbarAnimator ScrollbarAnimator_MIN =
    LayerTreeSettings_ScrollbarAnimator_ScrollbarAnimator_MIN;
  static const ScrollbarAnimator ScrollbarAnimator_MAX =
    LayerTreeSettings_ScrollbarAnimator_ScrollbarAnimator_MAX;
  static const int ScrollbarAnimator_ARRAYSIZE =
    LayerTreeSettings_ScrollbarAnimator_ScrollbarAnimator_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .cc.proto.RendererSettings renderer_settings = 1;
  inline bool has_renderer_settings() const;
  inline void clear_renderer_settings();
  static const int kRendererSettingsFieldNumber = 1;
  inline const ::cc::proto::RendererSettings& renderer_settings() const;
  inline ::cc::proto::RendererSettings* mutable_renderer_settings();
  inline ::cc::proto::RendererSettings* release_renderer_settings();
  inline void set_allocated_renderer_settings(::cc::proto::RendererSettings* renderer_settings);

  // optional bool single_thread_proxy_scheduler = 2;
  inline bool has_single_thread_proxy_scheduler() const;
  inline void clear_single_thread_proxy_scheduler();
  static const int kSingleThreadProxySchedulerFieldNumber = 2;
  inline bool single_thread_proxy_scheduler() const;
  inline void set_single_thread_proxy_scheduler(bool value);

  // optional bool use_external_begin_frame_source = 3;
  inline bool has_use_external_begin_frame_source() const;
  inline void clear_use_external_begin_frame_source();
  static const int kUseExternalBeginFrameSourceFieldNumber = 3;
  inline bool use_external_begin_frame_source() const;
  inline void set_use_external_begin_frame_source(bool value);

  // optional bool main_frame_before_activation_enabled = 4;
  inline bool has_main_frame_before_activation_enabled() const;
  inline void clear_main_frame_before_activation_enabled();
  static const int kMainFrameBeforeActivationEnabledFieldNumber = 4;
  inline bool main_frame_before_activation_enabled() const;
  inline void set_main_frame_before_activation_enabled(bool value);

  // optional bool using_synchronous_renderer_compositor = 5;
  inline bool has_using_synchronous_renderer_compositor() const;
  inline void clear_using_synchronous_renderer_compositor();
  static const int kUsingSynchronousRendererCompositorFieldNumber = 5;
  inline bool using_synchronous_renderer_compositor() const;
  inline void set_using_synchronous_renderer_compositor(bool value);

  // optional bool accelerated_animation_enabled = 6;
  inline bool has_accelerated_animation_enabled() const;
  inline void clear_accelerated_animation_enabled();
  static const int kAcceleratedAnimationEnabledFieldNumber = 6;
  inline bool accelerated_animation_enabled() const;
  inline void set_accelerated_animation_enabled(bool value);

  // optional bool can_use_lcd_text = 7;
  inline bool has_can_use_lcd_text() const;
  inline void clear_can_use_lcd_text();
  static const int kCanUseLcdTextFieldNumber = 7;
  inline bool can_use_lcd_text() const;
  inline void set_can_use_lcd_text(bool value);

  // optional bool use_distance_field_text = 8;
  inline bool has_use_distance_field_text() const;
  inline void clear_use_distance_field_text();
  static const int kUseDistanceFieldTextFieldNumber = 8;
  inline bool use_distance_field_text() const;
  inline void set_use_distance_field_text(bool value);

  // optional bool gpu_rasterization_enabled = 9;
  inline bool has_gpu_rasterization_enabled() const;
  inline void clear_gpu_rasterization_enabled();
  static const int kGpuRasterizationEnabledFieldNumber = 9;
  inline bool gpu_rasterization_enabled() const;
  inline void set_gpu_rasterization_enabled(bool value);

  // optional bool gpu_rasterization_forced = 10;
  inline bool has_gpu_rasterization_forced() const;
  inline void clear_gpu_rasterization_forced();
  static const int kGpuRasterizationForcedFieldNumber = 10;
  inline bool gpu_rasterization_forced() const;
  inline void set_gpu_rasterization_forced(bool value);

  // optional int32 gpu_rasterization_msaa_sample_count = 11;
  inline bool has_gpu_rasterization_msaa_sample_count() const;
  inline void clear_gpu_rasterization_msaa_sample_count();
  static const int kGpuRasterizationMsaaSampleCountFieldNumber = 11;
  inline ::google::protobuf::int32 gpu_rasterization_msaa_sample_count() const;
  inline void set_gpu_rasterization_msaa_sample_count(::google::protobuf::int32 value);

  // optional float gpu_rasterization_skewport_target_time_in_seconds = 12;
  inline bool has_gpu_rasterization_skewport_target_time_in_seconds() const;
  inline void clear_gpu_rasterization_skewport_target_time_in_seconds();
  static const int kGpuRasterizationSkewportTargetTimeInSecondsFieldNumber = 12;
  inline float gpu_rasterization_skewport_target_time_in_seconds() const;
  inline void set_gpu_rasterization_skewport_target_time_in_seconds(float value);

  // optional bool create_low_res_tiling = 13;
  inline bool has_create_low_res_tiling() const;
  inline void clear_create_low_res_tiling();
  static const int kCreateLowResTilingFieldNumber = 13;
  inline bool create_low_res_tiling() const;
  inline void set_create_low_res_tiling(bool value);

  // optional .cc.proto.LayerTreeSettings.ScrollbarAnimator scrollbar_animator = 14;
  inline bool has_scrollbar_animator() const;
  inline void clear_scrollbar_animator();
  static const int kScrollbarAnimatorFieldNumber = 14;
  inline ::cc::proto::LayerTreeSettings_ScrollbarAnimator scrollbar_animator() const;
  inline void set_scrollbar_animator(::cc::proto::LayerTreeSettings_ScrollbarAnimator value);

  // optional int32 scrollbar_fade_delay_ms = 15;
  inline bool has_scrollbar_fade_delay_ms() const;
  inline void clear_scrollbar_fade_delay_ms();
  static const int kScrollbarFadeDelayMsFieldNumber = 15;
  inline ::google::protobuf::int32 scrollbar_fade_delay_ms() const;
  inline void set_scrollbar_fade_delay_ms(::google::protobuf::int32 value);

  // optional int32 scrollbar_fade_resize_delay_ms = 16;
  inline bool has_scrollbar_fade_resize_delay_ms() const;
  inline void clear_scrollbar_fade_resize_delay_ms();
  static const int kScrollbarFadeResizeDelayMsFieldNumber = 16;
  inline ::google::protobuf::int32 scrollbar_fade_resize_delay_ms() const;
  inline void set_scrollbar_fade_resize_delay_ms(::google::protobuf::int32 value);

  // optional int32 scrollbar_fade_duration_ms = 17;
  inline bool has_scrollbar_fade_duration_ms() const;
  inline void clear_scrollbar_fade_duration_ms();
  static const int kScrollbarFadeDurationMsFieldNumber = 17;
  inline ::google::protobuf::int32 scrollbar_fade_duration_ms() const;
  inline void set_scrollbar_fade_duration_ms(::google::protobuf::int32 value);

  // optional uint32 solid_color_scrollbar_color = 18;
  inline bool has_solid_color_scrollbar_color() const;
  inline void clear_solid_color_scrollbar_color();
  static const int kSolidColorScrollbarColorFieldNumber = 18;
  inline ::google::protobuf::uint32 solid_color_scrollbar_color() const;
  inline void set_solid_color_scrollbar_color(::google::protobuf::uint32 value);

  // optional bool timeout_and_draw_when_animation_checkerboards = 19;
  inline bool has_timeout_and_draw_when_animation_checkerboards() const;
  inline void clear_timeout_and_draw_when_animation_checkerboards();
  static const int kTimeoutAndDrawWhenAnimationCheckerboardsFieldNumber = 19;
  inline bool timeout_and_draw_when_animation_checkerboards() const;
  inline void set_timeout_and_draw_when_animation_checkerboards(bool value);

  // optional bool layer_transforms_should_scale_layer_contents = 20;
  inline bool has_layer_transforms_should_scale_layer_contents() const;
  inline void clear_layer_transforms_should_scale_layer_contents();
  static const int kLayerTransformsShouldScaleLayerContentsFieldNumber = 20;
  inline bool layer_transforms_should_scale_layer_contents() const;
  inline void set_layer_transforms_should_scale_layer_contents(bool value);

  // optional bool layers_always_allowed_lcd_text = 21;
  inline bool has_layers_always_allowed_lcd_text() const;
  inline void clear_layers_always_allowed_lcd_text();
  static const int kLayersAlwaysAllowedLcdTextFieldNumber = 21;
  inline bool layers_always_allowed_lcd_text() const;
  inline void set_layers_always_allowed_lcd_text(bool value);

  // optional float minimum_contents_scale = 22;
  inline bool has_minimum_contents_scale() const;
  inline void clear_minimum_contents_scale();
  static const int kMinimumContentsScaleFieldNumber = 22;
  inline float minimum_contents_scale() const;
  inline void set_minimum_contents_scale(float value);

  // optional float low_res_contents_scale_factor = 23;
  inline bool has_low_res_contents_scale_factor() const;
  inline void clear_low_res_contents_scale_factor();
  static const int kLowResContentsScaleFactorFieldNumber = 23;
  inline float low_res_contents_scale_factor() const;
  inline void set_low_res_contents_scale_factor(float value);

  // optional float top_controls_show_threshold = 24;
  inline bool has_top_controls_show_threshold() const;
  inline void clear_top_controls_show_threshold();
  static const int kTopControlsShowThresholdFieldNumber = 24;
  inline float top_controls_show_threshold() const;
  inline void set_top_controls_show_threshold(float value);

  // optional float top_controls_hide_threshold = 25;
  inline bool has_top_controls_hide_threshold() const;
  inline void clear_top_controls_hide_threshold();
  static const int kTopControlsHideThresholdFieldNumber = 25;
  inline float top_controls_hide_threshold() const;
  inline void set_top_controls_hide_threshold(float value);

  // optional double background_animation_rate = 26;
  inline bool has_background_animation_rate() const;
  inline void clear_background_animation_rate();
  static const int kBackgroundAnimationRateFieldNumber = 26;
  inline double background_animation_rate() const;
  inline void set_background_animation_rate(double value);

  // optional .cc.proto.Size default_tile_size = 27;
  inline bool has_default_tile_size() const;
  inline void clear_default_tile_size();
  static const int kDefaultTileSizeFieldNumber = 27;
  inline const ::cc::proto::Size& default_tile_size() const;
  inline ::cc::proto::Size* mutable_default_tile_size();
  inline ::cc::proto::Size* release_default_tile_size();
  inline void set_allocated_default_tile_size(::cc::proto::Size* default_tile_size);

  // optional .cc.proto.Size max_untiled_layer_size = 28;
  inline bool has_max_untiled_layer_size() const;
  inline void clear_max_untiled_layer_size();
  static const int kMaxUntiledLayerSizeFieldNumber = 28;
  inline const ::cc::proto::Size& max_untiled_layer_size() const;
  inline ::cc::proto::Size* mutable_max_untiled_layer_size();
  inline ::cc::proto::Size* release_max_untiled_layer_size();
  inline void set_allocated_max_untiled_layer_size(::cc::proto::Size* max_untiled_layer_size);

  // optional .cc.proto.Size minimum_occlusion_tracking_size = 29;
  inline bool has_minimum_occlusion_tracking_size() const;
  inline void clear_minimum_occlusion_tracking_size();
  static const int kMinimumOcclusionTrackingSizeFieldNumber = 29;
  inline const ::cc::proto::Size& minimum_occlusion_tracking_size() const;
  inline ::cc::proto::Size* mutable_minimum_occlusion_tracking_size();
  inline ::cc::proto::Size* release_minimum_occlusion_tracking_size();
  inline void set_allocated_minimum_occlusion_tracking_size(::cc::proto::Size* minimum_occlusion_tracking_size);

  // optional uint32 tiling_interest_area_padding = 30;
  inline bool has_tiling_interest_area_padding() const;
  inline void clear_tiling_interest_area_padding();
  static const int kTilingInterestAreaPaddingFieldNumber = 30;
  inline ::google::protobuf::uint32 tiling_interest_area_padding() const;
  inline void set_tiling_interest_area_padding(::google::protobuf::uint32 value);

  // optional float skewport_target_time_in_seconds = 31;
  inline bool has_skewport_target_time_in_seconds() const;
  inline void clear_skewport_target_time_in_seconds();
  static const int kSkewportTargetTimeInSecondsFieldNumber = 31;
  inline float skewport_target_time_in_seconds() const;
  inline void set_skewport_target_time_in_seconds(float value);

  // optional int32 skewport_extrapolation_limit_in_content_pixels = 32;
  inline bool has_skewport_extrapolation_limit_in_content_pixels() const;
  inline void clear_skewport_extrapolation_limit_in_content_pixels();
  static const int kSkewportExtrapolationLimitInContentPixelsFieldNumber = 32;
  inline ::google::protobuf::int32 skewport_extrapolation_limit_in_content_pixels() const;
  inline void set_skewport_extrapolation_limit_in_content_pixels(::google::protobuf::int32 value);

  // optional uint32 max_memory_for_prepaint_percentage = 33;
  inline bool has_max_memory_for_prepaint_percentage() const;
  inline void clear_max_memory_for_prepaint_percentage();
  static const int kMaxMemoryForPrepaintPercentageFieldNumber = 33;
  inline ::google::protobuf::uint32 max_memory_for_prepaint_percentage() const;
  inline void set_max_memory_for_prepaint_percentage(::google::protobuf::uint32 value);

  // optional bool strict_layer_property_change_checking = 34;
  inline bool has_strict_layer_property_change_checking() const;
  inline void clear_strict_layer_property_change_checking();
  static const int kStrictLayerPropertyChangeCheckingFieldNumber = 34;
  inline bool strict_layer_property_change_checking() const;
  inline void set_strict_layer_property_change_checking(bool value);

  // optional bool use_zero_copy = 35;
  inline bool has_use_zero_copy() const;
  inline void clear_use_zero_copy();
  static const int kUseZeroCopyFieldNumber = 35;
  inline bool use_zero_copy() const;
  inline void set_use_zero_copy(bool value);

  // optional bool use_partial_raster = 36;
  inline bool has_use_partial_raster() const;
  inline void clear_use_partial_raster();
  static const int kUsePartialRasterFieldNumber = 36;
  inline bool use_partial_raster() const;
  inline void set_use_partial_raster(bool value);

  // optional bool enable_elastic_overscroll = 37;
  inline bool has_enable_elastic_overscroll() const;
  inline void clear_enable_elastic_overscroll();
  static const int kEnableElasticOverscrollFieldNumber = 37;
  inline bool enable_elastic_overscroll() const;
  inline void set_enable_elastic_overscroll(bool value);

  // repeated uint32 use_image_texture_targets = 38;
  inline int use_image_texture_targets_size() const;
  inline void clear_use_image_texture_targets();
  static const int kUseImageTextureTargetsFieldNumber = 38;
  inline ::google::protobuf::uint32 use_image_texture_targets(int index) const;
  inline void set_use_image_texture_targets(int index, ::google::protobuf::uint32 value);
  inline void add_use_image_texture_targets(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      use_image_texture_targets() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_use_image_texture_targets();

  // optional bool ignore_root_layer_flings = 39;
  inline bool has_ignore_root_layer_flings() const;
  inline void clear_ignore_root_layer_flings();
  static const int kIgnoreRootLayerFlingsFieldNumber = 39;
  inline bool ignore_root_layer_flings() const;
  inline void set_ignore_root_layer_flings(bool value);

  // optional uint32 scheduled_raster_task_limit = 40;
  inline bool has_scheduled_raster_task_limit() const;
  inline void clear_scheduled_raster_task_limit();
  static const int kScheduledRasterTaskLimitFieldNumber = 40;
  inline ::google::protobuf::uint32 scheduled_raster_task_limit() const;
  inline void set_scheduled_raster_task_limit(::google::protobuf::uint32 value);

  // optional bool use_occlusion_for_tile_prioritization = 41;
  inline bool has_use_occlusion_for_tile_prioritization() const;
  inline void clear_use_occlusion_for_tile_prioritization();
  static const int kUseOcclusionForTilePrioritizationFieldNumber = 41;
  inline bool use_occlusion_for_tile_prioritization() const;
  inline void set_use_occlusion_for_tile_prioritization(bool value);

  // optional bool verify_property_trees = 42;
  inline bool has_verify_property_trees() const;
  inline void clear_verify_property_trees();
  static const int kVerifyPropertyTreesFieldNumber = 42;
  inline bool verify_property_trees() const;
  inline void set_verify_property_trees(bool value);

  // optional bool use_property_trees = 43;
  inline bool has_use_property_trees() const;
  inline void clear_use_property_trees();
  static const int kUsePropertyTreesFieldNumber = 43;
  inline bool use_property_trees() const;
  inline void set_use_property_trees(bool value);

  // optional bool image_decode_tasks_enabled = 44;
  inline bool has_image_decode_tasks_enabled() const;
  inline void clear_image_decode_tasks_enabled();
  static const int kImageDecodeTasksEnabledFieldNumber = 44;
  inline bool image_decode_tasks_enabled() const;
  inline void set_image_decode_tasks_enabled(bool value);

  // optional bool use_compositor_animation_timelines = 45;
  inline bool has_use_compositor_animation_timelines() const;
  inline void clear_use_compositor_animation_timelines();
  static const int kUseCompositorAnimationTimelinesFieldNumber = 45;
  inline bool use_compositor_animation_timelines() const;
  inline void set_use_compositor_animation_timelines(bool value);

  // optional bool wait_for_beginframe_interval = 46;
  inline bool has_wait_for_beginframe_interval() const;
  inline void clear_wait_for_beginframe_interval();
  static const int kWaitForBeginframeIntervalFieldNumber = 46;
  inline bool wait_for_beginframe_interval() const;
  inline void set_wait_for_beginframe_interval(bool value);

  // optional int32 max_staging_buffer_usage_in_bytes = 47;
  inline bool has_max_staging_buffer_usage_in_bytes() const;
  inline void clear_max_staging_buffer_usage_in_bytes();
  static const int kMaxStagingBufferUsageInBytesFieldNumber = 47;
  inline ::google::protobuf::int32 max_staging_buffer_usage_in_bytes() const;
  inline void set_max_staging_buffer_usage_in_bytes(::google::protobuf::int32 value);

  // optional .cc.proto.ManagedMemoryPolicy memory_policy = 48;
  inline bool has_memory_policy() const;
  inline void clear_memory_policy();
  static const int kMemoryPolicyFieldNumber = 48;
  inline const ::cc::proto::ManagedMemoryPolicy& memory_policy() const;
  inline ::cc::proto::ManagedMemoryPolicy* mutable_memory_policy();
  inline ::cc::proto::ManagedMemoryPolicy* release_memory_policy();
  inline void set_allocated_memory_policy(::cc::proto::ManagedMemoryPolicy* memory_policy);

  // optional .cc.proto.LayerTreeDebugState initial_debug_state = 49;
  inline bool has_initial_debug_state() const;
  inline void clear_initial_debug_state();
  static const int kInitialDebugStateFieldNumber = 49;
  inline const ::cc::proto::LayerTreeDebugState& initial_debug_state() const;
  inline ::cc::proto::LayerTreeDebugState* mutable_initial_debug_state();
  inline ::cc::proto::LayerTreeDebugState* release_initial_debug_state();
  inline void set_allocated_initial_debug_state(::cc::proto::LayerTreeDebugState* initial_debug_state);

  // @@protoc_insertion_point(class_scope:cc.proto.LayerTreeSettings)
 private:
  inline void set_has_renderer_settings();
  inline void clear_has_renderer_settings();
  inline void set_has_single_thread_proxy_scheduler();
  inline void clear_has_single_thread_proxy_scheduler();
  inline void set_has_use_external_begin_frame_source();
  inline void clear_has_use_external_begin_frame_source();
  inline void set_has_main_frame_before_activation_enabled();
  inline void clear_has_main_frame_before_activation_enabled();
  inline void set_has_using_synchronous_renderer_compositor();
  inline void clear_has_using_synchronous_renderer_compositor();
  inline void set_has_accelerated_animation_enabled();
  inline void clear_has_accelerated_animation_enabled();
  inline void set_has_can_use_lcd_text();
  inline void clear_has_can_use_lcd_text();
  inline void set_has_use_distance_field_text();
  inline void clear_has_use_distance_field_text();
  inline void set_has_gpu_rasterization_enabled();
  inline void clear_has_gpu_rasterization_enabled();
  inline void set_has_gpu_rasterization_forced();
  inline void clear_has_gpu_rasterization_forced();
  inline void set_has_gpu_rasterization_msaa_sample_count();
  inline void clear_has_gpu_rasterization_msaa_sample_count();
  inline void set_has_gpu_rasterization_skewport_target_time_in_seconds();
  inline void clear_has_gpu_rasterization_skewport_target_time_in_seconds();
  inline void set_has_create_low_res_tiling();
  inline void clear_has_create_low_res_tiling();
  inline void set_has_scrollbar_animator();
  inline void clear_has_scrollbar_animator();
  inline void set_has_scrollbar_fade_delay_ms();
  inline void clear_has_scrollbar_fade_delay_ms();
  inline void set_has_scrollbar_fade_resize_delay_ms();
  inline void clear_has_scrollbar_fade_resize_delay_ms();
  inline void set_has_scrollbar_fade_duration_ms();
  inline void clear_has_scrollbar_fade_duration_ms();
  inline void set_has_solid_color_scrollbar_color();
  inline void clear_has_solid_color_scrollbar_color();
  inline void set_has_timeout_and_draw_when_animation_checkerboards();
  inline void clear_has_timeout_and_draw_when_animation_checkerboards();
  inline void set_has_layer_transforms_should_scale_layer_contents();
  inline void clear_has_layer_transforms_should_scale_layer_contents();
  inline void set_has_layers_always_allowed_lcd_text();
  inline void clear_has_layers_always_allowed_lcd_text();
  inline void set_has_minimum_contents_scale();
  inline void clear_has_minimum_contents_scale();
  inline void set_has_low_res_contents_scale_factor();
  inline void clear_has_low_res_contents_scale_factor();
  inline void set_has_top_controls_show_threshold();
  inline void clear_has_top_controls_show_threshold();
  inline void set_has_top_controls_hide_threshold();
  inline void clear_has_top_controls_hide_threshold();
  inline void set_has_background_animation_rate();
  inline void clear_has_background_animation_rate();
  inline void set_has_default_tile_size();
  inline void clear_has_default_tile_size();
  inline void set_has_max_untiled_layer_size();
  inline void clear_has_max_untiled_layer_size();
  inline void set_has_minimum_occlusion_tracking_size();
  inline void clear_has_minimum_occlusion_tracking_size();
  inline void set_has_tiling_interest_area_padding();
  inline void clear_has_tiling_interest_area_padding();
  inline void set_has_skewport_target_time_in_seconds();
  inline void clear_has_skewport_target_time_in_seconds();
  inline void set_has_skewport_extrapolation_limit_in_content_pixels();
  inline void clear_has_skewport_extrapolation_limit_in_content_pixels();
  inline void set_has_max_memory_for_prepaint_percentage();
  inline void clear_has_max_memory_for_prepaint_percentage();
  inline void set_has_strict_layer_property_change_checking();
  inline void clear_has_strict_layer_property_change_checking();
  inline void set_has_use_zero_copy();
  inline void clear_has_use_zero_copy();
  inline void set_has_use_partial_raster();
  inline void clear_has_use_partial_raster();
  inline void set_has_enable_elastic_overscroll();
  inline void clear_has_enable_elastic_overscroll();
  inline void set_has_ignore_root_layer_flings();
  inline void clear_has_ignore_root_layer_flings();
  inline void set_has_scheduled_raster_task_limit();
  inline void clear_has_scheduled_raster_task_limit();
  inline void set_has_use_occlusion_for_tile_prioritization();
  inline void clear_has_use_occlusion_for_tile_prioritization();
  inline void set_has_verify_property_trees();
  inline void clear_has_verify_property_trees();
  inline void set_has_use_property_trees();
  inline void clear_has_use_property_trees();
  inline void set_has_image_decode_tasks_enabled();
  inline void clear_has_image_decode_tasks_enabled();
  inline void set_has_use_compositor_animation_timelines();
  inline void clear_has_use_compositor_animation_timelines();
  inline void set_has_wait_for_beginframe_interval();
  inline void clear_has_wait_for_beginframe_interval();
  inline void set_has_max_staging_buffer_usage_in_bytes();
  inline void clear_has_max_staging_buffer_usage_in_bytes();
  inline void set_has_memory_policy();
  inline void clear_has_memory_policy();
  inline void set_has_initial_debug_state();
  inline void clear_has_initial_debug_state();

  ::cc::proto::RendererSettings* renderer_settings_;
  bool single_thread_proxy_scheduler_;
  bool use_external_begin_frame_source_;
  bool main_frame_before_activation_enabled_;
  bool using_synchronous_renderer_compositor_;
  bool accelerated_animation_enabled_;
  bool can_use_lcd_text_;
  bool use_distance_field_text_;
  bool gpu_rasterization_enabled_;
  ::google::protobuf::int32 gpu_rasterization_msaa_sample_count_;
  float gpu_rasterization_skewport_target_time_in_seconds_;
  int scrollbar_animator_;
  ::google::protobuf::int32 scrollbar_fade_delay_ms_;
  bool gpu_rasterization_forced_;
  bool create_low_res_tiling_;
  bool timeout_and_draw_when_animation_checkerboards_;
  bool layer_transforms_should_scale_layer_contents_;
  ::google::protobuf::int32 scrollbar_fade_resize_delay_ms_;
  ::google::protobuf::int32 scrollbar_fade_duration_ms_;
  ::google::protobuf::uint32 solid_color_scrollbar_color_;
  float minimum_contents_scale_;
  float low_res_contents_scale_factor_;
  float top_controls_show_threshold_;
  float top_controls_hide_threshold_;
  double background_animation_rate_;
  ::cc::proto::Size* default_tile_size_;
  ::cc::proto::Size* max_untiled_layer_size_;
  ::cc::proto::Size* minimum_occlusion_tracking_size_;
  ::google::protobuf::uint32 tiling_interest_area_padding_;
  float skewport_target_time_in_seconds_;
  bool layers_always_allowed_lcd_text_;
  bool strict_layer_property_change_checking_;
  bool use_zero_copy_;
  bool use_partial_raster_;
  ::google::protobuf::int32 skewport_extrapolation_limit_in_content_pixels_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > use_image_texture_targets_;
  ::google::protobuf::uint32 max_memory_for_prepaint_percentage_;
  bool enable_elastic_overscroll_;
  bool ignore_root_layer_flings_;
  bool use_occlusion_for_tile_prioritization_;
  bool verify_property_trees_;
  ::google::protobuf::uint32 scheduled_raster_task_limit_;
  bool use_property_trees_;
  bool image_decode_tasks_enabled_;
  bool use_compositor_animation_timelines_;
  bool wait_for_beginframe_interval_;
  ::cc::proto::ManagedMemoryPolicy* memory_policy_;
  ::cc::proto::LayerTreeDebugState* initial_debug_state_;
  ::google::protobuf::int32 max_staging_buffer_usage_in_bytes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(49 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_5ftree_5fsettings_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_5ftree_5fsettings_2eproto();
  #endif
  friend void protobuf_AssignDesc_layer_5ftree_5fsettings_2eproto();
  friend void protobuf_ShutdownFile_layer_5ftree_5fsettings_2eproto();

  void InitAsDefaultInstance();
  static LayerTreeSettings* default_instance_;
};
// ===================================================================


// ===================================================================

// LayerTreeSettings

// optional .cc.proto.RendererSettings renderer_settings = 1;
inline bool LayerTreeSettings::has_renderer_settings() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerTreeSettings::set_has_renderer_settings() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayerTreeSettings::clear_has_renderer_settings() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayerTreeSettings::clear_renderer_settings() {
  if (renderer_settings_ != NULL) renderer_settings_->::cc::proto::RendererSettings::Clear();
  clear_has_renderer_settings();
}
inline const ::cc::proto::RendererSettings& LayerTreeSettings::renderer_settings() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return renderer_settings_ != NULL ? *renderer_settings_ : *default_instance().renderer_settings_;
#else
  return renderer_settings_ != NULL ? *renderer_settings_ : *default_instance_->renderer_settings_;
#endif
}
inline ::cc::proto::RendererSettings* LayerTreeSettings::mutable_renderer_settings() {
  set_has_renderer_settings();
  if (renderer_settings_ == NULL) renderer_settings_ = new ::cc::proto::RendererSettings;
  return renderer_settings_;
}
inline ::cc::proto::RendererSettings* LayerTreeSettings::release_renderer_settings() {
  clear_has_renderer_settings();
  ::cc::proto::RendererSettings* temp = renderer_settings_;
  renderer_settings_ = NULL;
  return temp;
}
inline void LayerTreeSettings::set_allocated_renderer_settings(::cc::proto::RendererSettings* renderer_settings) {
  delete renderer_settings_;
  renderer_settings_ = renderer_settings;
  if (renderer_settings) {
    set_has_renderer_settings();
  } else {
    clear_has_renderer_settings();
  }
}

// optional bool single_thread_proxy_scheduler = 2;
inline bool LayerTreeSettings::has_single_thread_proxy_scheduler() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayerTreeSettings::set_has_single_thread_proxy_scheduler() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LayerTreeSettings::clear_has_single_thread_proxy_scheduler() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LayerTreeSettings::clear_single_thread_proxy_scheduler() {
  single_thread_proxy_scheduler_ = false;
  clear_has_single_thread_proxy_scheduler();
}
inline bool LayerTreeSettings::single_thread_proxy_scheduler() const {
  return single_thread_proxy_scheduler_;
}
inline void LayerTreeSettings::set_single_thread_proxy_scheduler(bool value) {
  set_has_single_thread_proxy_scheduler();
  single_thread_proxy_scheduler_ = value;
}

// optional bool use_external_begin_frame_source = 3;
inline bool LayerTreeSettings::has_use_external_begin_frame_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LayerTreeSettings::set_has_use_external_begin_frame_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LayerTreeSettings::clear_has_use_external_begin_frame_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LayerTreeSettings::clear_use_external_begin_frame_source() {
  use_external_begin_frame_source_ = false;
  clear_has_use_external_begin_frame_source();
}
inline bool LayerTreeSettings::use_external_begin_frame_source() const {
  return use_external_begin_frame_source_;
}
inline void LayerTreeSettings::set_use_external_begin_frame_source(bool value) {
  set_has_use_external_begin_frame_source();
  use_external_begin_frame_source_ = value;
}

// optional bool main_frame_before_activation_enabled = 4;
inline bool LayerTreeSettings::has_main_frame_before_activation_enabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LayerTreeSettings::set_has_main_frame_before_activation_enabled() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LayerTreeSettings::clear_has_main_frame_before_activation_enabled() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LayerTreeSettings::clear_main_frame_before_activation_enabled() {
  main_frame_before_activation_enabled_ = false;
  clear_has_main_frame_before_activation_enabled();
}
inline bool LayerTreeSettings::main_frame_before_activation_enabled() const {
  return main_frame_before_activation_enabled_;
}
inline void LayerTreeSettings::set_main_frame_before_activation_enabled(bool value) {
  set_has_main_frame_before_activation_enabled();
  main_frame_before_activation_enabled_ = value;
}

// optional bool using_synchronous_renderer_compositor = 5;
inline bool LayerTreeSettings::has_using_synchronous_renderer_compositor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LayerTreeSettings::set_has_using_synchronous_renderer_compositor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LayerTreeSettings::clear_has_using_synchronous_renderer_compositor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LayerTreeSettings::clear_using_synchronous_renderer_compositor() {
  using_synchronous_renderer_compositor_ = false;
  clear_has_using_synchronous_renderer_compositor();
}
inline bool LayerTreeSettings::using_synchronous_renderer_compositor() const {
  return using_synchronous_renderer_compositor_;
}
inline void LayerTreeSettings::set_using_synchronous_renderer_compositor(bool value) {
  set_has_using_synchronous_renderer_compositor();
  using_synchronous_renderer_compositor_ = value;
}

// optional bool accelerated_animation_enabled = 6;
inline bool LayerTreeSettings::has_accelerated_animation_enabled() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LayerTreeSettings::set_has_accelerated_animation_enabled() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LayerTreeSettings::clear_has_accelerated_animation_enabled() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LayerTreeSettings::clear_accelerated_animation_enabled() {
  accelerated_animation_enabled_ = false;
  clear_has_accelerated_animation_enabled();
}
inline bool LayerTreeSettings::accelerated_animation_enabled() const {
  return accelerated_animation_enabled_;
}
inline void LayerTreeSettings::set_accelerated_animation_enabled(bool value) {
  set_has_accelerated_animation_enabled();
  accelerated_animation_enabled_ = value;
}

// optional bool can_use_lcd_text = 7;
inline bool LayerTreeSettings::has_can_use_lcd_text() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LayerTreeSettings::set_has_can_use_lcd_text() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LayerTreeSettings::clear_has_can_use_lcd_text() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LayerTreeSettings::clear_can_use_lcd_text() {
  can_use_lcd_text_ = false;
  clear_has_can_use_lcd_text();
}
inline bool LayerTreeSettings::can_use_lcd_text() const {
  return can_use_lcd_text_;
}
inline void LayerTreeSettings::set_can_use_lcd_text(bool value) {
  set_has_can_use_lcd_text();
  can_use_lcd_text_ = value;
}

// optional bool use_distance_field_text = 8;
inline bool LayerTreeSettings::has_use_distance_field_text() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LayerTreeSettings::set_has_use_distance_field_text() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LayerTreeSettings::clear_has_use_distance_field_text() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LayerTreeSettings::clear_use_distance_field_text() {
  use_distance_field_text_ = false;
  clear_has_use_distance_field_text();
}
inline bool LayerTreeSettings::use_distance_field_text() const {
  return use_distance_field_text_;
}
inline void LayerTreeSettings::set_use_distance_field_text(bool value) {
  set_has_use_distance_field_text();
  use_distance_field_text_ = value;
}

// optional bool gpu_rasterization_enabled = 9;
inline bool LayerTreeSettings::has_gpu_rasterization_enabled() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LayerTreeSettings::set_has_gpu_rasterization_enabled() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LayerTreeSettings::clear_has_gpu_rasterization_enabled() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LayerTreeSettings::clear_gpu_rasterization_enabled() {
  gpu_rasterization_enabled_ = false;
  clear_has_gpu_rasterization_enabled();
}
inline bool LayerTreeSettings::gpu_rasterization_enabled() const {
  return gpu_rasterization_enabled_;
}
inline void LayerTreeSettings::set_gpu_rasterization_enabled(bool value) {
  set_has_gpu_rasterization_enabled();
  gpu_rasterization_enabled_ = value;
}

// optional bool gpu_rasterization_forced = 10;
inline bool LayerTreeSettings::has_gpu_rasterization_forced() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LayerTreeSettings::set_has_gpu_rasterization_forced() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LayerTreeSettings::clear_has_gpu_rasterization_forced() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LayerTreeSettings::clear_gpu_rasterization_forced() {
  gpu_rasterization_forced_ = false;
  clear_has_gpu_rasterization_forced();
}
inline bool LayerTreeSettings::gpu_rasterization_forced() const {
  return gpu_rasterization_forced_;
}
inline void LayerTreeSettings::set_gpu_rasterization_forced(bool value) {
  set_has_gpu_rasterization_forced();
  gpu_rasterization_forced_ = value;
}

// optional int32 gpu_rasterization_msaa_sample_count = 11;
inline bool LayerTreeSettings::has_gpu_rasterization_msaa_sample_count() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LayerTreeSettings::set_has_gpu_rasterization_msaa_sample_count() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LayerTreeSettings::clear_has_gpu_rasterization_msaa_sample_count() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LayerTreeSettings::clear_gpu_rasterization_msaa_sample_count() {
  gpu_rasterization_msaa_sample_count_ = 0;
  clear_has_gpu_rasterization_msaa_sample_count();
}
inline ::google::protobuf::int32 LayerTreeSettings::gpu_rasterization_msaa_sample_count() const {
  return gpu_rasterization_msaa_sample_count_;
}
inline void LayerTreeSettings::set_gpu_rasterization_msaa_sample_count(::google::protobuf::int32 value) {
  set_has_gpu_rasterization_msaa_sample_count();
  gpu_rasterization_msaa_sample_count_ = value;
}

// optional float gpu_rasterization_skewport_target_time_in_seconds = 12;
inline bool LayerTreeSettings::has_gpu_rasterization_skewport_target_time_in_seconds() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LayerTreeSettings::set_has_gpu_rasterization_skewport_target_time_in_seconds() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LayerTreeSettings::clear_has_gpu_rasterization_skewport_target_time_in_seconds() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LayerTreeSettings::clear_gpu_rasterization_skewport_target_time_in_seconds() {
  gpu_rasterization_skewport_target_time_in_seconds_ = 0;
  clear_has_gpu_rasterization_skewport_target_time_in_seconds();
}
inline float LayerTreeSettings::gpu_rasterization_skewport_target_time_in_seconds() const {
  return gpu_rasterization_skewport_target_time_in_seconds_;
}
inline void LayerTreeSettings::set_gpu_rasterization_skewport_target_time_in_seconds(float value) {
  set_has_gpu_rasterization_skewport_target_time_in_seconds();
  gpu_rasterization_skewport_target_time_in_seconds_ = value;
}

// optional bool create_low_res_tiling = 13;
inline bool LayerTreeSettings::has_create_low_res_tiling() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LayerTreeSettings::set_has_create_low_res_tiling() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LayerTreeSettings::clear_has_create_low_res_tiling() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LayerTreeSettings::clear_create_low_res_tiling() {
  create_low_res_tiling_ = false;
  clear_has_create_low_res_tiling();
}
inline bool LayerTreeSettings::create_low_res_tiling() const {
  return create_low_res_tiling_;
}
inline void LayerTreeSettings::set_create_low_res_tiling(bool value) {
  set_has_create_low_res_tiling();
  create_low_res_tiling_ = value;
}

// optional .cc.proto.LayerTreeSettings.ScrollbarAnimator scrollbar_animator = 14;
inline bool LayerTreeSettings::has_scrollbar_animator() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LayerTreeSettings::set_has_scrollbar_animator() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LayerTreeSettings::clear_has_scrollbar_animator() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LayerTreeSettings::clear_scrollbar_animator() {
  scrollbar_animator_ = 0;
  clear_has_scrollbar_animator();
}
inline ::cc::proto::LayerTreeSettings_ScrollbarAnimator LayerTreeSettings::scrollbar_animator() const {
  return static_cast< ::cc::proto::LayerTreeSettings_ScrollbarAnimator >(scrollbar_animator_);
}
inline void LayerTreeSettings::set_scrollbar_animator(::cc::proto::LayerTreeSettings_ScrollbarAnimator value) {
  assert(::cc::proto::LayerTreeSettings_ScrollbarAnimator_IsValid(value));
  set_has_scrollbar_animator();
  scrollbar_animator_ = value;
}

// optional int32 scrollbar_fade_delay_ms = 15;
inline bool LayerTreeSettings::has_scrollbar_fade_delay_ms() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LayerTreeSettings::set_has_scrollbar_fade_delay_ms() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LayerTreeSettings::clear_has_scrollbar_fade_delay_ms() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LayerTreeSettings::clear_scrollbar_fade_delay_ms() {
  scrollbar_fade_delay_ms_ = 0;
  clear_has_scrollbar_fade_delay_ms();
}
inline ::google::protobuf::int32 LayerTreeSettings::scrollbar_fade_delay_ms() const {
  return scrollbar_fade_delay_ms_;
}
inline void LayerTreeSettings::set_scrollbar_fade_delay_ms(::google::protobuf::int32 value) {
  set_has_scrollbar_fade_delay_ms();
  scrollbar_fade_delay_ms_ = value;
}

// optional int32 scrollbar_fade_resize_delay_ms = 16;
inline bool LayerTreeSettings::has_scrollbar_fade_resize_delay_ms() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LayerTreeSettings::set_has_scrollbar_fade_resize_delay_ms() {
  _has_bits_[0] |= 0x00008000u;
}
inline void LayerTreeSettings::clear_has_scrollbar_fade_resize_delay_ms() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void LayerTreeSettings::clear_scrollbar_fade_resize_delay_ms() {
  scrollbar_fade_resize_delay_ms_ = 0;
  clear_has_scrollbar_fade_resize_delay_ms();
}
inline ::google::protobuf::int32 LayerTreeSettings::scrollbar_fade_resize_delay_ms() const {
  return scrollbar_fade_resize_delay_ms_;
}
inline void LayerTreeSettings::set_scrollbar_fade_resize_delay_ms(::google::protobuf::int32 value) {
  set_has_scrollbar_fade_resize_delay_ms();
  scrollbar_fade_resize_delay_ms_ = value;
}

// optional int32 scrollbar_fade_duration_ms = 17;
inline bool LayerTreeSettings::has_scrollbar_fade_duration_ms() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LayerTreeSettings::set_has_scrollbar_fade_duration_ms() {
  _has_bits_[0] |= 0x00010000u;
}
inline void LayerTreeSettings::clear_has_scrollbar_fade_duration_ms() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void LayerTreeSettings::clear_scrollbar_fade_duration_ms() {
  scrollbar_fade_duration_ms_ = 0;
  clear_has_scrollbar_fade_duration_ms();
}
inline ::google::protobuf::int32 LayerTreeSettings::scrollbar_fade_duration_ms() const {
  return scrollbar_fade_duration_ms_;
}
inline void LayerTreeSettings::set_scrollbar_fade_duration_ms(::google::protobuf::int32 value) {
  set_has_scrollbar_fade_duration_ms();
  scrollbar_fade_duration_ms_ = value;
}

// optional uint32 solid_color_scrollbar_color = 18;
inline bool LayerTreeSettings::has_solid_color_scrollbar_color() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void LayerTreeSettings::set_has_solid_color_scrollbar_color() {
  _has_bits_[0] |= 0x00020000u;
}
inline void LayerTreeSettings::clear_has_solid_color_scrollbar_color() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void LayerTreeSettings::clear_solid_color_scrollbar_color() {
  solid_color_scrollbar_color_ = 0u;
  clear_has_solid_color_scrollbar_color();
}
inline ::google::protobuf::uint32 LayerTreeSettings::solid_color_scrollbar_color() const {
  return solid_color_scrollbar_color_;
}
inline void LayerTreeSettings::set_solid_color_scrollbar_color(::google::protobuf::uint32 value) {
  set_has_solid_color_scrollbar_color();
  solid_color_scrollbar_color_ = value;
}

// optional bool timeout_and_draw_when_animation_checkerboards = 19;
inline bool LayerTreeSettings::has_timeout_and_draw_when_animation_checkerboards() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void LayerTreeSettings::set_has_timeout_and_draw_when_animation_checkerboards() {
  _has_bits_[0] |= 0x00040000u;
}
inline void LayerTreeSettings::clear_has_timeout_and_draw_when_animation_checkerboards() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void LayerTreeSettings::clear_timeout_and_draw_when_animation_checkerboards() {
  timeout_and_draw_when_animation_checkerboards_ = false;
  clear_has_timeout_and_draw_when_animation_checkerboards();
}
inline bool LayerTreeSettings::timeout_and_draw_when_animation_checkerboards() const {
  return timeout_and_draw_when_animation_checkerboards_;
}
inline void LayerTreeSettings::set_timeout_and_draw_when_animation_checkerboards(bool value) {
  set_has_timeout_and_draw_when_animation_checkerboards();
  timeout_and_draw_when_animation_checkerboards_ = value;
}

// optional bool layer_transforms_should_scale_layer_contents = 20;
inline bool LayerTreeSettings::has_layer_transforms_should_scale_layer_contents() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void LayerTreeSettings::set_has_layer_transforms_should_scale_layer_contents() {
  _has_bits_[0] |= 0x00080000u;
}
inline void LayerTreeSettings::clear_has_layer_transforms_should_scale_layer_contents() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void LayerTreeSettings::clear_layer_transforms_should_scale_layer_contents() {
  layer_transforms_should_scale_layer_contents_ = false;
  clear_has_layer_transforms_should_scale_layer_contents();
}
inline bool LayerTreeSettings::layer_transforms_should_scale_layer_contents() const {
  return layer_transforms_should_scale_layer_contents_;
}
inline void LayerTreeSettings::set_layer_transforms_should_scale_layer_contents(bool value) {
  set_has_layer_transforms_should_scale_layer_contents();
  layer_transforms_should_scale_layer_contents_ = value;
}

// optional bool layers_always_allowed_lcd_text = 21;
inline bool LayerTreeSettings::has_layers_always_allowed_lcd_text() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void LayerTreeSettings::set_has_layers_always_allowed_lcd_text() {
  _has_bits_[0] |= 0x00100000u;
}
inline void LayerTreeSettings::clear_has_layers_always_allowed_lcd_text() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void LayerTreeSettings::clear_layers_always_allowed_lcd_text() {
  layers_always_allowed_lcd_text_ = false;
  clear_has_layers_always_allowed_lcd_text();
}
inline bool LayerTreeSettings::layers_always_allowed_lcd_text() const {
  return layers_always_allowed_lcd_text_;
}
inline void LayerTreeSettings::set_layers_always_allowed_lcd_text(bool value) {
  set_has_layers_always_allowed_lcd_text();
  layers_always_allowed_lcd_text_ = value;
}

// optional float minimum_contents_scale = 22;
inline bool LayerTreeSettings::has_minimum_contents_scale() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void LayerTreeSettings::set_has_minimum_contents_scale() {
  _has_bits_[0] |= 0x00200000u;
}
inline void LayerTreeSettings::clear_has_minimum_contents_scale() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void LayerTreeSettings::clear_minimum_contents_scale() {
  minimum_contents_scale_ = 0;
  clear_has_minimum_contents_scale();
}
inline float LayerTreeSettings::minimum_contents_scale() const {
  return minimum_contents_scale_;
}
inline void LayerTreeSettings::set_minimum_contents_scale(float value) {
  set_has_minimum_contents_scale();
  minimum_contents_scale_ = value;
}

// optional float low_res_contents_scale_factor = 23;
inline bool LayerTreeSettings::has_low_res_contents_scale_factor() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void LayerTreeSettings::set_has_low_res_contents_scale_factor() {
  _has_bits_[0] |= 0x00400000u;
}
inline void LayerTreeSettings::clear_has_low_res_contents_scale_factor() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void LayerTreeSettings::clear_low_res_contents_scale_factor() {
  low_res_contents_scale_factor_ = 0;
  clear_has_low_res_contents_scale_factor();
}
inline float LayerTreeSettings::low_res_contents_scale_factor() const {
  return low_res_contents_scale_factor_;
}
inline void LayerTreeSettings::set_low_res_contents_scale_factor(float value) {
  set_has_low_res_contents_scale_factor();
  low_res_contents_scale_factor_ = value;
}

// optional float top_controls_show_threshold = 24;
inline bool LayerTreeSettings::has_top_controls_show_threshold() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void LayerTreeSettings::set_has_top_controls_show_threshold() {
  _has_bits_[0] |= 0x00800000u;
}
inline void LayerTreeSettings::clear_has_top_controls_show_threshold() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void LayerTreeSettings::clear_top_controls_show_threshold() {
  top_controls_show_threshold_ = 0;
  clear_has_top_controls_show_threshold();
}
inline float LayerTreeSettings::top_controls_show_threshold() const {
  return top_controls_show_threshold_;
}
inline void LayerTreeSettings::set_top_controls_show_threshold(float value) {
  set_has_top_controls_show_threshold();
  top_controls_show_threshold_ = value;
}

// optional float top_controls_hide_threshold = 25;
inline bool LayerTreeSettings::has_top_controls_hide_threshold() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void LayerTreeSettings::set_has_top_controls_hide_threshold() {
  _has_bits_[0] |= 0x01000000u;
}
inline void LayerTreeSettings::clear_has_top_controls_hide_threshold() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void LayerTreeSettings::clear_top_controls_hide_threshold() {
  top_controls_hide_threshold_ = 0;
  clear_has_top_controls_hide_threshold();
}
inline float LayerTreeSettings::top_controls_hide_threshold() const {
  return top_controls_hide_threshold_;
}
inline void LayerTreeSettings::set_top_controls_hide_threshold(float value) {
  set_has_top_controls_hide_threshold();
  top_controls_hide_threshold_ = value;
}

// optional double background_animation_rate = 26;
inline bool LayerTreeSettings::has_background_animation_rate() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void LayerTreeSettings::set_has_background_animation_rate() {
  _has_bits_[0] |= 0x02000000u;
}
inline void LayerTreeSettings::clear_has_background_animation_rate() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void LayerTreeSettings::clear_background_animation_rate() {
  background_animation_rate_ = 0;
  clear_has_background_animation_rate();
}
inline double LayerTreeSettings::background_animation_rate() const {
  return background_animation_rate_;
}
inline void LayerTreeSettings::set_background_animation_rate(double value) {
  set_has_background_animation_rate();
  background_animation_rate_ = value;
}

// optional .cc.proto.Size default_tile_size = 27;
inline bool LayerTreeSettings::has_default_tile_size() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void LayerTreeSettings::set_has_default_tile_size() {
  _has_bits_[0] |= 0x04000000u;
}
inline void LayerTreeSettings::clear_has_default_tile_size() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void LayerTreeSettings::clear_default_tile_size() {
  if (default_tile_size_ != NULL) default_tile_size_->::cc::proto::Size::Clear();
  clear_has_default_tile_size();
}
inline const ::cc::proto::Size& LayerTreeSettings::default_tile_size() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return default_tile_size_ != NULL ? *default_tile_size_ : *default_instance().default_tile_size_;
#else
  return default_tile_size_ != NULL ? *default_tile_size_ : *default_instance_->default_tile_size_;
#endif
}
inline ::cc::proto::Size* LayerTreeSettings::mutable_default_tile_size() {
  set_has_default_tile_size();
  if (default_tile_size_ == NULL) default_tile_size_ = new ::cc::proto::Size;
  return default_tile_size_;
}
inline ::cc::proto::Size* LayerTreeSettings::release_default_tile_size() {
  clear_has_default_tile_size();
  ::cc::proto::Size* temp = default_tile_size_;
  default_tile_size_ = NULL;
  return temp;
}
inline void LayerTreeSettings::set_allocated_default_tile_size(::cc::proto::Size* default_tile_size) {
  delete default_tile_size_;
  default_tile_size_ = default_tile_size;
  if (default_tile_size) {
    set_has_default_tile_size();
  } else {
    clear_has_default_tile_size();
  }
}

// optional .cc.proto.Size max_untiled_layer_size = 28;
inline bool LayerTreeSettings::has_max_untiled_layer_size() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void LayerTreeSettings::set_has_max_untiled_layer_size() {
  _has_bits_[0] |= 0x08000000u;
}
inline void LayerTreeSettings::clear_has_max_untiled_layer_size() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void LayerTreeSettings::clear_max_untiled_layer_size() {
  if (max_untiled_layer_size_ != NULL) max_untiled_layer_size_->::cc::proto::Size::Clear();
  clear_has_max_untiled_layer_size();
}
inline const ::cc::proto::Size& LayerTreeSettings::max_untiled_layer_size() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return max_untiled_layer_size_ != NULL ? *max_untiled_layer_size_ : *default_instance().max_untiled_layer_size_;
#else
  return max_untiled_layer_size_ != NULL ? *max_untiled_layer_size_ : *default_instance_->max_untiled_layer_size_;
#endif
}
inline ::cc::proto::Size* LayerTreeSettings::mutable_max_untiled_layer_size() {
  set_has_max_untiled_layer_size();
  if (max_untiled_layer_size_ == NULL) max_untiled_layer_size_ = new ::cc::proto::Size;
  return max_untiled_layer_size_;
}
inline ::cc::proto::Size* LayerTreeSettings::release_max_untiled_layer_size() {
  clear_has_max_untiled_layer_size();
  ::cc::proto::Size* temp = max_untiled_layer_size_;
  max_untiled_layer_size_ = NULL;
  return temp;
}
inline void LayerTreeSettings::set_allocated_max_untiled_layer_size(::cc::proto::Size* max_untiled_layer_size) {
  delete max_untiled_layer_size_;
  max_untiled_layer_size_ = max_untiled_layer_size;
  if (max_untiled_layer_size) {
    set_has_max_untiled_layer_size();
  } else {
    clear_has_max_untiled_layer_size();
  }
}

// optional .cc.proto.Size minimum_occlusion_tracking_size = 29;
inline bool LayerTreeSettings::has_minimum_occlusion_tracking_size() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void LayerTreeSettings::set_has_minimum_occlusion_tracking_size() {
  _has_bits_[0] |= 0x10000000u;
}
inline void LayerTreeSettings::clear_has_minimum_occlusion_tracking_size() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void LayerTreeSettings::clear_minimum_occlusion_tracking_size() {
  if (minimum_occlusion_tracking_size_ != NULL) minimum_occlusion_tracking_size_->::cc::proto::Size::Clear();
  clear_has_minimum_occlusion_tracking_size();
}
inline const ::cc::proto::Size& LayerTreeSettings::minimum_occlusion_tracking_size() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return minimum_occlusion_tracking_size_ != NULL ? *minimum_occlusion_tracking_size_ : *default_instance().minimum_occlusion_tracking_size_;
#else
  return minimum_occlusion_tracking_size_ != NULL ? *minimum_occlusion_tracking_size_ : *default_instance_->minimum_occlusion_tracking_size_;
#endif
}
inline ::cc::proto::Size* LayerTreeSettings::mutable_minimum_occlusion_tracking_size() {
  set_has_minimum_occlusion_tracking_size();
  if (minimum_occlusion_tracking_size_ == NULL) minimum_occlusion_tracking_size_ = new ::cc::proto::Size;
  return minimum_occlusion_tracking_size_;
}
inline ::cc::proto::Size* LayerTreeSettings::release_minimum_occlusion_tracking_size() {
  clear_has_minimum_occlusion_tracking_size();
  ::cc::proto::Size* temp = minimum_occlusion_tracking_size_;
  minimum_occlusion_tracking_size_ = NULL;
  return temp;
}
inline void LayerTreeSettings::set_allocated_minimum_occlusion_tracking_size(::cc::proto::Size* minimum_occlusion_tracking_size) {
  delete minimum_occlusion_tracking_size_;
  minimum_occlusion_tracking_size_ = minimum_occlusion_tracking_size;
  if (minimum_occlusion_tracking_size) {
    set_has_minimum_occlusion_tracking_size();
  } else {
    clear_has_minimum_occlusion_tracking_size();
  }
}

// optional uint32 tiling_interest_area_padding = 30;
inline bool LayerTreeSettings::has_tiling_interest_area_padding() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void LayerTreeSettings::set_has_tiling_interest_area_padding() {
  _has_bits_[0] |= 0x20000000u;
}
inline void LayerTreeSettings::clear_has_tiling_interest_area_padding() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void LayerTreeSettings::clear_tiling_interest_area_padding() {
  tiling_interest_area_padding_ = 0u;
  clear_has_tiling_interest_area_padding();
}
inline ::google::protobuf::uint32 LayerTreeSettings::tiling_interest_area_padding() const {
  return tiling_interest_area_padding_;
}
inline void LayerTreeSettings::set_tiling_interest_area_padding(::google::protobuf::uint32 value) {
  set_has_tiling_interest_area_padding();
  tiling_interest_area_padding_ = value;
}

// optional float skewport_target_time_in_seconds = 31;
inline bool LayerTreeSettings::has_skewport_target_time_in_seconds() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void LayerTreeSettings::set_has_skewport_target_time_in_seconds() {
  _has_bits_[0] |= 0x40000000u;
}
inline void LayerTreeSettings::clear_has_skewport_target_time_in_seconds() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void LayerTreeSettings::clear_skewport_target_time_in_seconds() {
  skewport_target_time_in_seconds_ = 0;
  clear_has_skewport_target_time_in_seconds();
}
inline float LayerTreeSettings::skewport_target_time_in_seconds() const {
  return skewport_target_time_in_seconds_;
}
inline void LayerTreeSettings::set_skewport_target_time_in_seconds(float value) {
  set_has_skewport_target_time_in_seconds();
  skewport_target_time_in_seconds_ = value;
}

// optional int32 skewport_extrapolation_limit_in_content_pixels = 32;
inline bool LayerTreeSettings::has_skewport_extrapolation_limit_in_content_pixels() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void LayerTreeSettings::set_has_skewport_extrapolation_limit_in_content_pixels() {
  _has_bits_[0] |= 0x80000000u;
}
inline void LayerTreeSettings::clear_has_skewport_extrapolation_limit_in_content_pixels() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void LayerTreeSettings::clear_skewport_extrapolation_limit_in_content_pixels() {
  skewport_extrapolation_limit_in_content_pixels_ = 0;
  clear_has_skewport_extrapolation_limit_in_content_pixels();
}
inline ::google::protobuf::int32 LayerTreeSettings::skewport_extrapolation_limit_in_content_pixels() const {
  return skewport_extrapolation_limit_in_content_pixels_;
}
inline void LayerTreeSettings::set_skewport_extrapolation_limit_in_content_pixels(::google::protobuf::int32 value) {
  set_has_skewport_extrapolation_limit_in_content_pixels();
  skewport_extrapolation_limit_in_content_pixels_ = value;
}

// optional uint32 max_memory_for_prepaint_percentage = 33;
inline bool LayerTreeSettings::has_max_memory_for_prepaint_percentage() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void LayerTreeSettings::set_has_max_memory_for_prepaint_percentage() {
  _has_bits_[1] |= 0x00000001u;
}
inline void LayerTreeSettings::clear_has_max_memory_for_prepaint_percentage() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void LayerTreeSettings::clear_max_memory_for_prepaint_percentage() {
  max_memory_for_prepaint_percentage_ = 0u;
  clear_has_max_memory_for_prepaint_percentage();
}
inline ::google::protobuf::uint32 LayerTreeSettings::max_memory_for_prepaint_percentage() const {
  return max_memory_for_prepaint_percentage_;
}
inline void LayerTreeSettings::set_max_memory_for_prepaint_percentage(::google::protobuf::uint32 value) {
  set_has_max_memory_for_prepaint_percentage();
  max_memory_for_prepaint_percentage_ = value;
}

// optional bool strict_layer_property_change_checking = 34;
inline bool LayerTreeSettings::has_strict_layer_property_change_checking() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void LayerTreeSettings::set_has_strict_layer_property_change_checking() {
  _has_bits_[1] |= 0x00000002u;
}
inline void LayerTreeSettings::clear_has_strict_layer_property_change_checking() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void LayerTreeSettings::clear_strict_layer_property_change_checking() {
  strict_layer_property_change_checking_ = false;
  clear_has_strict_layer_property_change_checking();
}
inline bool LayerTreeSettings::strict_layer_property_change_checking() const {
  return strict_layer_property_change_checking_;
}
inline void LayerTreeSettings::set_strict_layer_property_change_checking(bool value) {
  set_has_strict_layer_property_change_checking();
  strict_layer_property_change_checking_ = value;
}

// optional bool use_zero_copy = 35;
inline bool LayerTreeSettings::has_use_zero_copy() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void LayerTreeSettings::set_has_use_zero_copy() {
  _has_bits_[1] |= 0x00000004u;
}
inline void LayerTreeSettings::clear_has_use_zero_copy() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void LayerTreeSettings::clear_use_zero_copy() {
  use_zero_copy_ = false;
  clear_has_use_zero_copy();
}
inline bool LayerTreeSettings::use_zero_copy() const {
  return use_zero_copy_;
}
inline void LayerTreeSettings::set_use_zero_copy(bool value) {
  set_has_use_zero_copy();
  use_zero_copy_ = value;
}

// optional bool use_partial_raster = 36;
inline bool LayerTreeSettings::has_use_partial_raster() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void LayerTreeSettings::set_has_use_partial_raster() {
  _has_bits_[1] |= 0x00000008u;
}
inline void LayerTreeSettings::clear_has_use_partial_raster() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void LayerTreeSettings::clear_use_partial_raster() {
  use_partial_raster_ = false;
  clear_has_use_partial_raster();
}
inline bool LayerTreeSettings::use_partial_raster() const {
  return use_partial_raster_;
}
inline void LayerTreeSettings::set_use_partial_raster(bool value) {
  set_has_use_partial_raster();
  use_partial_raster_ = value;
}

// optional bool enable_elastic_overscroll = 37;
inline bool LayerTreeSettings::has_enable_elastic_overscroll() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void LayerTreeSettings::set_has_enable_elastic_overscroll() {
  _has_bits_[1] |= 0x00000010u;
}
inline void LayerTreeSettings::clear_has_enable_elastic_overscroll() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void LayerTreeSettings::clear_enable_elastic_overscroll() {
  enable_elastic_overscroll_ = false;
  clear_has_enable_elastic_overscroll();
}
inline bool LayerTreeSettings::enable_elastic_overscroll() const {
  return enable_elastic_overscroll_;
}
inline void LayerTreeSettings::set_enable_elastic_overscroll(bool value) {
  set_has_enable_elastic_overscroll();
  enable_elastic_overscroll_ = value;
}

// repeated uint32 use_image_texture_targets = 38;
inline int LayerTreeSettings::use_image_texture_targets_size() const {
  return use_image_texture_targets_.size();
}
inline void LayerTreeSettings::clear_use_image_texture_targets() {
  use_image_texture_targets_.Clear();
}
inline ::google::protobuf::uint32 LayerTreeSettings::use_image_texture_targets(int index) const {
  return use_image_texture_targets_.Get(index);
}
inline void LayerTreeSettings::set_use_image_texture_targets(int index, ::google::protobuf::uint32 value) {
  use_image_texture_targets_.Set(index, value);
}
inline void LayerTreeSettings::add_use_image_texture_targets(::google::protobuf::uint32 value) {
  use_image_texture_targets_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
LayerTreeSettings::use_image_texture_targets() const {
  return use_image_texture_targets_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
LayerTreeSettings::mutable_use_image_texture_targets() {
  return &use_image_texture_targets_;
}

// optional bool ignore_root_layer_flings = 39;
inline bool LayerTreeSettings::has_ignore_root_layer_flings() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void LayerTreeSettings::set_has_ignore_root_layer_flings() {
  _has_bits_[1] |= 0x00000040u;
}
inline void LayerTreeSettings::clear_has_ignore_root_layer_flings() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void LayerTreeSettings::clear_ignore_root_layer_flings() {
  ignore_root_layer_flings_ = false;
  clear_has_ignore_root_layer_flings();
}
inline bool LayerTreeSettings::ignore_root_layer_flings() const {
  return ignore_root_layer_flings_;
}
inline void LayerTreeSettings::set_ignore_root_layer_flings(bool value) {
  set_has_ignore_root_layer_flings();
  ignore_root_layer_flings_ = value;
}

// optional uint32 scheduled_raster_task_limit = 40;
inline bool LayerTreeSettings::has_scheduled_raster_task_limit() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void LayerTreeSettings::set_has_scheduled_raster_task_limit() {
  _has_bits_[1] |= 0x00000080u;
}
inline void LayerTreeSettings::clear_has_scheduled_raster_task_limit() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void LayerTreeSettings::clear_scheduled_raster_task_limit() {
  scheduled_raster_task_limit_ = 0u;
  clear_has_scheduled_raster_task_limit();
}
inline ::google::protobuf::uint32 LayerTreeSettings::scheduled_raster_task_limit() const {
  return scheduled_raster_task_limit_;
}
inline void LayerTreeSettings::set_scheduled_raster_task_limit(::google::protobuf::uint32 value) {
  set_has_scheduled_raster_task_limit();
  scheduled_raster_task_limit_ = value;
}

// optional bool use_occlusion_for_tile_prioritization = 41;
inline bool LayerTreeSettings::has_use_occlusion_for_tile_prioritization() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void LayerTreeSettings::set_has_use_occlusion_for_tile_prioritization() {
  _has_bits_[1] |= 0x00000100u;
}
inline void LayerTreeSettings::clear_has_use_occlusion_for_tile_prioritization() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void LayerTreeSettings::clear_use_occlusion_for_tile_prioritization() {
  use_occlusion_for_tile_prioritization_ = false;
  clear_has_use_occlusion_for_tile_prioritization();
}
inline bool LayerTreeSettings::use_occlusion_for_tile_prioritization() const {
  return use_occlusion_for_tile_prioritization_;
}
inline void LayerTreeSettings::set_use_occlusion_for_tile_prioritization(bool value) {
  set_has_use_occlusion_for_tile_prioritization();
  use_occlusion_for_tile_prioritization_ = value;
}

// optional bool verify_property_trees = 42;
inline bool LayerTreeSettings::has_verify_property_trees() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void LayerTreeSettings::set_has_verify_property_trees() {
  _has_bits_[1] |= 0x00000200u;
}
inline void LayerTreeSettings::clear_has_verify_property_trees() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void LayerTreeSettings::clear_verify_property_trees() {
  verify_property_trees_ = false;
  clear_has_verify_property_trees();
}
inline bool LayerTreeSettings::verify_property_trees() const {
  return verify_property_trees_;
}
inline void LayerTreeSettings::set_verify_property_trees(bool value) {
  set_has_verify_property_trees();
  verify_property_trees_ = value;
}

// optional bool use_property_trees = 43;
inline bool LayerTreeSettings::has_use_property_trees() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void LayerTreeSettings::set_has_use_property_trees() {
  _has_bits_[1] |= 0x00000400u;
}
inline void LayerTreeSettings::clear_has_use_property_trees() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void LayerTreeSettings::clear_use_property_trees() {
  use_property_trees_ = false;
  clear_has_use_property_trees();
}
inline bool LayerTreeSettings::use_property_trees() const {
  return use_property_trees_;
}
inline void LayerTreeSettings::set_use_property_trees(bool value) {
  set_has_use_property_trees();
  use_property_trees_ = value;
}

// optional bool image_decode_tasks_enabled = 44;
inline bool LayerTreeSettings::has_image_decode_tasks_enabled() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void LayerTreeSettings::set_has_image_decode_tasks_enabled() {
  _has_bits_[1] |= 0x00000800u;
}
inline void LayerTreeSettings::clear_has_image_decode_tasks_enabled() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void LayerTreeSettings::clear_image_decode_tasks_enabled() {
  image_decode_tasks_enabled_ = false;
  clear_has_image_decode_tasks_enabled();
}
inline bool LayerTreeSettings::image_decode_tasks_enabled() const {
  return image_decode_tasks_enabled_;
}
inline void LayerTreeSettings::set_image_decode_tasks_enabled(bool value) {
  set_has_image_decode_tasks_enabled();
  image_decode_tasks_enabled_ = value;
}

// optional bool use_compositor_animation_timelines = 45;
inline bool LayerTreeSettings::has_use_compositor_animation_timelines() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void LayerTreeSettings::set_has_use_compositor_animation_timelines() {
  _has_bits_[1] |= 0x00001000u;
}
inline void LayerTreeSettings::clear_has_use_compositor_animation_timelines() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void LayerTreeSettings::clear_use_compositor_animation_timelines() {
  use_compositor_animation_timelines_ = false;
  clear_has_use_compositor_animation_timelines();
}
inline bool LayerTreeSettings::use_compositor_animation_timelines() const {
  return use_compositor_animation_timelines_;
}
inline void LayerTreeSettings::set_use_compositor_animation_timelines(bool value) {
  set_has_use_compositor_animation_timelines();
  use_compositor_animation_timelines_ = value;
}

// optional bool wait_for_beginframe_interval = 46;
inline bool LayerTreeSettings::has_wait_for_beginframe_interval() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void LayerTreeSettings::set_has_wait_for_beginframe_interval() {
  _has_bits_[1] |= 0x00002000u;
}
inline void LayerTreeSettings::clear_has_wait_for_beginframe_interval() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void LayerTreeSettings::clear_wait_for_beginframe_interval() {
  wait_for_beginframe_interval_ = false;
  clear_has_wait_for_beginframe_interval();
}
inline bool LayerTreeSettings::wait_for_beginframe_interval() const {
  return wait_for_beginframe_interval_;
}
inline void LayerTreeSettings::set_wait_for_beginframe_interval(bool value) {
  set_has_wait_for_beginframe_interval();
  wait_for_beginframe_interval_ = value;
}

// optional int32 max_staging_buffer_usage_in_bytes = 47;
inline bool LayerTreeSettings::has_max_staging_buffer_usage_in_bytes() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void LayerTreeSettings::set_has_max_staging_buffer_usage_in_bytes() {
  _has_bits_[1] |= 0x00004000u;
}
inline void LayerTreeSettings::clear_has_max_staging_buffer_usage_in_bytes() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void LayerTreeSettings::clear_max_staging_buffer_usage_in_bytes() {
  max_staging_buffer_usage_in_bytes_ = 0;
  clear_has_max_staging_buffer_usage_in_bytes();
}
inline ::google::protobuf::int32 LayerTreeSettings::max_staging_buffer_usage_in_bytes() const {
  return max_staging_buffer_usage_in_bytes_;
}
inline void LayerTreeSettings::set_max_staging_buffer_usage_in_bytes(::google::protobuf::int32 value) {
  set_has_max_staging_buffer_usage_in_bytes();
  max_staging_buffer_usage_in_bytes_ = value;
}

// optional .cc.proto.ManagedMemoryPolicy memory_policy = 48;
inline bool LayerTreeSettings::has_memory_policy() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void LayerTreeSettings::set_has_memory_policy() {
  _has_bits_[1] |= 0x00008000u;
}
inline void LayerTreeSettings::clear_has_memory_policy() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void LayerTreeSettings::clear_memory_policy() {
  if (memory_policy_ != NULL) memory_policy_->::cc::proto::ManagedMemoryPolicy::Clear();
  clear_has_memory_policy();
}
inline const ::cc::proto::ManagedMemoryPolicy& LayerTreeSettings::memory_policy() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return memory_policy_ != NULL ? *memory_policy_ : *default_instance().memory_policy_;
#else
  return memory_policy_ != NULL ? *memory_policy_ : *default_instance_->memory_policy_;
#endif
}
inline ::cc::proto::ManagedMemoryPolicy* LayerTreeSettings::mutable_memory_policy() {
  set_has_memory_policy();
  if (memory_policy_ == NULL) memory_policy_ = new ::cc::proto::ManagedMemoryPolicy;
  return memory_policy_;
}
inline ::cc::proto::ManagedMemoryPolicy* LayerTreeSettings::release_memory_policy() {
  clear_has_memory_policy();
  ::cc::proto::ManagedMemoryPolicy* temp = memory_policy_;
  memory_policy_ = NULL;
  return temp;
}
inline void LayerTreeSettings::set_allocated_memory_policy(::cc::proto::ManagedMemoryPolicy* memory_policy) {
  delete memory_policy_;
  memory_policy_ = memory_policy;
  if (memory_policy) {
    set_has_memory_policy();
  } else {
    clear_has_memory_policy();
  }
}

// optional .cc.proto.LayerTreeDebugState initial_debug_state = 49;
inline bool LayerTreeSettings::has_initial_debug_state() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void LayerTreeSettings::set_has_initial_debug_state() {
  _has_bits_[1] |= 0x00010000u;
}
inline void LayerTreeSettings::clear_has_initial_debug_state() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void LayerTreeSettings::clear_initial_debug_state() {
  if (initial_debug_state_ != NULL) initial_debug_state_->::cc::proto::LayerTreeDebugState::Clear();
  clear_has_initial_debug_state();
}
inline const ::cc::proto::LayerTreeDebugState& LayerTreeSettings::initial_debug_state() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return initial_debug_state_ != NULL ? *initial_debug_state_ : *default_instance().initial_debug_state_;
#else
  return initial_debug_state_ != NULL ? *initial_debug_state_ : *default_instance_->initial_debug_state_;
#endif
}
inline ::cc::proto::LayerTreeDebugState* LayerTreeSettings::mutable_initial_debug_state() {
  set_has_initial_debug_state();
  if (initial_debug_state_ == NULL) initial_debug_state_ = new ::cc::proto::LayerTreeDebugState;
  return initial_debug_state_;
}
inline ::cc::proto::LayerTreeDebugState* LayerTreeSettings::release_initial_debug_state() {
  clear_has_initial_debug_state();
  ::cc::proto::LayerTreeDebugState* temp = initial_debug_state_;
  initial_debug_state_ = NULL;
  return temp;
}
inline void LayerTreeSettings::set_allocated_initial_debug_state(::cc::proto::LayerTreeDebugState* initial_debug_state) {
  delete initial_debug_state_;
  initial_debug_state_ = initial_debug_state;
  if (initial_debug_state) {
    set_has_initial_debug_state();
  } else {
    clear_has_initial_debug_state();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_layer_5ftree_5fsettings_2eproto__INCLUDED
