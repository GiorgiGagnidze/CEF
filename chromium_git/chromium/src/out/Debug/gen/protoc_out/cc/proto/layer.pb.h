// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: layer.proto

#ifndef PROTOBUF_layer_2eproto__INCLUDED
#define PROTOBUF_layer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "display_list_recording_source.pb.h"
#include "layer_position_constraint.pb.h"
#include "point3f.pb.h"
#include "pointf.pb.h"
#include "region.pb.h"
#include "rect.pb.h"
#include "scroll_offset.pb.h"
#include "size.pb.h"
#include "skxfermode.pb.h"
#include "transform.pb.h"
#include "vector2df.pb.h"
// @@protoc_insertion_point(includes)
#include "cc/proto/cc_proto_export.h"

namespace cc {
namespace proto {

// Internal implementation detail -- do not call these.
void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto();
void protobuf_AssignDesc_layer_2eproto();
void protobuf_ShutdownFile_layer_2eproto();

class LayerNode;
class LayerUpdate;
class LayerProperties;
class BaseLayerProperties;
class PictureLayerProperties;

enum LayerType {
  UNKNOWN = 0,
  LAYER = 1,
  PICTURE_LAYER = 2,
  HEADS_UP_DISPLAY_LAYER = 3
};
CC_PROTO_EXPORT bool LayerType_IsValid(int value);
const LayerType LayerType_MIN = UNKNOWN;
const LayerType LayerType_MAX = HEADS_UP_DISPLAY_LAYER;
const int LayerType_ARRAYSIZE = LayerType_MAX + 1;

// ===================================================================

class CC_PROTO_EXPORT LayerNode : public ::google::protobuf::MessageLite {
 public:
  LayerNode();
  virtual ~LayerNode();

  LayerNode(const LayerNode& from);

  inline LayerNode& operator=(const LayerNode& from) {
    CopyFrom(from);
    return *this;
  }

  static const LayerNode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LayerNode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LayerNode* other);

  // implements Message ----------------------------------------------

  LayerNode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LayerNode& from);
  void MergeFrom(const LayerNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .cc.proto.LayerType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::cc::proto::LayerType type() const;
  inline void set_type(::cc::proto::LayerType value);

  // optional int32 parent_id = 3;
  inline bool has_parent_id() const;
  inline void clear_parent_id();
  static const int kParentIdFieldNumber = 3;
  inline ::google::protobuf::int32 parent_id() const;
  inline void set_parent_id(::google::protobuf::int32 value);

  // repeated .cc.proto.LayerNode children = 4;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 4;
  inline const ::cc::proto::LayerNode& children(int index) const;
  inline ::cc::proto::LayerNode* mutable_children(int index);
  inline ::cc::proto::LayerNode* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::cc::proto::LayerNode >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::cc::proto::LayerNode >*
      mutable_children();

  // optional .cc.proto.LayerNode mask_layer = 5;
  inline bool has_mask_layer() const;
  inline void clear_mask_layer();
  static const int kMaskLayerFieldNumber = 5;
  inline const ::cc::proto::LayerNode& mask_layer() const;
  inline ::cc::proto::LayerNode* mutable_mask_layer();
  inline ::cc::proto::LayerNode* release_mask_layer();
  inline void set_allocated_mask_layer(::cc::proto::LayerNode* mask_layer);

  // optional .cc.proto.LayerNode replica_layer = 6;
  inline bool has_replica_layer() const;
  inline void clear_replica_layer();
  static const int kReplicaLayerFieldNumber = 6;
  inline const ::cc::proto::LayerNode& replica_layer() const;
  inline ::cc::proto::LayerNode* mutable_replica_layer();
  inline ::cc::proto::LayerNode* release_replica_layer();
  inline void set_allocated_replica_layer(::cc::proto::LayerNode* replica_layer);

  // @@protoc_insertion_point(class_scope:cc.proto.LayerNode)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_parent_id();
  inline void clear_has_parent_id();
  inline void set_has_mask_layer();
  inline void clear_has_mask_layer();
  inline void set_has_replica_layer();
  inline void clear_has_replica_layer();

  ::google::protobuf::int32 id_;
  int type_;
  ::google::protobuf::RepeatedPtrField< ::cc::proto::LayerNode > children_;
  ::cc::proto::LayerNode* mask_layer_;
  ::cc::proto::LayerNode* replica_layer_;
  ::google::protobuf::int32 parent_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto();
  #endif
  friend void protobuf_AssignDesc_layer_2eproto();
  friend void protobuf_ShutdownFile_layer_2eproto();

  void InitAsDefaultInstance();
  static LayerNode* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT LayerUpdate : public ::google::protobuf::MessageLite {
 public:
  LayerUpdate();
  virtual ~LayerUpdate();

  LayerUpdate(const LayerUpdate& from);

  inline LayerUpdate& operator=(const LayerUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const LayerUpdate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LayerUpdate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LayerUpdate* other);

  // implements Message ----------------------------------------------

  LayerUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LayerUpdate& from);
  void MergeFrom(const LayerUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cc.proto.LayerProperties layers = 1;
  inline int layers_size() const;
  inline void clear_layers();
  static const int kLayersFieldNumber = 1;
  inline const ::cc::proto::LayerProperties& layers(int index) const;
  inline ::cc::proto::LayerProperties* mutable_layers(int index);
  inline ::cc::proto::LayerProperties* add_layers();
  inline const ::google::protobuf::RepeatedPtrField< ::cc::proto::LayerProperties >&
      layers() const;
  inline ::google::protobuf::RepeatedPtrField< ::cc::proto::LayerProperties >*
      mutable_layers();

  // @@protoc_insertion_point(class_scope:cc.proto.LayerUpdate)
 private:

  ::google::protobuf::RepeatedPtrField< ::cc::proto::LayerProperties > layers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto();
  #endif
  friend void protobuf_AssignDesc_layer_2eproto();
  friend void protobuf_ShutdownFile_layer_2eproto();

  void InitAsDefaultInstance();
  static LayerUpdate* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT LayerProperties : public ::google::protobuf::MessageLite {
 public:
  LayerProperties();
  virtual ~LayerProperties();

  LayerProperties(const LayerProperties& from);

  inline LayerProperties& operator=(const LayerProperties& from) {
    CopyFrom(from);
    return *this;
  }

  static const LayerProperties& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LayerProperties* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LayerProperties* other);

  // implements Message ----------------------------------------------

  LayerProperties* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LayerProperties& from);
  void MergeFrom(const LayerProperties& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional bool needs_push_properties = 3;
  inline bool has_needs_push_properties() const;
  inline void clear_needs_push_properties();
  static const int kNeedsPushPropertiesFieldNumber = 3;
  inline bool needs_push_properties() const;
  inline void set_needs_push_properties(bool value);

  // optional int32 num_dependents_need_push_properties = 4;
  inline bool has_num_dependents_need_push_properties() const;
  inline void clear_num_dependents_need_push_properties();
  static const int kNumDependentsNeedPushPropertiesFieldNumber = 4;
  inline ::google::protobuf::int32 num_dependents_need_push_properties() const;
  inline void set_num_dependents_need_push_properties(::google::protobuf::int32 value);

  // optional .cc.proto.BaseLayerProperties base = 5;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 5;
  inline const ::cc::proto::BaseLayerProperties& base() const;
  inline ::cc::proto::BaseLayerProperties* mutable_base();
  inline ::cc::proto::BaseLayerProperties* release_base();
  inline void set_allocated_base(::cc::proto::BaseLayerProperties* base);

  // optional .cc.proto.PictureLayerProperties picture = 6;
  inline bool has_picture() const;
  inline void clear_picture();
  static const int kPictureFieldNumber = 6;
  inline const ::cc::proto::PictureLayerProperties& picture() const;
  inline ::cc::proto::PictureLayerProperties* mutable_picture();
  inline ::cc::proto::PictureLayerProperties* release_picture();
  inline void set_allocated_picture(::cc::proto::PictureLayerProperties* picture);

  // @@protoc_insertion_point(class_scope:cc.proto.LayerProperties)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_needs_push_properties();
  inline void clear_has_needs_push_properties();
  inline void set_has_num_dependents_need_push_properties();
  inline void clear_has_num_dependents_need_push_properties();
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_picture();
  inline void clear_has_picture();

  ::google::protobuf::int32 id_;
  bool needs_push_properties_;
  ::cc::proto::BaseLayerProperties* base_;
  ::cc::proto::PictureLayerProperties* picture_;
  ::google::protobuf::int32 num_dependents_need_push_properties_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto();
  #endif
  friend void protobuf_AssignDesc_layer_2eproto();
  friend void protobuf_ShutdownFile_layer_2eproto();

  void InitAsDefaultInstance();
  static LayerProperties* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT BaseLayerProperties : public ::google::protobuf::MessageLite {
 public:
  BaseLayerProperties();
  virtual ~BaseLayerProperties();

  BaseLayerProperties(const BaseLayerProperties& from);

  inline BaseLayerProperties& operator=(const BaseLayerProperties& from) {
    CopyFrom(from);
    return *this;
  }

  static const BaseLayerProperties& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BaseLayerProperties* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BaseLayerProperties* other);

  // implements Message ----------------------------------------------

  BaseLayerProperties* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BaseLayerProperties& from);
  void MergeFrom(const BaseLayerProperties& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cc.proto.Point3F transform_origin = 1;
  inline bool has_transform_origin() const;
  inline void clear_transform_origin();
  static const int kTransformOriginFieldNumber = 1;
  inline const ::cc::proto::Point3F& transform_origin() const;
  inline ::cc::proto::Point3F* mutable_transform_origin();
  inline ::cc::proto::Point3F* release_transform_origin();
  inline void set_allocated_transform_origin(::cc::proto::Point3F* transform_origin);

  // optional uint32 background_color = 2;
  inline bool has_background_color() const;
  inline void clear_background_color();
  static const int kBackgroundColorFieldNumber = 2;
  inline ::google::protobuf::uint32 background_color() const;
  inline void set_background_color(::google::protobuf::uint32 value);

  // optional .cc.proto.Size bounds = 3;
  inline bool has_bounds() const;
  inline void clear_bounds();
  static const int kBoundsFieldNumber = 3;
  inline const ::cc::proto::Size& bounds() const;
  inline ::cc::proto::Size* mutable_bounds();
  inline ::cc::proto::Size* release_bounds();
  inline void set_allocated_bounds(::cc::proto::Size* bounds);

  // optional int64 transform_free_index = 4;
  inline bool has_transform_free_index() const;
  inline void clear_transform_free_index();
  static const int kTransformFreeIndexFieldNumber = 4;
  inline ::google::protobuf::int64 transform_free_index() const;
  inline void set_transform_free_index(::google::protobuf::int64 value);

  // optional int64 effect_tree_index = 5;
  inline bool has_effect_tree_index() const;
  inline void clear_effect_tree_index();
  static const int kEffectTreeIndexFieldNumber = 5;
  inline ::google::protobuf::int64 effect_tree_index() const;
  inline void set_effect_tree_index(::google::protobuf::int64 value);

  // optional int64 clip_tree_index = 6;
  inline bool has_clip_tree_index() const;
  inline void clear_clip_tree_index();
  static const int kClipTreeIndexFieldNumber = 6;
  inline ::google::protobuf::int64 clip_tree_index() const;
  inline void set_clip_tree_index(::google::protobuf::int64 value);

  // optional int64 scroll_tree_index = 50;
  inline bool has_scroll_tree_index() const;
  inline void clear_scroll_tree_index();
  static const int kScrollTreeIndexFieldNumber = 50;
  inline ::google::protobuf::int64 scroll_tree_index() const;
  inline void set_scroll_tree_index(::google::protobuf::int64 value);

  // optional .cc.proto.Vector2dF offset_to_transform_parent = 7;
  inline bool has_offset_to_transform_parent() const;
  inline void clear_offset_to_transform_parent();
  static const int kOffsetToTransformParentFieldNumber = 7;
  inline const ::cc::proto::Vector2dF& offset_to_transform_parent() const;
  inline ::cc::proto::Vector2dF* mutable_offset_to_transform_parent();
  inline ::cc::proto::Vector2dF* release_offset_to_transform_parent();
  inline void set_allocated_offset_to_transform_parent(::cc::proto::Vector2dF* offset_to_transform_parent);

  // optional bool double_sided = 8;
  inline bool has_double_sided() const;
  inline void clear_double_sided();
  static const int kDoubleSidedFieldNumber = 8;
  inline bool double_sided() const;
  inline void set_double_sided(bool value);

  // optional bool draws_content = 9;
  inline bool has_draws_content() const;
  inline void clear_draws_content();
  static const int kDrawsContentFieldNumber = 9;
  inline bool draws_content() const;
  inline void set_draws_content(bool value);

  // optional bool hide_layer_and_subtree = 10;
  inline bool has_hide_layer_and_subtree() const;
  inline void clear_hide_layer_and_subtree();
  static const int kHideLayerAndSubtreeFieldNumber = 10;
  inline bool hide_layer_and_subtree() const;
  inline void set_hide_layer_and_subtree(bool value);

  // optional bool has_render_surface = 11;
  inline bool has_has_render_surface() const;
  inline void clear_has_render_surface();
  static const int kHasRenderSurfaceFieldNumber = 11;
  inline bool has_render_surface() const;
  inline void set_has_render_surface(bool value);

  // optional bool masks_to_bounds = 14;
  inline bool has_masks_to_bounds() const;
  inline void clear_masks_to_bounds();
  static const int kMasksToBoundsFieldNumber = 14;
  inline bool masks_to_bounds() const;
  inline void set_masks_to_bounds(bool value);

  // optional uint32 main_thread_scrolling_reasons = 15;
  inline bool has_main_thread_scrolling_reasons() const;
  inline void clear_main_thread_scrolling_reasons();
  static const int kMainThreadScrollingReasonsFieldNumber = 15;
  inline ::google::protobuf::uint32 main_thread_scrolling_reasons() const;
  inline void set_main_thread_scrolling_reasons(::google::protobuf::uint32 value);

  // optional bool have_scroll_event_handlers = 17;
  inline bool has_have_scroll_event_handlers() const;
  inline void clear_have_scroll_event_handlers();
  static const int kHaveScrollEventHandlersFieldNumber = 17;
  inline bool have_scroll_event_handlers() const;
  inline void set_have_scroll_event_handlers(bool value);

  // optional .cc.proto.Region non_fast_scrollable_region = 18;
  inline bool has_non_fast_scrollable_region() const;
  inline void clear_non_fast_scrollable_region();
  static const int kNonFastScrollableRegionFieldNumber = 18;
  inline const ::cc::proto::Region& non_fast_scrollable_region() const;
  inline ::cc::proto::Region* mutable_non_fast_scrollable_region();
  inline ::cc::proto::Region* release_non_fast_scrollable_region();
  inline void set_allocated_non_fast_scrollable_region(::cc::proto::Region* non_fast_scrollable_region);

  // optional .cc.proto.Region touch_event_handler_region = 19;
  inline bool has_touch_event_handler_region() const;
  inline void clear_touch_event_handler_region();
  static const int kTouchEventHandlerRegionFieldNumber = 19;
  inline const ::cc::proto::Region& touch_event_handler_region() const;
  inline ::cc::proto::Region* mutable_touch_event_handler_region();
  inline ::cc::proto::Region* release_touch_event_handler_region();
  inline void set_allocated_touch_event_handler_region(::cc::proto::Region* touch_event_handler_region);

  // optional bool contents_opaque = 21;
  inline bool has_contents_opaque() const;
  inline void clear_contents_opaque();
  static const int kContentsOpaqueFieldNumber = 21;
  inline bool contents_opaque() const;
  inline void set_contents_opaque(bool value);

  // optional float opacity = 22;
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 22;
  inline float opacity() const;
  inline void set_opacity(float value);

  // optional .cc.proto.SkXfermode.Mode blend_mode = 23;
  inline bool has_blend_mode() const;
  inline void clear_blend_mode();
  static const int kBlendModeFieldNumber = 23;
  inline ::cc::proto::SkXfermode_Mode blend_mode() const;
  inline void set_blend_mode(::cc::proto::SkXfermode_Mode value);

  // optional bool is_root_for_isolated_group = 24;
  inline bool has_is_root_for_isolated_group() const;
  inline void clear_is_root_for_isolated_group();
  static const int kIsRootForIsolatedGroupFieldNumber = 24;
  inline bool is_root_for_isolated_group() const;
  inline void set_is_root_for_isolated_group(bool value);

  // optional .cc.proto.PointF position = 25;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 25;
  inline const ::cc::proto::PointF& position() const;
  inline ::cc::proto::PointF* mutable_position();
  inline ::cc::proto::PointF* release_position();
  inline void set_allocated_position(::cc::proto::PointF* position);

  // optional bool is_container_for_fixed_position_layers = 26;
  inline bool has_is_container_for_fixed_position_layers() const;
  inline void clear_is_container_for_fixed_position_layers();
  static const int kIsContainerForFixedPositionLayersFieldNumber = 26;
  inline bool is_container_for_fixed_position_layers() const;
  inline void set_is_container_for_fixed_position_layers(bool value);

  // optional .cc.proto.LayerPositionConstraint position_constraint = 27;
  inline bool has_position_constraint() const;
  inline void clear_position_constraint();
  static const int kPositionConstraintFieldNumber = 27;
  inline const ::cc::proto::LayerPositionConstraint& position_constraint() const;
  inline ::cc::proto::LayerPositionConstraint* mutable_position_constraint();
  inline ::cc::proto::LayerPositionConstraint* release_position_constraint();
  inline void set_allocated_position_constraint(::cc::proto::LayerPositionConstraint* position_constraint);

  // optional bool should_flatten_transform = 28;
  inline bool has_should_flatten_transform() const;
  inline void clear_should_flatten_transform();
  static const int kShouldFlattenTransformFieldNumber = 28;
  inline bool should_flatten_transform() const;
  inline void set_should_flatten_transform(bool value);

  // optional bool should_flatten_transform_from_property_tree = 29;
  inline bool has_should_flatten_transform_from_property_tree() const;
  inline void clear_should_flatten_transform_from_property_tree();
  static const int kShouldFlattenTransformFromPropertyTreeFieldNumber = 29;
  inline bool should_flatten_transform_from_property_tree() const;
  inline void set_should_flatten_transform_from_property_tree(bool value);

  // optional int32 num_layer_or_descendants_with_copy_request = 30;
  inline bool has_num_layer_or_descendants_with_copy_request() const;
  inline void clear_num_layer_or_descendants_with_copy_request();
  static const int kNumLayerOrDescendantsWithCopyRequestFieldNumber = 30;
  inline ::google::protobuf::int32 num_layer_or_descendants_with_copy_request() const;
  inline void set_num_layer_or_descendants_with_copy_request(::google::protobuf::int32 value);

  // optional .cc.proto.SkXfermode.Mode draw_blend_mode = 31;
  inline bool has_draw_blend_mode() const;
  inline void clear_draw_blend_mode();
  static const int kDrawBlendModeFieldNumber = 31;
  inline ::cc::proto::SkXfermode_Mode draw_blend_mode() const;
  inline void set_draw_blend_mode(::cc::proto::SkXfermode_Mode value);

  // optional bool use_parent_backface_visibility = 32;
  inline bool has_use_parent_backface_visibility() const;
  inline void clear_use_parent_backface_visibility();
  static const int kUseParentBackfaceVisibilityFieldNumber = 32;
  inline bool use_parent_backface_visibility() const;
  inline void set_use_parent_backface_visibility(bool value);

  // optional .cc.proto.Transform transform = 33;
  inline bool has_transform() const;
  inline void clear_transform();
  static const int kTransformFieldNumber = 33;
  inline const ::cc::proto::Transform& transform() const;
  inline ::cc::proto::Transform* mutable_transform();
  inline ::cc::proto::Transform* release_transform();
  inline void set_allocated_transform(::cc::proto::Transform* transform);

  // optional bool transform_is_invertible = 34;
  inline bool has_transform_is_invertible() const;
  inline void clear_transform_is_invertible();
  static const int kTransformIsInvertibleFieldNumber = 34;
  inline bool transform_is_invertible() const;
  inline void set_transform_is_invertible(bool value);

  // optional int32 sorting_context_id = 35;
  inline bool has_sorting_context_id() const;
  inline void clear_sorting_context_id();
  static const int kSortingContextIdFieldNumber = 35;
  inline ::google::protobuf::int32 sorting_context_id() const;
  inline void set_sorting_context_id(::google::protobuf::int32 value);

  // optional int32 num_descendants_that_draw_content = 36;
  inline bool has_num_descendants_that_draw_content() const;
  inline void clear_num_descendants_that_draw_content();
  static const int kNumDescendantsThatDrawContentFieldNumber = 36;
  inline ::google::protobuf::int32 num_descendants_that_draw_content() const;
  inline void set_num_descendants_that_draw_content(::google::protobuf::int32 value);

  // optional int32 scroll_clip_layer_id = 37;
  inline bool has_scroll_clip_layer_id() const;
  inline void clear_scroll_clip_layer_id();
  static const int kScrollClipLayerIdFieldNumber = 37;
  inline ::google::protobuf::int32 scroll_clip_layer_id() const;
  inline void set_scroll_clip_layer_id(::google::protobuf::int32 value);

  // optional bool user_scrollable_horizontal = 38;
  inline bool has_user_scrollable_horizontal() const;
  inline void clear_user_scrollable_horizontal();
  static const int kUserScrollableHorizontalFieldNumber = 38;
  inline bool user_scrollable_horizontal() const;
  inline void set_user_scrollable_horizontal(bool value);

  // optional bool user_scrollable_vertical = 39;
  inline bool has_user_scrollable_vertical() const;
  inline void clear_user_scrollable_vertical();
  static const int kUserScrollableVerticalFieldNumber = 39;
  inline bool user_scrollable_vertical() const;
  inline void set_user_scrollable_vertical(bool value);

  // optional int32 scroll_parent_id = 40;
  inline bool has_scroll_parent_id() const;
  inline void clear_scroll_parent_id();
  static const int kScrollParentIdFieldNumber = 40;
  inline ::google::protobuf::int32 scroll_parent_id() const;
  inline void set_scroll_parent_id(::google::protobuf::int32 value);

  // repeated int32 scroll_children_ids = 41;
  inline int scroll_children_ids_size() const;
  inline void clear_scroll_children_ids();
  static const int kScrollChildrenIdsFieldNumber = 41;
  inline ::google::protobuf::int32 scroll_children_ids(int index) const;
  inline void set_scroll_children_ids(int index, ::google::protobuf::int32 value);
  inline void add_scroll_children_ids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      scroll_children_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_scroll_children_ids();

  // optional int32 clip_parent_id = 42;
  inline bool has_clip_parent_id() const;
  inline void clear_clip_parent_id();
  static const int kClipParentIdFieldNumber = 42;
  inline ::google::protobuf::int32 clip_parent_id() const;
  inline void set_clip_parent_id(::google::protobuf::int32 value);

  // repeated int32 clip_children_ids = 43;
  inline int clip_children_ids_size() const;
  inline void clear_clip_children_ids();
  static const int kClipChildrenIdsFieldNumber = 43;
  inline ::google::protobuf::int32 clip_children_ids(int index) const;
  inline void set_clip_children_ids(int index, ::google::protobuf::int32 value);
  inline void add_clip_children_ids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      clip_children_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_clip_children_ids();

  // optional .cc.proto.ScrollOffset scroll_offset = 44;
  inline bool has_scroll_offset() const;
  inline void clear_scroll_offset();
  static const int kScrollOffsetFieldNumber = 44;
  inline const ::cc::proto::ScrollOffset& scroll_offset() const;
  inline ::cc::proto::ScrollOffset* mutable_scroll_offset();
  inline ::cc::proto::ScrollOffset* release_scroll_offset();
  inline void set_allocated_scroll_offset(::cc::proto::ScrollOffset* scroll_offset);

  // optional .cc.proto.Vector2dF scroll_compensation_adjustment = 45;
  inline bool has_scroll_compensation_adjustment() const;
  inline void clear_scroll_compensation_adjustment();
  static const int kScrollCompensationAdjustmentFieldNumber = 45;
  inline const ::cc::proto::Vector2dF& scroll_compensation_adjustment() const;
  inline ::cc::proto::Vector2dF* mutable_scroll_compensation_adjustment();
  inline ::cc::proto::Vector2dF* release_scroll_compensation_adjustment();
  inline void set_allocated_scroll_compensation_adjustment(::cc::proto::Vector2dF* scroll_compensation_adjustment);

  // optional .cc.proto.Rect update_rect = 46;
  inline bool has_update_rect() const;
  inline void clear_update_rect();
  static const int kUpdateRectFieldNumber = 46;
  inline const ::cc::proto::Rect& update_rect() const;
  inline ::cc::proto::Rect* mutable_update_rect();
  inline ::cc::proto::Rect* release_update_rect();
  inline void set_allocated_update_rect(::cc::proto::Rect* update_rect);

  // optional bool stacking_order_changed = 47;
  inline bool has_stacking_order_changed() const;
  inline void clear_stacking_order_changed();
  static const int kStackingOrderChangedFieldNumber = 47;
  inline bool stacking_order_changed() const;
  inline void set_stacking_order_changed(bool value);

  // @@protoc_insertion_point(class_scope:cc.proto.BaseLayerProperties)
 private:
  inline void set_has_transform_origin();
  inline void clear_has_transform_origin();
  inline void set_has_background_color();
  inline void clear_has_background_color();
  inline void set_has_bounds();
  inline void clear_has_bounds();
  inline void set_has_transform_free_index();
  inline void clear_has_transform_free_index();
  inline void set_has_effect_tree_index();
  inline void clear_has_effect_tree_index();
  inline void set_has_clip_tree_index();
  inline void clear_has_clip_tree_index();
  inline void set_has_scroll_tree_index();
  inline void clear_has_scroll_tree_index();
  inline void set_has_offset_to_transform_parent();
  inline void clear_has_offset_to_transform_parent();
  inline void set_has_double_sided();
  inline void clear_has_double_sided();
  inline void set_has_draws_content();
  inline void clear_has_draws_content();
  inline void set_has_hide_layer_and_subtree();
  inline void clear_has_hide_layer_and_subtree();
  inline void set_has_has_render_surface();
  inline void clear_has_has_render_surface();
  inline void set_has_masks_to_bounds();
  inline void clear_has_masks_to_bounds();
  inline void set_has_main_thread_scrolling_reasons();
  inline void clear_has_main_thread_scrolling_reasons();
  inline void set_has_have_scroll_event_handlers();
  inline void clear_has_have_scroll_event_handlers();
  inline void set_has_non_fast_scrollable_region();
  inline void clear_has_non_fast_scrollable_region();
  inline void set_has_touch_event_handler_region();
  inline void clear_has_touch_event_handler_region();
  inline void set_has_contents_opaque();
  inline void clear_has_contents_opaque();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_blend_mode();
  inline void clear_has_blend_mode();
  inline void set_has_is_root_for_isolated_group();
  inline void clear_has_is_root_for_isolated_group();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_is_container_for_fixed_position_layers();
  inline void clear_has_is_container_for_fixed_position_layers();
  inline void set_has_position_constraint();
  inline void clear_has_position_constraint();
  inline void set_has_should_flatten_transform();
  inline void clear_has_should_flatten_transform();
  inline void set_has_should_flatten_transform_from_property_tree();
  inline void clear_has_should_flatten_transform_from_property_tree();
  inline void set_has_num_layer_or_descendants_with_copy_request();
  inline void clear_has_num_layer_or_descendants_with_copy_request();
  inline void set_has_draw_blend_mode();
  inline void clear_has_draw_blend_mode();
  inline void set_has_use_parent_backface_visibility();
  inline void clear_has_use_parent_backface_visibility();
  inline void set_has_transform();
  inline void clear_has_transform();
  inline void set_has_transform_is_invertible();
  inline void clear_has_transform_is_invertible();
  inline void set_has_sorting_context_id();
  inline void clear_has_sorting_context_id();
  inline void set_has_num_descendants_that_draw_content();
  inline void clear_has_num_descendants_that_draw_content();
  inline void set_has_scroll_clip_layer_id();
  inline void clear_has_scroll_clip_layer_id();
  inline void set_has_user_scrollable_horizontal();
  inline void clear_has_user_scrollable_horizontal();
  inline void set_has_user_scrollable_vertical();
  inline void clear_has_user_scrollable_vertical();
  inline void set_has_scroll_parent_id();
  inline void clear_has_scroll_parent_id();
  inline void set_has_clip_parent_id();
  inline void clear_has_clip_parent_id();
  inline void set_has_scroll_offset();
  inline void clear_has_scroll_offset();
  inline void set_has_scroll_compensation_adjustment();
  inline void clear_has_scroll_compensation_adjustment();
  inline void set_has_update_rect();
  inline void clear_has_update_rect();
  inline void set_has_stacking_order_changed();
  inline void clear_has_stacking_order_changed();

  ::cc::proto::Point3F* transform_origin_;
  ::cc::proto::Size* bounds_;
  ::google::protobuf::int64 transform_free_index_;
  ::google::protobuf::int64 effect_tree_index_;
  ::google::protobuf::int64 clip_tree_index_;
  ::google::protobuf::int64 scroll_tree_index_;
  ::cc::proto::Vector2dF* offset_to_transform_parent_;
  ::google::protobuf::uint32 background_color_;
  bool double_sided_;
  bool draws_content_;
  bool hide_layer_and_subtree_;
  bool has_render_surface_;
  ::cc::proto::Region* non_fast_scrollable_region_;
  ::google::protobuf::uint32 main_thread_scrolling_reasons_;
  bool masks_to_bounds_;
  bool have_scroll_event_handlers_;
  bool contents_opaque_;
  bool is_root_for_isolated_group_;
  ::cc::proto::Region* touch_event_handler_region_;
  float opacity_;
  int blend_mode_;
  ::cc::proto::PointF* position_;
  ::cc::proto::LayerPositionConstraint* position_constraint_;
  bool is_container_for_fixed_position_layers_;
  bool should_flatten_transform_;
  bool should_flatten_transform_from_property_tree_;
  bool use_parent_backface_visibility_;
  ::google::protobuf::int32 num_layer_or_descendants_with_copy_request_;
  ::cc::proto::Transform* transform_;
  int draw_blend_mode_;
  ::google::protobuf::int32 sorting_context_id_;
  ::google::protobuf::int32 num_descendants_that_draw_content_;
  ::google::protobuf::int32 scroll_clip_layer_id_;
  bool transform_is_invertible_;
  bool user_scrollable_horizontal_;
  bool user_scrollable_vertical_;
  bool stacking_order_changed_;
  ::google::protobuf::int32 scroll_parent_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > scroll_children_ids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > clip_children_ids_;
  ::cc::proto::ScrollOffset* scroll_offset_;
  ::cc::proto::Vector2dF* scroll_compensation_adjustment_;
  ::cc::proto::Rect* update_rect_;
  ::google::protobuf::int32 clip_parent_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(44 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto();
  #endif
  friend void protobuf_AssignDesc_layer_2eproto();
  friend void protobuf_ShutdownFile_layer_2eproto();

  void InitAsDefaultInstance();
  static BaseLayerProperties* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT PictureLayerProperties : public ::google::protobuf::MessageLite {
 public:
  PictureLayerProperties();
  virtual ~PictureLayerProperties();

  PictureLayerProperties(const PictureLayerProperties& from);

  inline PictureLayerProperties& operator=(const PictureLayerProperties& from) {
    CopyFrom(from);
    return *this;
  }

  static const PictureLayerProperties& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PictureLayerProperties* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PictureLayerProperties* other);

  // implements Message ----------------------------------------------

  PictureLayerProperties* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PictureLayerProperties& from);
  void MergeFrom(const PictureLayerProperties& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cc.proto.DisplayListRecordingSource recording_source = 1;
  inline bool has_recording_source() const;
  inline void clear_recording_source();
  static const int kRecordingSourceFieldNumber = 1;
  inline const ::cc::proto::DisplayListRecordingSource& recording_source() const;
  inline ::cc::proto::DisplayListRecordingSource* mutable_recording_source();
  inline ::cc::proto::DisplayListRecordingSource* release_recording_source();
  inline void set_allocated_recording_source(::cc::proto::DisplayListRecordingSource* recording_source);

  // optional .cc.proto.Region invalidation = 2;
  inline bool has_invalidation() const;
  inline void clear_invalidation();
  static const int kInvalidationFieldNumber = 2;
  inline const ::cc::proto::Region& invalidation() const;
  inline ::cc::proto::Region* mutable_invalidation();
  inline ::cc::proto::Region* release_invalidation();
  inline void set_allocated_invalidation(::cc::proto::Region* invalidation);

  // optional .cc.proto.Rect last_updated_visible_layer_rect = 3;
  inline bool has_last_updated_visible_layer_rect() const;
  inline void clear_last_updated_visible_layer_rect();
  static const int kLastUpdatedVisibleLayerRectFieldNumber = 3;
  inline const ::cc::proto::Rect& last_updated_visible_layer_rect() const;
  inline ::cc::proto::Rect* mutable_last_updated_visible_layer_rect();
  inline ::cc::proto::Rect* release_last_updated_visible_layer_rect();
  inline void set_allocated_last_updated_visible_layer_rect(::cc::proto::Rect* last_updated_visible_layer_rect);

  // optional bool is_mask = 4;
  inline bool has_is_mask() const;
  inline void clear_is_mask();
  static const int kIsMaskFieldNumber = 4;
  inline bool is_mask() const;
  inline void set_is_mask(bool value);

  // optional bool nearest_neighbor = 5;
  inline bool has_nearest_neighbor() const;
  inline void clear_nearest_neighbor();
  static const int kNearestNeighborFieldNumber = 5;
  inline bool nearest_neighbor() const;
  inline void set_nearest_neighbor(bool value);

  // optional int64 update_source_frame_number = 6;
  inline bool has_update_source_frame_number() const;
  inline void clear_update_source_frame_number();
  static const int kUpdateSourceFrameNumberFieldNumber = 6;
  inline ::google::protobuf::int64 update_source_frame_number() const;
  inline void set_update_source_frame_number(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:cc.proto.PictureLayerProperties)
 private:
  inline void set_has_recording_source();
  inline void clear_has_recording_source();
  inline void set_has_invalidation();
  inline void clear_has_invalidation();
  inline void set_has_last_updated_visible_layer_rect();
  inline void clear_has_last_updated_visible_layer_rect();
  inline void set_has_is_mask();
  inline void clear_has_is_mask();
  inline void set_has_nearest_neighbor();
  inline void clear_has_nearest_neighbor();
  inline void set_has_update_source_frame_number();
  inline void clear_has_update_source_frame_number();

  ::cc::proto::DisplayListRecordingSource* recording_source_;
  ::cc::proto::Region* invalidation_;
  ::cc::proto::Rect* last_updated_visible_layer_rect_;
  ::google::protobuf::int64 update_source_frame_number_;
  bool is_mask_;
  bool nearest_neighbor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_2eproto();
  #endif
  friend void protobuf_AssignDesc_layer_2eproto();
  friend void protobuf_ShutdownFile_layer_2eproto();

  void InitAsDefaultInstance();
  static PictureLayerProperties* default_instance_;
};
// ===================================================================


// ===================================================================

// LayerNode

// optional int32 id = 1;
inline bool LayerNode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerNode::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayerNode::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayerNode::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 LayerNode::id() const {
  return id_;
}
inline void LayerNode::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .cc.proto.LayerType type = 2;
inline bool LayerNode::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayerNode::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LayerNode::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LayerNode::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::cc::proto::LayerType LayerNode::type() const {
  return static_cast< ::cc::proto::LayerType >(type_);
}
inline void LayerNode::set_type(::cc::proto::LayerType value) {
  assert(::cc::proto::LayerType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 parent_id = 3;
inline bool LayerNode::has_parent_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LayerNode::set_has_parent_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LayerNode::clear_has_parent_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LayerNode::clear_parent_id() {
  parent_id_ = 0;
  clear_has_parent_id();
}
inline ::google::protobuf::int32 LayerNode::parent_id() const {
  return parent_id_;
}
inline void LayerNode::set_parent_id(::google::protobuf::int32 value) {
  set_has_parent_id();
  parent_id_ = value;
}

// repeated .cc.proto.LayerNode children = 4;
inline int LayerNode::children_size() const {
  return children_.size();
}
inline void LayerNode::clear_children() {
  children_.Clear();
}
inline const ::cc::proto::LayerNode& LayerNode::children(int index) const {
  return children_.Get(index);
}
inline ::cc::proto::LayerNode* LayerNode::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::cc::proto::LayerNode* LayerNode::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cc::proto::LayerNode >&
LayerNode::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::cc::proto::LayerNode >*
LayerNode::mutable_children() {
  return &children_;
}

// optional .cc.proto.LayerNode mask_layer = 5;
inline bool LayerNode::has_mask_layer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LayerNode::set_has_mask_layer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LayerNode::clear_has_mask_layer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LayerNode::clear_mask_layer() {
  if (mask_layer_ != NULL) mask_layer_->::cc::proto::LayerNode::Clear();
  clear_has_mask_layer();
}
inline const ::cc::proto::LayerNode& LayerNode::mask_layer() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return mask_layer_ != NULL ? *mask_layer_ : *default_instance().mask_layer_;
#else
  return mask_layer_ != NULL ? *mask_layer_ : *default_instance_->mask_layer_;
#endif
}
inline ::cc::proto::LayerNode* LayerNode::mutable_mask_layer() {
  set_has_mask_layer();
  if (mask_layer_ == NULL) mask_layer_ = new ::cc::proto::LayerNode;
  return mask_layer_;
}
inline ::cc::proto::LayerNode* LayerNode::release_mask_layer() {
  clear_has_mask_layer();
  ::cc::proto::LayerNode* temp = mask_layer_;
  mask_layer_ = NULL;
  return temp;
}
inline void LayerNode::set_allocated_mask_layer(::cc::proto::LayerNode* mask_layer) {
  delete mask_layer_;
  mask_layer_ = mask_layer;
  if (mask_layer) {
    set_has_mask_layer();
  } else {
    clear_has_mask_layer();
  }
}

// optional .cc.proto.LayerNode replica_layer = 6;
inline bool LayerNode::has_replica_layer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LayerNode::set_has_replica_layer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LayerNode::clear_has_replica_layer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LayerNode::clear_replica_layer() {
  if (replica_layer_ != NULL) replica_layer_->::cc::proto::LayerNode::Clear();
  clear_has_replica_layer();
}
inline const ::cc::proto::LayerNode& LayerNode::replica_layer() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return replica_layer_ != NULL ? *replica_layer_ : *default_instance().replica_layer_;
#else
  return replica_layer_ != NULL ? *replica_layer_ : *default_instance_->replica_layer_;
#endif
}
inline ::cc::proto::LayerNode* LayerNode::mutable_replica_layer() {
  set_has_replica_layer();
  if (replica_layer_ == NULL) replica_layer_ = new ::cc::proto::LayerNode;
  return replica_layer_;
}
inline ::cc::proto::LayerNode* LayerNode::release_replica_layer() {
  clear_has_replica_layer();
  ::cc::proto::LayerNode* temp = replica_layer_;
  replica_layer_ = NULL;
  return temp;
}
inline void LayerNode::set_allocated_replica_layer(::cc::proto::LayerNode* replica_layer) {
  delete replica_layer_;
  replica_layer_ = replica_layer;
  if (replica_layer) {
    set_has_replica_layer();
  } else {
    clear_has_replica_layer();
  }
}

// -------------------------------------------------------------------

// LayerUpdate

// repeated .cc.proto.LayerProperties layers = 1;
inline int LayerUpdate::layers_size() const {
  return layers_.size();
}
inline void LayerUpdate::clear_layers() {
  layers_.Clear();
}
inline const ::cc::proto::LayerProperties& LayerUpdate::layers(int index) const {
  return layers_.Get(index);
}
inline ::cc::proto::LayerProperties* LayerUpdate::mutable_layers(int index) {
  return layers_.Mutable(index);
}
inline ::cc::proto::LayerProperties* LayerUpdate::add_layers() {
  return layers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cc::proto::LayerProperties >&
LayerUpdate::layers() const {
  return layers_;
}
inline ::google::protobuf::RepeatedPtrField< ::cc::proto::LayerProperties >*
LayerUpdate::mutable_layers() {
  return &layers_;
}

// -------------------------------------------------------------------

// LayerProperties

// optional int32 id = 1;
inline bool LayerProperties::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerProperties::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayerProperties::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayerProperties::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 LayerProperties::id() const {
  return id_;
}
inline void LayerProperties::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional bool needs_push_properties = 3;
inline bool LayerProperties::has_needs_push_properties() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayerProperties::set_has_needs_push_properties() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LayerProperties::clear_has_needs_push_properties() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LayerProperties::clear_needs_push_properties() {
  needs_push_properties_ = false;
  clear_has_needs_push_properties();
}
inline bool LayerProperties::needs_push_properties() const {
  return needs_push_properties_;
}
inline void LayerProperties::set_needs_push_properties(bool value) {
  set_has_needs_push_properties();
  needs_push_properties_ = value;
}

// optional int32 num_dependents_need_push_properties = 4;
inline bool LayerProperties::has_num_dependents_need_push_properties() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LayerProperties::set_has_num_dependents_need_push_properties() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LayerProperties::clear_has_num_dependents_need_push_properties() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LayerProperties::clear_num_dependents_need_push_properties() {
  num_dependents_need_push_properties_ = 0;
  clear_has_num_dependents_need_push_properties();
}
inline ::google::protobuf::int32 LayerProperties::num_dependents_need_push_properties() const {
  return num_dependents_need_push_properties_;
}
inline void LayerProperties::set_num_dependents_need_push_properties(::google::protobuf::int32 value) {
  set_has_num_dependents_need_push_properties();
  num_dependents_need_push_properties_ = value;
}

// optional .cc.proto.BaseLayerProperties base = 5;
inline bool LayerProperties::has_base() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LayerProperties::set_has_base() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LayerProperties::clear_has_base() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LayerProperties::clear_base() {
  if (base_ != NULL) base_->::cc::proto::BaseLayerProperties::Clear();
  clear_has_base();
}
inline const ::cc::proto::BaseLayerProperties& LayerProperties::base() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return base_ != NULL ? *base_ : *default_instance().base_;
#else
  return base_ != NULL ? *base_ : *default_instance_->base_;
#endif
}
inline ::cc::proto::BaseLayerProperties* LayerProperties::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::cc::proto::BaseLayerProperties;
  return base_;
}
inline ::cc::proto::BaseLayerProperties* LayerProperties::release_base() {
  clear_has_base();
  ::cc::proto::BaseLayerProperties* temp = base_;
  base_ = NULL;
  return temp;
}
inline void LayerProperties::set_allocated_base(::cc::proto::BaseLayerProperties* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional .cc.proto.PictureLayerProperties picture = 6;
inline bool LayerProperties::has_picture() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LayerProperties::set_has_picture() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LayerProperties::clear_has_picture() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LayerProperties::clear_picture() {
  if (picture_ != NULL) picture_->::cc::proto::PictureLayerProperties::Clear();
  clear_has_picture();
}
inline const ::cc::proto::PictureLayerProperties& LayerProperties::picture() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return picture_ != NULL ? *picture_ : *default_instance().picture_;
#else
  return picture_ != NULL ? *picture_ : *default_instance_->picture_;
#endif
}
inline ::cc::proto::PictureLayerProperties* LayerProperties::mutable_picture() {
  set_has_picture();
  if (picture_ == NULL) picture_ = new ::cc::proto::PictureLayerProperties;
  return picture_;
}
inline ::cc::proto::PictureLayerProperties* LayerProperties::release_picture() {
  clear_has_picture();
  ::cc::proto::PictureLayerProperties* temp = picture_;
  picture_ = NULL;
  return temp;
}
inline void LayerProperties::set_allocated_picture(::cc::proto::PictureLayerProperties* picture) {
  delete picture_;
  picture_ = picture;
  if (picture) {
    set_has_picture();
  } else {
    clear_has_picture();
  }
}

// -------------------------------------------------------------------

// BaseLayerProperties

// optional .cc.proto.Point3F transform_origin = 1;
inline bool BaseLayerProperties::has_transform_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseLayerProperties::set_has_transform_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseLayerProperties::clear_has_transform_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseLayerProperties::clear_transform_origin() {
  if (transform_origin_ != NULL) transform_origin_->::cc::proto::Point3F::Clear();
  clear_has_transform_origin();
}
inline const ::cc::proto::Point3F& BaseLayerProperties::transform_origin() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transform_origin_ != NULL ? *transform_origin_ : *default_instance().transform_origin_;
#else
  return transform_origin_ != NULL ? *transform_origin_ : *default_instance_->transform_origin_;
#endif
}
inline ::cc::proto::Point3F* BaseLayerProperties::mutable_transform_origin() {
  set_has_transform_origin();
  if (transform_origin_ == NULL) transform_origin_ = new ::cc::proto::Point3F;
  return transform_origin_;
}
inline ::cc::proto::Point3F* BaseLayerProperties::release_transform_origin() {
  clear_has_transform_origin();
  ::cc::proto::Point3F* temp = transform_origin_;
  transform_origin_ = NULL;
  return temp;
}
inline void BaseLayerProperties::set_allocated_transform_origin(::cc::proto::Point3F* transform_origin) {
  delete transform_origin_;
  transform_origin_ = transform_origin;
  if (transform_origin) {
    set_has_transform_origin();
  } else {
    clear_has_transform_origin();
  }
}

// optional uint32 background_color = 2;
inline bool BaseLayerProperties::has_background_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BaseLayerProperties::set_has_background_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BaseLayerProperties::clear_has_background_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BaseLayerProperties::clear_background_color() {
  background_color_ = 0u;
  clear_has_background_color();
}
inline ::google::protobuf::uint32 BaseLayerProperties::background_color() const {
  return background_color_;
}
inline void BaseLayerProperties::set_background_color(::google::protobuf::uint32 value) {
  set_has_background_color();
  background_color_ = value;
}

// optional .cc.proto.Size bounds = 3;
inline bool BaseLayerProperties::has_bounds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BaseLayerProperties::set_has_bounds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BaseLayerProperties::clear_has_bounds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BaseLayerProperties::clear_bounds() {
  if (bounds_ != NULL) bounds_->::cc::proto::Size::Clear();
  clear_has_bounds();
}
inline const ::cc::proto::Size& BaseLayerProperties::bounds() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bounds_ != NULL ? *bounds_ : *default_instance().bounds_;
#else
  return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
#endif
}
inline ::cc::proto::Size* BaseLayerProperties::mutable_bounds() {
  set_has_bounds();
  if (bounds_ == NULL) bounds_ = new ::cc::proto::Size;
  return bounds_;
}
inline ::cc::proto::Size* BaseLayerProperties::release_bounds() {
  clear_has_bounds();
  ::cc::proto::Size* temp = bounds_;
  bounds_ = NULL;
  return temp;
}
inline void BaseLayerProperties::set_allocated_bounds(::cc::proto::Size* bounds) {
  delete bounds_;
  bounds_ = bounds;
  if (bounds) {
    set_has_bounds();
  } else {
    clear_has_bounds();
  }
}

// optional int64 transform_free_index = 4;
inline bool BaseLayerProperties::has_transform_free_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BaseLayerProperties::set_has_transform_free_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BaseLayerProperties::clear_has_transform_free_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BaseLayerProperties::clear_transform_free_index() {
  transform_free_index_ = GOOGLE_LONGLONG(0);
  clear_has_transform_free_index();
}
inline ::google::protobuf::int64 BaseLayerProperties::transform_free_index() const {
  return transform_free_index_;
}
inline void BaseLayerProperties::set_transform_free_index(::google::protobuf::int64 value) {
  set_has_transform_free_index();
  transform_free_index_ = value;
}

// optional int64 effect_tree_index = 5;
inline bool BaseLayerProperties::has_effect_tree_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BaseLayerProperties::set_has_effect_tree_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BaseLayerProperties::clear_has_effect_tree_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BaseLayerProperties::clear_effect_tree_index() {
  effect_tree_index_ = GOOGLE_LONGLONG(0);
  clear_has_effect_tree_index();
}
inline ::google::protobuf::int64 BaseLayerProperties::effect_tree_index() const {
  return effect_tree_index_;
}
inline void BaseLayerProperties::set_effect_tree_index(::google::protobuf::int64 value) {
  set_has_effect_tree_index();
  effect_tree_index_ = value;
}

// optional int64 clip_tree_index = 6;
inline bool BaseLayerProperties::has_clip_tree_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BaseLayerProperties::set_has_clip_tree_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BaseLayerProperties::clear_has_clip_tree_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BaseLayerProperties::clear_clip_tree_index() {
  clip_tree_index_ = GOOGLE_LONGLONG(0);
  clear_has_clip_tree_index();
}
inline ::google::protobuf::int64 BaseLayerProperties::clip_tree_index() const {
  return clip_tree_index_;
}
inline void BaseLayerProperties::set_clip_tree_index(::google::protobuf::int64 value) {
  set_has_clip_tree_index();
  clip_tree_index_ = value;
}

// optional int64 scroll_tree_index = 50;
inline bool BaseLayerProperties::has_scroll_tree_index() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BaseLayerProperties::set_has_scroll_tree_index() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BaseLayerProperties::clear_has_scroll_tree_index() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BaseLayerProperties::clear_scroll_tree_index() {
  scroll_tree_index_ = GOOGLE_LONGLONG(0);
  clear_has_scroll_tree_index();
}
inline ::google::protobuf::int64 BaseLayerProperties::scroll_tree_index() const {
  return scroll_tree_index_;
}
inline void BaseLayerProperties::set_scroll_tree_index(::google::protobuf::int64 value) {
  set_has_scroll_tree_index();
  scroll_tree_index_ = value;
}

// optional .cc.proto.Vector2dF offset_to_transform_parent = 7;
inline bool BaseLayerProperties::has_offset_to_transform_parent() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BaseLayerProperties::set_has_offset_to_transform_parent() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BaseLayerProperties::clear_has_offset_to_transform_parent() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BaseLayerProperties::clear_offset_to_transform_parent() {
  if (offset_to_transform_parent_ != NULL) offset_to_transform_parent_->::cc::proto::Vector2dF::Clear();
  clear_has_offset_to_transform_parent();
}
inline const ::cc::proto::Vector2dF& BaseLayerProperties::offset_to_transform_parent() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return offset_to_transform_parent_ != NULL ? *offset_to_transform_parent_ : *default_instance().offset_to_transform_parent_;
#else
  return offset_to_transform_parent_ != NULL ? *offset_to_transform_parent_ : *default_instance_->offset_to_transform_parent_;
#endif
}
inline ::cc::proto::Vector2dF* BaseLayerProperties::mutable_offset_to_transform_parent() {
  set_has_offset_to_transform_parent();
  if (offset_to_transform_parent_ == NULL) offset_to_transform_parent_ = new ::cc::proto::Vector2dF;
  return offset_to_transform_parent_;
}
inline ::cc::proto::Vector2dF* BaseLayerProperties::release_offset_to_transform_parent() {
  clear_has_offset_to_transform_parent();
  ::cc::proto::Vector2dF* temp = offset_to_transform_parent_;
  offset_to_transform_parent_ = NULL;
  return temp;
}
inline void BaseLayerProperties::set_allocated_offset_to_transform_parent(::cc::proto::Vector2dF* offset_to_transform_parent) {
  delete offset_to_transform_parent_;
  offset_to_transform_parent_ = offset_to_transform_parent;
  if (offset_to_transform_parent) {
    set_has_offset_to_transform_parent();
  } else {
    clear_has_offset_to_transform_parent();
  }
}

// optional bool double_sided = 8;
inline bool BaseLayerProperties::has_double_sided() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BaseLayerProperties::set_has_double_sided() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BaseLayerProperties::clear_has_double_sided() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BaseLayerProperties::clear_double_sided() {
  double_sided_ = false;
  clear_has_double_sided();
}
inline bool BaseLayerProperties::double_sided() const {
  return double_sided_;
}
inline void BaseLayerProperties::set_double_sided(bool value) {
  set_has_double_sided();
  double_sided_ = value;
}

// optional bool draws_content = 9;
inline bool BaseLayerProperties::has_draws_content() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BaseLayerProperties::set_has_draws_content() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BaseLayerProperties::clear_has_draws_content() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BaseLayerProperties::clear_draws_content() {
  draws_content_ = false;
  clear_has_draws_content();
}
inline bool BaseLayerProperties::draws_content() const {
  return draws_content_;
}
inline void BaseLayerProperties::set_draws_content(bool value) {
  set_has_draws_content();
  draws_content_ = value;
}

// optional bool hide_layer_and_subtree = 10;
inline bool BaseLayerProperties::has_hide_layer_and_subtree() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BaseLayerProperties::set_has_hide_layer_and_subtree() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BaseLayerProperties::clear_has_hide_layer_and_subtree() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BaseLayerProperties::clear_hide_layer_and_subtree() {
  hide_layer_and_subtree_ = false;
  clear_has_hide_layer_and_subtree();
}
inline bool BaseLayerProperties::hide_layer_and_subtree() const {
  return hide_layer_and_subtree_;
}
inline void BaseLayerProperties::set_hide_layer_and_subtree(bool value) {
  set_has_hide_layer_and_subtree();
  hide_layer_and_subtree_ = value;
}

// optional bool has_render_surface = 11;
inline bool BaseLayerProperties::has_has_render_surface() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BaseLayerProperties::set_has_has_render_surface() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BaseLayerProperties::clear_has_has_render_surface() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BaseLayerProperties::clear_has_render_surface() {
  has_render_surface_ = false;
  clear_has_has_render_surface();
}
inline bool BaseLayerProperties::has_render_surface() const {
  return has_render_surface_;
}
inline void BaseLayerProperties::set_has_render_surface(bool value) {
  set_has_has_render_surface();
  has_render_surface_ = value;
}

// optional bool masks_to_bounds = 14;
inline bool BaseLayerProperties::has_masks_to_bounds() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BaseLayerProperties::set_has_masks_to_bounds() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BaseLayerProperties::clear_has_masks_to_bounds() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BaseLayerProperties::clear_masks_to_bounds() {
  masks_to_bounds_ = false;
  clear_has_masks_to_bounds();
}
inline bool BaseLayerProperties::masks_to_bounds() const {
  return masks_to_bounds_;
}
inline void BaseLayerProperties::set_masks_to_bounds(bool value) {
  set_has_masks_to_bounds();
  masks_to_bounds_ = value;
}

// optional uint32 main_thread_scrolling_reasons = 15;
inline bool BaseLayerProperties::has_main_thread_scrolling_reasons() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BaseLayerProperties::set_has_main_thread_scrolling_reasons() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BaseLayerProperties::clear_has_main_thread_scrolling_reasons() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BaseLayerProperties::clear_main_thread_scrolling_reasons() {
  main_thread_scrolling_reasons_ = 0u;
  clear_has_main_thread_scrolling_reasons();
}
inline ::google::protobuf::uint32 BaseLayerProperties::main_thread_scrolling_reasons() const {
  return main_thread_scrolling_reasons_;
}
inline void BaseLayerProperties::set_main_thread_scrolling_reasons(::google::protobuf::uint32 value) {
  set_has_main_thread_scrolling_reasons();
  main_thread_scrolling_reasons_ = value;
}

// optional bool have_scroll_event_handlers = 17;
inline bool BaseLayerProperties::has_have_scroll_event_handlers() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BaseLayerProperties::set_has_have_scroll_event_handlers() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BaseLayerProperties::clear_has_have_scroll_event_handlers() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BaseLayerProperties::clear_have_scroll_event_handlers() {
  have_scroll_event_handlers_ = false;
  clear_has_have_scroll_event_handlers();
}
inline bool BaseLayerProperties::have_scroll_event_handlers() const {
  return have_scroll_event_handlers_;
}
inline void BaseLayerProperties::set_have_scroll_event_handlers(bool value) {
  set_has_have_scroll_event_handlers();
  have_scroll_event_handlers_ = value;
}

// optional .cc.proto.Region non_fast_scrollable_region = 18;
inline bool BaseLayerProperties::has_non_fast_scrollable_region() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BaseLayerProperties::set_has_non_fast_scrollable_region() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BaseLayerProperties::clear_has_non_fast_scrollable_region() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BaseLayerProperties::clear_non_fast_scrollable_region() {
  if (non_fast_scrollable_region_ != NULL) non_fast_scrollable_region_->::cc::proto::Region::Clear();
  clear_has_non_fast_scrollable_region();
}
inline const ::cc::proto::Region& BaseLayerProperties::non_fast_scrollable_region() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return non_fast_scrollable_region_ != NULL ? *non_fast_scrollable_region_ : *default_instance().non_fast_scrollable_region_;
#else
  return non_fast_scrollable_region_ != NULL ? *non_fast_scrollable_region_ : *default_instance_->non_fast_scrollable_region_;
#endif
}
inline ::cc::proto::Region* BaseLayerProperties::mutable_non_fast_scrollable_region() {
  set_has_non_fast_scrollable_region();
  if (non_fast_scrollable_region_ == NULL) non_fast_scrollable_region_ = new ::cc::proto::Region;
  return non_fast_scrollable_region_;
}
inline ::cc::proto::Region* BaseLayerProperties::release_non_fast_scrollable_region() {
  clear_has_non_fast_scrollable_region();
  ::cc::proto::Region* temp = non_fast_scrollable_region_;
  non_fast_scrollable_region_ = NULL;
  return temp;
}
inline void BaseLayerProperties::set_allocated_non_fast_scrollable_region(::cc::proto::Region* non_fast_scrollable_region) {
  delete non_fast_scrollable_region_;
  non_fast_scrollable_region_ = non_fast_scrollable_region;
  if (non_fast_scrollable_region) {
    set_has_non_fast_scrollable_region();
  } else {
    clear_has_non_fast_scrollable_region();
  }
}

// optional .cc.proto.Region touch_event_handler_region = 19;
inline bool BaseLayerProperties::has_touch_event_handler_region() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BaseLayerProperties::set_has_touch_event_handler_region() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BaseLayerProperties::clear_has_touch_event_handler_region() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BaseLayerProperties::clear_touch_event_handler_region() {
  if (touch_event_handler_region_ != NULL) touch_event_handler_region_->::cc::proto::Region::Clear();
  clear_has_touch_event_handler_region();
}
inline const ::cc::proto::Region& BaseLayerProperties::touch_event_handler_region() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return touch_event_handler_region_ != NULL ? *touch_event_handler_region_ : *default_instance().touch_event_handler_region_;
#else
  return touch_event_handler_region_ != NULL ? *touch_event_handler_region_ : *default_instance_->touch_event_handler_region_;
#endif
}
inline ::cc::proto::Region* BaseLayerProperties::mutable_touch_event_handler_region() {
  set_has_touch_event_handler_region();
  if (touch_event_handler_region_ == NULL) touch_event_handler_region_ = new ::cc::proto::Region;
  return touch_event_handler_region_;
}
inline ::cc::proto::Region* BaseLayerProperties::release_touch_event_handler_region() {
  clear_has_touch_event_handler_region();
  ::cc::proto::Region* temp = touch_event_handler_region_;
  touch_event_handler_region_ = NULL;
  return temp;
}
inline void BaseLayerProperties::set_allocated_touch_event_handler_region(::cc::proto::Region* touch_event_handler_region) {
  delete touch_event_handler_region_;
  touch_event_handler_region_ = touch_event_handler_region;
  if (touch_event_handler_region) {
    set_has_touch_event_handler_region();
  } else {
    clear_has_touch_event_handler_region();
  }
}

// optional bool contents_opaque = 21;
inline bool BaseLayerProperties::has_contents_opaque() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BaseLayerProperties::set_has_contents_opaque() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BaseLayerProperties::clear_has_contents_opaque() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BaseLayerProperties::clear_contents_opaque() {
  contents_opaque_ = false;
  clear_has_contents_opaque();
}
inline bool BaseLayerProperties::contents_opaque() const {
  return contents_opaque_;
}
inline void BaseLayerProperties::set_contents_opaque(bool value) {
  set_has_contents_opaque();
  contents_opaque_ = value;
}

// optional float opacity = 22;
inline bool BaseLayerProperties::has_opacity() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BaseLayerProperties::set_has_opacity() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BaseLayerProperties::clear_has_opacity() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BaseLayerProperties::clear_opacity() {
  opacity_ = 0;
  clear_has_opacity();
}
inline float BaseLayerProperties::opacity() const {
  return opacity_;
}
inline void BaseLayerProperties::set_opacity(float value) {
  set_has_opacity();
  opacity_ = value;
}

// optional .cc.proto.SkXfermode.Mode blend_mode = 23;
inline bool BaseLayerProperties::has_blend_mode() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BaseLayerProperties::set_has_blend_mode() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BaseLayerProperties::clear_has_blend_mode() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BaseLayerProperties::clear_blend_mode() {
  blend_mode_ = 0;
  clear_has_blend_mode();
}
inline ::cc::proto::SkXfermode_Mode BaseLayerProperties::blend_mode() const {
  return static_cast< ::cc::proto::SkXfermode_Mode >(blend_mode_);
}
inline void BaseLayerProperties::set_blend_mode(::cc::proto::SkXfermode_Mode value) {
  assert(::cc::proto::SkXfermode_Mode_IsValid(value));
  set_has_blend_mode();
  blend_mode_ = value;
}

// optional bool is_root_for_isolated_group = 24;
inline bool BaseLayerProperties::has_is_root_for_isolated_group() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BaseLayerProperties::set_has_is_root_for_isolated_group() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BaseLayerProperties::clear_has_is_root_for_isolated_group() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BaseLayerProperties::clear_is_root_for_isolated_group() {
  is_root_for_isolated_group_ = false;
  clear_has_is_root_for_isolated_group();
}
inline bool BaseLayerProperties::is_root_for_isolated_group() const {
  return is_root_for_isolated_group_;
}
inline void BaseLayerProperties::set_is_root_for_isolated_group(bool value) {
  set_has_is_root_for_isolated_group();
  is_root_for_isolated_group_ = value;
}

// optional .cc.proto.PointF position = 25;
inline bool BaseLayerProperties::has_position() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void BaseLayerProperties::set_has_position() {
  _has_bits_[0] |= 0x00200000u;
}
inline void BaseLayerProperties::clear_has_position() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void BaseLayerProperties::clear_position() {
  if (position_ != NULL) position_->::cc::proto::PointF::Clear();
  clear_has_position();
}
inline const ::cc::proto::PointF& BaseLayerProperties::position() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return position_ != NULL ? *position_ : *default_instance().position_;
#else
  return position_ != NULL ? *position_ : *default_instance_->position_;
#endif
}
inline ::cc::proto::PointF* BaseLayerProperties::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::cc::proto::PointF;
  return position_;
}
inline ::cc::proto::PointF* BaseLayerProperties::release_position() {
  clear_has_position();
  ::cc::proto::PointF* temp = position_;
  position_ = NULL;
  return temp;
}
inline void BaseLayerProperties::set_allocated_position(::cc::proto::PointF* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// optional bool is_container_for_fixed_position_layers = 26;
inline bool BaseLayerProperties::has_is_container_for_fixed_position_layers() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void BaseLayerProperties::set_has_is_container_for_fixed_position_layers() {
  _has_bits_[0] |= 0x00400000u;
}
inline void BaseLayerProperties::clear_has_is_container_for_fixed_position_layers() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void BaseLayerProperties::clear_is_container_for_fixed_position_layers() {
  is_container_for_fixed_position_layers_ = false;
  clear_has_is_container_for_fixed_position_layers();
}
inline bool BaseLayerProperties::is_container_for_fixed_position_layers() const {
  return is_container_for_fixed_position_layers_;
}
inline void BaseLayerProperties::set_is_container_for_fixed_position_layers(bool value) {
  set_has_is_container_for_fixed_position_layers();
  is_container_for_fixed_position_layers_ = value;
}

// optional .cc.proto.LayerPositionConstraint position_constraint = 27;
inline bool BaseLayerProperties::has_position_constraint() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void BaseLayerProperties::set_has_position_constraint() {
  _has_bits_[0] |= 0x00800000u;
}
inline void BaseLayerProperties::clear_has_position_constraint() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void BaseLayerProperties::clear_position_constraint() {
  if (position_constraint_ != NULL) position_constraint_->::cc::proto::LayerPositionConstraint::Clear();
  clear_has_position_constraint();
}
inline const ::cc::proto::LayerPositionConstraint& BaseLayerProperties::position_constraint() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return position_constraint_ != NULL ? *position_constraint_ : *default_instance().position_constraint_;
#else
  return position_constraint_ != NULL ? *position_constraint_ : *default_instance_->position_constraint_;
#endif
}
inline ::cc::proto::LayerPositionConstraint* BaseLayerProperties::mutable_position_constraint() {
  set_has_position_constraint();
  if (position_constraint_ == NULL) position_constraint_ = new ::cc::proto::LayerPositionConstraint;
  return position_constraint_;
}
inline ::cc::proto::LayerPositionConstraint* BaseLayerProperties::release_position_constraint() {
  clear_has_position_constraint();
  ::cc::proto::LayerPositionConstraint* temp = position_constraint_;
  position_constraint_ = NULL;
  return temp;
}
inline void BaseLayerProperties::set_allocated_position_constraint(::cc::proto::LayerPositionConstraint* position_constraint) {
  delete position_constraint_;
  position_constraint_ = position_constraint;
  if (position_constraint) {
    set_has_position_constraint();
  } else {
    clear_has_position_constraint();
  }
}

// optional bool should_flatten_transform = 28;
inline bool BaseLayerProperties::has_should_flatten_transform() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void BaseLayerProperties::set_has_should_flatten_transform() {
  _has_bits_[0] |= 0x01000000u;
}
inline void BaseLayerProperties::clear_has_should_flatten_transform() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void BaseLayerProperties::clear_should_flatten_transform() {
  should_flatten_transform_ = false;
  clear_has_should_flatten_transform();
}
inline bool BaseLayerProperties::should_flatten_transform() const {
  return should_flatten_transform_;
}
inline void BaseLayerProperties::set_should_flatten_transform(bool value) {
  set_has_should_flatten_transform();
  should_flatten_transform_ = value;
}

// optional bool should_flatten_transform_from_property_tree = 29;
inline bool BaseLayerProperties::has_should_flatten_transform_from_property_tree() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void BaseLayerProperties::set_has_should_flatten_transform_from_property_tree() {
  _has_bits_[0] |= 0x02000000u;
}
inline void BaseLayerProperties::clear_has_should_flatten_transform_from_property_tree() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void BaseLayerProperties::clear_should_flatten_transform_from_property_tree() {
  should_flatten_transform_from_property_tree_ = false;
  clear_has_should_flatten_transform_from_property_tree();
}
inline bool BaseLayerProperties::should_flatten_transform_from_property_tree() const {
  return should_flatten_transform_from_property_tree_;
}
inline void BaseLayerProperties::set_should_flatten_transform_from_property_tree(bool value) {
  set_has_should_flatten_transform_from_property_tree();
  should_flatten_transform_from_property_tree_ = value;
}

// optional int32 num_layer_or_descendants_with_copy_request = 30;
inline bool BaseLayerProperties::has_num_layer_or_descendants_with_copy_request() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void BaseLayerProperties::set_has_num_layer_or_descendants_with_copy_request() {
  _has_bits_[0] |= 0x04000000u;
}
inline void BaseLayerProperties::clear_has_num_layer_or_descendants_with_copy_request() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void BaseLayerProperties::clear_num_layer_or_descendants_with_copy_request() {
  num_layer_or_descendants_with_copy_request_ = 0;
  clear_has_num_layer_or_descendants_with_copy_request();
}
inline ::google::protobuf::int32 BaseLayerProperties::num_layer_or_descendants_with_copy_request() const {
  return num_layer_or_descendants_with_copy_request_;
}
inline void BaseLayerProperties::set_num_layer_or_descendants_with_copy_request(::google::protobuf::int32 value) {
  set_has_num_layer_or_descendants_with_copy_request();
  num_layer_or_descendants_with_copy_request_ = value;
}

// optional .cc.proto.SkXfermode.Mode draw_blend_mode = 31;
inline bool BaseLayerProperties::has_draw_blend_mode() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void BaseLayerProperties::set_has_draw_blend_mode() {
  _has_bits_[0] |= 0x08000000u;
}
inline void BaseLayerProperties::clear_has_draw_blend_mode() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void BaseLayerProperties::clear_draw_blend_mode() {
  draw_blend_mode_ = 0;
  clear_has_draw_blend_mode();
}
inline ::cc::proto::SkXfermode_Mode BaseLayerProperties::draw_blend_mode() const {
  return static_cast< ::cc::proto::SkXfermode_Mode >(draw_blend_mode_);
}
inline void BaseLayerProperties::set_draw_blend_mode(::cc::proto::SkXfermode_Mode value) {
  assert(::cc::proto::SkXfermode_Mode_IsValid(value));
  set_has_draw_blend_mode();
  draw_blend_mode_ = value;
}

// optional bool use_parent_backface_visibility = 32;
inline bool BaseLayerProperties::has_use_parent_backface_visibility() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void BaseLayerProperties::set_has_use_parent_backface_visibility() {
  _has_bits_[0] |= 0x10000000u;
}
inline void BaseLayerProperties::clear_has_use_parent_backface_visibility() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void BaseLayerProperties::clear_use_parent_backface_visibility() {
  use_parent_backface_visibility_ = false;
  clear_has_use_parent_backface_visibility();
}
inline bool BaseLayerProperties::use_parent_backface_visibility() const {
  return use_parent_backface_visibility_;
}
inline void BaseLayerProperties::set_use_parent_backface_visibility(bool value) {
  set_has_use_parent_backface_visibility();
  use_parent_backface_visibility_ = value;
}

// optional .cc.proto.Transform transform = 33;
inline bool BaseLayerProperties::has_transform() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void BaseLayerProperties::set_has_transform() {
  _has_bits_[0] |= 0x20000000u;
}
inline void BaseLayerProperties::clear_has_transform() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void BaseLayerProperties::clear_transform() {
  if (transform_ != NULL) transform_->::cc::proto::Transform::Clear();
  clear_has_transform();
}
inline const ::cc::proto::Transform& BaseLayerProperties::transform() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transform_ != NULL ? *transform_ : *default_instance().transform_;
#else
  return transform_ != NULL ? *transform_ : *default_instance_->transform_;
#endif
}
inline ::cc::proto::Transform* BaseLayerProperties::mutable_transform() {
  set_has_transform();
  if (transform_ == NULL) transform_ = new ::cc::proto::Transform;
  return transform_;
}
inline ::cc::proto::Transform* BaseLayerProperties::release_transform() {
  clear_has_transform();
  ::cc::proto::Transform* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline void BaseLayerProperties::set_allocated_transform(::cc::proto::Transform* transform) {
  delete transform_;
  transform_ = transform;
  if (transform) {
    set_has_transform();
  } else {
    clear_has_transform();
  }
}

// optional bool transform_is_invertible = 34;
inline bool BaseLayerProperties::has_transform_is_invertible() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void BaseLayerProperties::set_has_transform_is_invertible() {
  _has_bits_[0] |= 0x40000000u;
}
inline void BaseLayerProperties::clear_has_transform_is_invertible() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void BaseLayerProperties::clear_transform_is_invertible() {
  transform_is_invertible_ = false;
  clear_has_transform_is_invertible();
}
inline bool BaseLayerProperties::transform_is_invertible() const {
  return transform_is_invertible_;
}
inline void BaseLayerProperties::set_transform_is_invertible(bool value) {
  set_has_transform_is_invertible();
  transform_is_invertible_ = value;
}

// optional int32 sorting_context_id = 35;
inline bool BaseLayerProperties::has_sorting_context_id() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void BaseLayerProperties::set_has_sorting_context_id() {
  _has_bits_[0] |= 0x80000000u;
}
inline void BaseLayerProperties::clear_has_sorting_context_id() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void BaseLayerProperties::clear_sorting_context_id() {
  sorting_context_id_ = 0;
  clear_has_sorting_context_id();
}
inline ::google::protobuf::int32 BaseLayerProperties::sorting_context_id() const {
  return sorting_context_id_;
}
inline void BaseLayerProperties::set_sorting_context_id(::google::protobuf::int32 value) {
  set_has_sorting_context_id();
  sorting_context_id_ = value;
}

// optional int32 num_descendants_that_draw_content = 36;
inline bool BaseLayerProperties::has_num_descendants_that_draw_content() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void BaseLayerProperties::set_has_num_descendants_that_draw_content() {
  _has_bits_[1] |= 0x00000001u;
}
inline void BaseLayerProperties::clear_has_num_descendants_that_draw_content() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void BaseLayerProperties::clear_num_descendants_that_draw_content() {
  num_descendants_that_draw_content_ = 0;
  clear_has_num_descendants_that_draw_content();
}
inline ::google::protobuf::int32 BaseLayerProperties::num_descendants_that_draw_content() const {
  return num_descendants_that_draw_content_;
}
inline void BaseLayerProperties::set_num_descendants_that_draw_content(::google::protobuf::int32 value) {
  set_has_num_descendants_that_draw_content();
  num_descendants_that_draw_content_ = value;
}

// optional int32 scroll_clip_layer_id = 37;
inline bool BaseLayerProperties::has_scroll_clip_layer_id() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void BaseLayerProperties::set_has_scroll_clip_layer_id() {
  _has_bits_[1] |= 0x00000002u;
}
inline void BaseLayerProperties::clear_has_scroll_clip_layer_id() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void BaseLayerProperties::clear_scroll_clip_layer_id() {
  scroll_clip_layer_id_ = 0;
  clear_has_scroll_clip_layer_id();
}
inline ::google::protobuf::int32 BaseLayerProperties::scroll_clip_layer_id() const {
  return scroll_clip_layer_id_;
}
inline void BaseLayerProperties::set_scroll_clip_layer_id(::google::protobuf::int32 value) {
  set_has_scroll_clip_layer_id();
  scroll_clip_layer_id_ = value;
}

// optional bool user_scrollable_horizontal = 38;
inline bool BaseLayerProperties::has_user_scrollable_horizontal() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void BaseLayerProperties::set_has_user_scrollable_horizontal() {
  _has_bits_[1] |= 0x00000004u;
}
inline void BaseLayerProperties::clear_has_user_scrollable_horizontal() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void BaseLayerProperties::clear_user_scrollable_horizontal() {
  user_scrollable_horizontal_ = false;
  clear_has_user_scrollable_horizontal();
}
inline bool BaseLayerProperties::user_scrollable_horizontal() const {
  return user_scrollable_horizontal_;
}
inline void BaseLayerProperties::set_user_scrollable_horizontal(bool value) {
  set_has_user_scrollable_horizontal();
  user_scrollable_horizontal_ = value;
}

// optional bool user_scrollable_vertical = 39;
inline bool BaseLayerProperties::has_user_scrollable_vertical() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void BaseLayerProperties::set_has_user_scrollable_vertical() {
  _has_bits_[1] |= 0x00000008u;
}
inline void BaseLayerProperties::clear_has_user_scrollable_vertical() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void BaseLayerProperties::clear_user_scrollable_vertical() {
  user_scrollable_vertical_ = false;
  clear_has_user_scrollable_vertical();
}
inline bool BaseLayerProperties::user_scrollable_vertical() const {
  return user_scrollable_vertical_;
}
inline void BaseLayerProperties::set_user_scrollable_vertical(bool value) {
  set_has_user_scrollable_vertical();
  user_scrollable_vertical_ = value;
}

// optional int32 scroll_parent_id = 40;
inline bool BaseLayerProperties::has_scroll_parent_id() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void BaseLayerProperties::set_has_scroll_parent_id() {
  _has_bits_[1] |= 0x00000010u;
}
inline void BaseLayerProperties::clear_has_scroll_parent_id() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void BaseLayerProperties::clear_scroll_parent_id() {
  scroll_parent_id_ = 0;
  clear_has_scroll_parent_id();
}
inline ::google::protobuf::int32 BaseLayerProperties::scroll_parent_id() const {
  return scroll_parent_id_;
}
inline void BaseLayerProperties::set_scroll_parent_id(::google::protobuf::int32 value) {
  set_has_scroll_parent_id();
  scroll_parent_id_ = value;
}

// repeated int32 scroll_children_ids = 41;
inline int BaseLayerProperties::scroll_children_ids_size() const {
  return scroll_children_ids_.size();
}
inline void BaseLayerProperties::clear_scroll_children_ids() {
  scroll_children_ids_.Clear();
}
inline ::google::protobuf::int32 BaseLayerProperties::scroll_children_ids(int index) const {
  return scroll_children_ids_.Get(index);
}
inline void BaseLayerProperties::set_scroll_children_ids(int index, ::google::protobuf::int32 value) {
  scroll_children_ids_.Set(index, value);
}
inline void BaseLayerProperties::add_scroll_children_ids(::google::protobuf::int32 value) {
  scroll_children_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BaseLayerProperties::scroll_children_ids() const {
  return scroll_children_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BaseLayerProperties::mutable_scroll_children_ids() {
  return &scroll_children_ids_;
}

// optional int32 clip_parent_id = 42;
inline bool BaseLayerProperties::has_clip_parent_id() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void BaseLayerProperties::set_has_clip_parent_id() {
  _has_bits_[1] |= 0x00000040u;
}
inline void BaseLayerProperties::clear_has_clip_parent_id() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void BaseLayerProperties::clear_clip_parent_id() {
  clip_parent_id_ = 0;
  clear_has_clip_parent_id();
}
inline ::google::protobuf::int32 BaseLayerProperties::clip_parent_id() const {
  return clip_parent_id_;
}
inline void BaseLayerProperties::set_clip_parent_id(::google::protobuf::int32 value) {
  set_has_clip_parent_id();
  clip_parent_id_ = value;
}

// repeated int32 clip_children_ids = 43;
inline int BaseLayerProperties::clip_children_ids_size() const {
  return clip_children_ids_.size();
}
inline void BaseLayerProperties::clear_clip_children_ids() {
  clip_children_ids_.Clear();
}
inline ::google::protobuf::int32 BaseLayerProperties::clip_children_ids(int index) const {
  return clip_children_ids_.Get(index);
}
inline void BaseLayerProperties::set_clip_children_ids(int index, ::google::protobuf::int32 value) {
  clip_children_ids_.Set(index, value);
}
inline void BaseLayerProperties::add_clip_children_ids(::google::protobuf::int32 value) {
  clip_children_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BaseLayerProperties::clip_children_ids() const {
  return clip_children_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BaseLayerProperties::mutable_clip_children_ids() {
  return &clip_children_ids_;
}

// optional .cc.proto.ScrollOffset scroll_offset = 44;
inline bool BaseLayerProperties::has_scroll_offset() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void BaseLayerProperties::set_has_scroll_offset() {
  _has_bits_[1] |= 0x00000100u;
}
inline void BaseLayerProperties::clear_has_scroll_offset() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void BaseLayerProperties::clear_scroll_offset() {
  if (scroll_offset_ != NULL) scroll_offset_->::cc::proto::ScrollOffset::Clear();
  clear_has_scroll_offset();
}
inline const ::cc::proto::ScrollOffset& BaseLayerProperties::scroll_offset() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scroll_offset_ != NULL ? *scroll_offset_ : *default_instance().scroll_offset_;
#else
  return scroll_offset_ != NULL ? *scroll_offset_ : *default_instance_->scroll_offset_;
#endif
}
inline ::cc::proto::ScrollOffset* BaseLayerProperties::mutable_scroll_offset() {
  set_has_scroll_offset();
  if (scroll_offset_ == NULL) scroll_offset_ = new ::cc::proto::ScrollOffset;
  return scroll_offset_;
}
inline ::cc::proto::ScrollOffset* BaseLayerProperties::release_scroll_offset() {
  clear_has_scroll_offset();
  ::cc::proto::ScrollOffset* temp = scroll_offset_;
  scroll_offset_ = NULL;
  return temp;
}
inline void BaseLayerProperties::set_allocated_scroll_offset(::cc::proto::ScrollOffset* scroll_offset) {
  delete scroll_offset_;
  scroll_offset_ = scroll_offset;
  if (scroll_offset) {
    set_has_scroll_offset();
  } else {
    clear_has_scroll_offset();
  }
}

// optional .cc.proto.Vector2dF scroll_compensation_adjustment = 45;
inline bool BaseLayerProperties::has_scroll_compensation_adjustment() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void BaseLayerProperties::set_has_scroll_compensation_adjustment() {
  _has_bits_[1] |= 0x00000200u;
}
inline void BaseLayerProperties::clear_has_scroll_compensation_adjustment() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void BaseLayerProperties::clear_scroll_compensation_adjustment() {
  if (scroll_compensation_adjustment_ != NULL) scroll_compensation_adjustment_->::cc::proto::Vector2dF::Clear();
  clear_has_scroll_compensation_adjustment();
}
inline const ::cc::proto::Vector2dF& BaseLayerProperties::scroll_compensation_adjustment() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scroll_compensation_adjustment_ != NULL ? *scroll_compensation_adjustment_ : *default_instance().scroll_compensation_adjustment_;
#else
  return scroll_compensation_adjustment_ != NULL ? *scroll_compensation_adjustment_ : *default_instance_->scroll_compensation_adjustment_;
#endif
}
inline ::cc::proto::Vector2dF* BaseLayerProperties::mutable_scroll_compensation_adjustment() {
  set_has_scroll_compensation_adjustment();
  if (scroll_compensation_adjustment_ == NULL) scroll_compensation_adjustment_ = new ::cc::proto::Vector2dF;
  return scroll_compensation_adjustment_;
}
inline ::cc::proto::Vector2dF* BaseLayerProperties::release_scroll_compensation_adjustment() {
  clear_has_scroll_compensation_adjustment();
  ::cc::proto::Vector2dF* temp = scroll_compensation_adjustment_;
  scroll_compensation_adjustment_ = NULL;
  return temp;
}
inline void BaseLayerProperties::set_allocated_scroll_compensation_adjustment(::cc::proto::Vector2dF* scroll_compensation_adjustment) {
  delete scroll_compensation_adjustment_;
  scroll_compensation_adjustment_ = scroll_compensation_adjustment;
  if (scroll_compensation_adjustment) {
    set_has_scroll_compensation_adjustment();
  } else {
    clear_has_scroll_compensation_adjustment();
  }
}

// optional .cc.proto.Rect update_rect = 46;
inline bool BaseLayerProperties::has_update_rect() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void BaseLayerProperties::set_has_update_rect() {
  _has_bits_[1] |= 0x00000400u;
}
inline void BaseLayerProperties::clear_has_update_rect() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void BaseLayerProperties::clear_update_rect() {
  if (update_rect_ != NULL) update_rect_->::cc::proto::Rect::Clear();
  clear_has_update_rect();
}
inline const ::cc::proto::Rect& BaseLayerProperties::update_rect() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return update_rect_ != NULL ? *update_rect_ : *default_instance().update_rect_;
#else
  return update_rect_ != NULL ? *update_rect_ : *default_instance_->update_rect_;
#endif
}
inline ::cc::proto::Rect* BaseLayerProperties::mutable_update_rect() {
  set_has_update_rect();
  if (update_rect_ == NULL) update_rect_ = new ::cc::proto::Rect;
  return update_rect_;
}
inline ::cc::proto::Rect* BaseLayerProperties::release_update_rect() {
  clear_has_update_rect();
  ::cc::proto::Rect* temp = update_rect_;
  update_rect_ = NULL;
  return temp;
}
inline void BaseLayerProperties::set_allocated_update_rect(::cc::proto::Rect* update_rect) {
  delete update_rect_;
  update_rect_ = update_rect;
  if (update_rect) {
    set_has_update_rect();
  } else {
    clear_has_update_rect();
  }
}

// optional bool stacking_order_changed = 47;
inline bool BaseLayerProperties::has_stacking_order_changed() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void BaseLayerProperties::set_has_stacking_order_changed() {
  _has_bits_[1] |= 0x00000800u;
}
inline void BaseLayerProperties::clear_has_stacking_order_changed() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void BaseLayerProperties::clear_stacking_order_changed() {
  stacking_order_changed_ = false;
  clear_has_stacking_order_changed();
}
inline bool BaseLayerProperties::stacking_order_changed() const {
  return stacking_order_changed_;
}
inline void BaseLayerProperties::set_stacking_order_changed(bool value) {
  set_has_stacking_order_changed();
  stacking_order_changed_ = value;
}

// -------------------------------------------------------------------

// PictureLayerProperties

// optional .cc.proto.DisplayListRecordingSource recording_source = 1;
inline bool PictureLayerProperties::has_recording_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PictureLayerProperties::set_has_recording_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PictureLayerProperties::clear_has_recording_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PictureLayerProperties::clear_recording_source() {
  if (recording_source_ != NULL) recording_source_->::cc::proto::DisplayListRecordingSource::Clear();
  clear_has_recording_source();
}
inline const ::cc::proto::DisplayListRecordingSource& PictureLayerProperties::recording_source() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return recording_source_ != NULL ? *recording_source_ : *default_instance().recording_source_;
#else
  return recording_source_ != NULL ? *recording_source_ : *default_instance_->recording_source_;
#endif
}
inline ::cc::proto::DisplayListRecordingSource* PictureLayerProperties::mutable_recording_source() {
  set_has_recording_source();
  if (recording_source_ == NULL) recording_source_ = new ::cc::proto::DisplayListRecordingSource;
  return recording_source_;
}
inline ::cc::proto::DisplayListRecordingSource* PictureLayerProperties::release_recording_source() {
  clear_has_recording_source();
  ::cc::proto::DisplayListRecordingSource* temp = recording_source_;
  recording_source_ = NULL;
  return temp;
}
inline void PictureLayerProperties::set_allocated_recording_source(::cc::proto::DisplayListRecordingSource* recording_source) {
  delete recording_source_;
  recording_source_ = recording_source;
  if (recording_source) {
    set_has_recording_source();
  } else {
    clear_has_recording_source();
  }
}

// optional .cc.proto.Region invalidation = 2;
inline bool PictureLayerProperties::has_invalidation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PictureLayerProperties::set_has_invalidation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PictureLayerProperties::clear_has_invalidation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PictureLayerProperties::clear_invalidation() {
  if (invalidation_ != NULL) invalidation_->::cc::proto::Region::Clear();
  clear_has_invalidation();
}
inline const ::cc::proto::Region& PictureLayerProperties::invalidation() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return invalidation_ != NULL ? *invalidation_ : *default_instance().invalidation_;
#else
  return invalidation_ != NULL ? *invalidation_ : *default_instance_->invalidation_;
#endif
}
inline ::cc::proto::Region* PictureLayerProperties::mutable_invalidation() {
  set_has_invalidation();
  if (invalidation_ == NULL) invalidation_ = new ::cc::proto::Region;
  return invalidation_;
}
inline ::cc::proto::Region* PictureLayerProperties::release_invalidation() {
  clear_has_invalidation();
  ::cc::proto::Region* temp = invalidation_;
  invalidation_ = NULL;
  return temp;
}
inline void PictureLayerProperties::set_allocated_invalidation(::cc::proto::Region* invalidation) {
  delete invalidation_;
  invalidation_ = invalidation;
  if (invalidation) {
    set_has_invalidation();
  } else {
    clear_has_invalidation();
  }
}

// optional .cc.proto.Rect last_updated_visible_layer_rect = 3;
inline bool PictureLayerProperties::has_last_updated_visible_layer_rect() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PictureLayerProperties::set_has_last_updated_visible_layer_rect() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PictureLayerProperties::clear_has_last_updated_visible_layer_rect() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PictureLayerProperties::clear_last_updated_visible_layer_rect() {
  if (last_updated_visible_layer_rect_ != NULL) last_updated_visible_layer_rect_->::cc::proto::Rect::Clear();
  clear_has_last_updated_visible_layer_rect();
}
inline const ::cc::proto::Rect& PictureLayerProperties::last_updated_visible_layer_rect() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return last_updated_visible_layer_rect_ != NULL ? *last_updated_visible_layer_rect_ : *default_instance().last_updated_visible_layer_rect_;
#else
  return last_updated_visible_layer_rect_ != NULL ? *last_updated_visible_layer_rect_ : *default_instance_->last_updated_visible_layer_rect_;
#endif
}
inline ::cc::proto::Rect* PictureLayerProperties::mutable_last_updated_visible_layer_rect() {
  set_has_last_updated_visible_layer_rect();
  if (last_updated_visible_layer_rect_ == NULL) last_updated_visible_layer_rect_ = new ::cc::proto::Rect;
  return last_updated_visible_layer_rect_;
}
inline ::cc::proto::Rect* PictureLayerProperties::release_last_updated_visible_layer_rect() {
  clear_has_last_updated_visible_layer_rect();
  ::cc::proto::Rect* temp = last_updated_visible_layer_rect_;
  last_updated_visible_layer_rect_ = NULL;
  return temp;
}
inline void PictureLayerProperties::set_allocated_last_updated_visible_layer_rect(::cc::proto::Rect* last_updated_visible_layer_rect) {
  delete last_updated_visible_layer_rect_;
  last_updated_visible_layer_rect_ = last_updated_visible_layer_rect;
  if (last_updated_visible_layer_rect) {
    set_has_last_updated_visible_layer_rect();
  } else {
    clear_has_last_updated_visible_layer_rect();
  }
}

// optional bool is_mask = 4;
inline bool PictureLayerProperties::has_is_mask() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PictureLayerProperties::set_has_is_mask() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PictureLayerProperties::clear_has_is_mask() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PictureLayerProperties::clear_is_mask() {
  is_mask_ = false;
  clear_has_is_mask();
}
inline bool PictureLayerProperties::is_mask() const {
  return is_mask_;
}
inline void PictureLayerProperties::set_is_mask(bool value) {
  set_has_is_mask();
  is_mask_ = value;
}

// optional bool nearest_neighbor = 5;
inline bool PictureLayerProperties::has_nearest_neighbor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PictureLayerProperties::set_has_nearest_neighbor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PictureLayerProperties::clear_has_nearest_neighbor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PictureLayerProperties::clear_nearest_neighbor() {
  nearest_neighbor_ = false;
  clear_has_nearest_neighbor();
}
inline bool PictureLayerProperties::nearest_neighbor() const {
  return nearest_neighbor_;
}
inline void PictureLayerProperties::set_nearest_neighbor(bool value) {
  set_has_nearest_neighbor();
  nearest_neighbor_ = value;
}

// optional int64 update_source_frame_number = 6;
inline bool PictureLayerProperties::has_update_source_frame_number() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PictureLayerProperties::set_has_update_source_frame_number() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PictureLayerProperties::clear_has_update_source_frame_number() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PictureLayerProperties::clear_update_source_frame_number() {
  update_source_frame_number_ = GOOGLE_LONGLONG(0);
  clear_has_update_source_frame_number();
}
inline ::google::protobuf::int64 PictureLayerProperties::update_source_frame_number() const {
  return update_source_frame_number_;
}
inline void PictureLayerProperties::set_update_source_frame_number(::google::protobuf::int64 value) {
  set_has_update_source_frame_number();
  update_source_frame_number_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_layer_2eproto__INCLUDED
