// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: display_item.proto

#ifndef PROTOBUF_display_5fitem_2eproto__INCLUDED
#define PROTOBUF_display_5fitem_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "skregion.pb.h"
#include "skrrect.pb.h"
#include "skxfermode.pb.h"
#include "rect.pb.h"
#include "rectf.pb.h"
#include "transform.pb.h"
// @@protoc_insertion_point(includes)
#include "cc/proto/cc_proto_export.h"

namespace cc {
namespace proto {

// Internal implementation detail -- do not call these.
void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
void protobuf_AssignDesc_display_5fitem_2eproto();
void protobuf_ShutdownFile_display_5fitem_2eproto();

class DisplayItemListSettings;
class DisplayItemList;
class DisplayItem;
class ClipDisplayItem;
class ClipPathDisplayItem;
class CompositingDisplayItem;
class DrawingDisplayItem;
class FilterDisplayItem;
class FloatClipDisplayItem;
class TransformDisplayItem;

enum DisplayItem_Type {
  DisplayItem_Type_Type_Clip = 1,
  DisplayItem_Type_Type_EndClip = 2,
  DisplayItem_Type_Type_ClipPath = 3,
  DisplayItem_Type_Type_EndClipPath = 4,
  DisplayItem_Type_Type_Compositing = 5,
  DisplayItem_Type_Type_EndCompositing = 6,
  DisplayItem_Type_Type_Drawing = 7,
  DisplayItem_Type_Type_Filter = 8,
  DisplayItem_Type_Type_EndFilter = 9,
  DisplayItem_Type_Type_FloatClip = 10,
  DisplayItem_Type_Type_EndFloatClip = 11,
  DisplayItem_Type_Type_Transform = 12,
  DisplayItem_Type_Type_EndTransform = 13
};
CC_PROTO_EXPORT bool DisplayItem_Type_IsValid(int value);
const DisplayItem_Type DisplayItem_Type_Type_MIN = DisplayItem_Type_Type_Clip;
const DisplayItem_Type DisplayItem_Type_Type_MAX = DisplayItem_Type_Type_EndTransform;
const int DisplayItem_Type_Type_ARRAYSIZE = DisplayItem_Type_Type_MAX + 1;

// ===================================================================

class CC_PROTO_EXPORT DisplayItemListSettings : public ::google::protobuf::MessageLite {
 public:
  DisplayItemListSettings();
  virtual ~DisplayItemListSettings();

  DisplayItemListSettings(const DisplayItemListSettings& from);

  inline DisplayItemListSettings& operator=(const DisplayItemListSettings& from) {
    CopyFrom(from);
    return *this;
  }

  static const DisplayItemListSettings& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DisplayItemListSettings* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DisplayItemListSettings* other);

  // implements Message ----------------------------------------------

  DisplayItemListSettings* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DisplayItemListSettings& from);
  void MergeFrom(const DisplayItemListSettings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool use_cached_picture = 1;
  inline bool has_use_cached_picture() const;
  inline void clear_use_cached_picture();
  static const int kUseCachedPictureFieldNumber = 1;
  inline bool use_cached_picture() const;
  inline void set_use_cached_picture(bool value);

  // @@protoc_insertion_point(class_scope:cc.proto.DisplayItemListSettings)
 private:
  inline void set_has_use_cached_picture();
  inline void clear_has_use_cached_picture();

  bool use_cached_picture_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
  #endif
  friend void protobuf_AssignDesc_display_5fitem_2eproto();
  friend void protobuf_ShutdownFile_display_5fitem_2eproto();

  void InitAsDefaultInstance();
  static DisplayItemListSettings* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT DisplayItemList : public ::google::protobuf::MessageLite {
 public:
  DisplayItemList();
  virtual ~DisplayItemList();

  DisplayItemList(const DisplayItemList& from);

  inline DisplayItemList& operator=(const DisplayItemList& from) {
    CopyFrom(from);
    return *this;
  }

  static const DisplayItemList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DisplayItemList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DisplayItemList* other);

  // implements Message ----------------------------------------------

  DisplayItemList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DisplayItemList& from);
  void MergeFrom(const DisplayItemList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cc.proto.DisplayItem items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::cc::proto::DisplayItem& items(int index) const;
  inline ::cc::proto::DisplayItem* mutable_items(int index);
  inline ::cc::proto::DisplayItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::cc::proto::DisplayItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::cc::proto::DisplayItem >*
      mutable_items();

  // optional .cc.proto.Rect layer_rect = 2;
  inline bool has_layer_rect() const;
  inline void clear_layer_rect();
  static const int kLayerRectFieldNumber = 2;
  inline const ::cc::proto::Rect& layer_rect() const;
  inline ::cc::proto::Rect* mutable_layer_rect();
  inline ::cc::proto::Rect* release_layer_rect();
  inline void set_allocated_layer_rect(::cc::proto::Rect* layer_rect);

  // optional .cc.proto.DisplayItemListSettings settings = 3;
  inline bool has_settings() const;
  inline void clear_settings();
  static const int kSettingsFieldNumber = 3;
  inline const ::cc::proto::DisplayItemListSettings& settings() const;
  inline ::cc::proto::DisplayItemListSettings* mutable_settings();
  inline ::cc::proto::DisplayItemListSettings* release_settings();
  inline void set_allocated_settings(::cc::proto::DisplayItemListSettings* settings);

  // @@protoc_insertion_point(class_scope:cc.proto.DisplayItemList)
 private:
  inline void set_has_layer_rect();
  inline void clear_has_layer_rect();
  inline void set_has_settings();
  inline void clear_has_settings();

  ::google::protobuf::RepeatedPtrField< ::cc::proto::DisplayItem > items_;
  ::cc::proto::Rect* layer_rect_;
  ::cc::proto::DisplayItemListSettings* settings_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
  #endif
  friend void protobuf_AssignDesc_display_5fitem_2eproto();
  friend void protobuf_ShutdownFile_display_5fitem_2eproto();

  void InitAsDefaultInstance();
  static DisplayItemList* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT DisplayItem : public ::google::protobuf::MessageLite {
 public:
  DisplayItem();
  virtual ~DisplayItem();

  DisplayItem(const DisplayItem& from);

  inline DisplayItem& operator=(const DisplayItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const DisplayItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DisplayItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DisplayItem* other);

  // implements Message ----------------------------------------------

  DisplayItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DisplayItem& from);
  void MergeFrom(const DisplayItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef DisplayItem_Type Type;
  static const Type Type_Clip = DisplayItem_Type_Type_Clip;
  static const Type Type_EndClip = DisplayItem_Type_Type_EndClip;
  static const Type Type_ClipPath = DisplayItem_Type_Type_ClipPath;
  static const Type Type_EndClipPath = DisplayItem_Type_Type_EndClipPath;
  static const Type Type_Compositing = DisplayItem_Type_Type_Compositing;
  static const Type Type_EndCompositing = DisplayItem_Type_Type_EndCompositing;
  static const Type Type_Drawing = DisplayItem_Type_Type_Drawing;
  static const Type Type_Filter = DisplayItem_Type_Type_Filter;
  static const Type Type_EndFilter = DisplayItem_Type_Type_EndFilter;
  static const Type Type_FloatClip = DisplayItem_Type_Type_FloatClip;
  static const Type Type_EndFloatClip = DisplayItem_Type_Type_EndFloatClip;
  static const Type Type_Transform = DisplayItem_Type_Type_Transform;
  static const Type Type_EndTransform = DisplayItem_Type_Type_EndTransform;
  static inline bool Type_IsValid(int value) {
    return DisplayItem_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DisplayItem_Type_Type_MIN;
  static const Type Type_MAX =
    DisplayItem_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DisplayItem_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .cc.proto.DisplayItem.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::cc::proto::DisplayItem_Type type() const;
  inline void set_type(::cc::proto::DisplayItem_Type value);

  // optional .cc.proto.ClipDisplayItem clip_item = 1000;
  inline bool has_clip_item() const;
  inline void clear_clip_item();
  static const int kClipItemFieldNumber = 1000;
  inline const ::cc::proto::ClipDisplayItem& clip_item() const;
  inline ::cc::proto::ClipDisplayItem* mutable_clip_item();
  inline ::cc::proto::ClipDisplayItem* release_clip_item();
  inline void set_allocated_clip_item(::cc::proto::ClipDisplayItem* clip_item);

  // optional .cc.proto.ClipPathDisplayItem clip_path_item = 1001;
  inline bool has_clip_path_item() const;
  inline void clear_clip_path_item();
  static const int kClipPathItemFieldNumber = 1001;
  inline const ::cc::proto::ClipPathDisplayItem& clip_path_item() const;
  inline ::cc::proto::ClipPathDisplayItem* mutable_clip_path_item();
  inline ::cc::proto::ClipPathDisplayItem* release_clip_path_item();
  inline void set_allocated_clip_path_item(::cc::proto::ClipPathDisplayItem* clip_path_item);

  // optional .cc.proto.CompositingDisplayItem compositing_item = 1002;
  inline bool has_compositing_item() const;
  inline void clear_compositing_item();
  static const int kCompositingItemFieldNumber = 1002;
  inline const ::cc::proto::CompositingDisplayItem& compositing_item() const;
  inline ::cc::proto::CompositingDisplayItem* mutable_compositing_item();
  inline ::cc::proto::CompositingDisplayItem* release_compositing_item();
  inline void set_allocated_compositing_item(::cc::proto::CompositingDisplayItem* compositing_item);

  // optional .cc.proto.DrawingDisplayItem drawing_item = 1003;
  inline bool has_drawing_item() const;
  inline void clear_drawing_item();
  static const int kDrawingItemFieldNumber = 1003;
  inline const ::cc::proto::DrawingDisplayItem& drawing_item() const;
  inline ::cc::proto::DrawingDisplayItem* mutable_drawing_item();
  inline ::cc::proto::DrawingDisplayItem* release_drawing_item();
  inline void set_allocated_drawing_item(::cc::proto::DrawingDisplayItem* drawing_item);

  // optional .cc.proto.FilterDisplayItem filter_item = 1004;
  inline bool has_filter_item() const;
  inline void clear_filter_item();
  static const int kFilterItemFieldNumber = 1004;
  inline const ::cc::proto::FilterDisplayItem& filter_item() const;
  inline ::cc::proto::FilterDisplayItem* mutable_filter_item();
  inline ::cc::proto::FilterDisplayItem* release_filter_item();
  inline void set_allocated_filter_item(::cc::proto::FilterDisplayItem* filter_item);

  // optional .cc.proto.FloatClipDisplayItem float_clip_item = 1005;
  inline bool has_float_clip_item() const;
  inline void clear_float_clip_item();
  static const int kFloatClipItemFieldNumber = 1005;
  inline const ::cc::proto::FloatClipDisplayItem& float_clip_item() const;
  inline ::cc::proto::FloatClipDisplayItem* mutable_float_clip_item();
  inline ::cc::proto::FloatClipDisplayItem* release_float_clip_item();
  inline void set_allocated_float_clip_item(::cc::proto::FloatClipDisplayItem* float_clip_item);

  // optional .cc.proto.TransformDisplayItem transform_item = 1006;
  inline bool has_transform_item() const;
  inline void clear_transform_item();
  static const int kTransformItemFieldNumber = 1006;
  inline const ::cc::proto::TransformDisplayItem& transform_item() const;
  inline ::cc::proto::TransformDisplayItem* mutable_transform_item();
  inline ::cc::proto::TransformDisplayItem* release_transform_item();
  inline void set_allocated_transform_item(::cc::proto::TransformDisplayItem* transform_item);

  // @@protoc_insertion_point(class_scope:cc.proto.DisplayItem)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_clip_item();
  inline void clear_has_clip_item();
  inline void set_has_clip_path_item();
  inline void clear_has_clip_path_item();
  inline void set_has_compositing_item();
  inline void clear_has_compositing_item();
  inline void set_has_drawing_item();
  inline void clear_has_drawing_item();
  inline void set_has_filter_item();
  inline void clear_has_filter_item();
  inline void set_has_float_clip_item();
  inline void clear_has_float_clip_item();
  inline void set_has_transform_item();
  inline void clear_has_transform_item();

  ::cc::proto::ClipDisplayItem* clip_item_;
  ::cc::proto::ClipPathDisplayItem* clip_path_item_;
  ::cc::proto::CompositingDisplayItem* compositing_item_;
  ::cc::proto::DrawingDisplayItem* drawing_item_;
  ::cc::proto::FilterDisplayItem* filter_item_;
  ::cc::proto::FloatClipDisplayItem* float_clip_item_;
  ::cc::proto::TransformDisplayItem* transform_item_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
  #endif
  friend void protobuf_AssignDesc_display_5fitem_2eproto();
  friend void protobuf_ShutdownFile_display_5fitem_2eproto();

  void InitAsDefaultInstance();
  static DisplayItem* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT ClipDisplayItem : public ::google::protobuf::MessageLite {
 public:
  ClipDisplayItem();
  virtual ~ClipDisplayItem();

  ClipDisplayItem(const ClipDisplayItem& from);

  inline ClipDisplayItem& operator=(const ClipDisplayItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClipDisplayItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClipDisplayItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClipDisplayItem* other);

  // implements Message ----------------------------------------------

  ClipDisplayItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClipDisplayItem& from);
  void MergeFrom(const ClipDisplayItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cc.proto.Rect clip_rect = 1;
  inline bool has_clip_rect() const;
  inline void clear_clip_rect();
  static const int kClipRectFieldNumber = 1;
  inline const ::cc::proto::Rect& clip_rect() const;
  inline ::cc::proto::Rect* mutable_clip_rect();
  inline ::cc::proto::Rect* release_clip_rect();
  inline void set_allocated_clip_rect(::cc::proto::Rect* clip_rect);

  // repeated .cc.proto.SkRRect rounded_rects = 2;
  inline int rounded_rects_size() const;
  inline void clear_rounded_rects();
  static const int kRoundedRectsFieldNumber = 2;
  inline const ::cc::proto::SkRRect& rounded_rects(int index) const;
  inline ::cc::proto::SkRRect* mutable_rounded_rects(int index);
  inline ::cc::proto::SkRRect* add_rounded_rects();
  inline const ::google::protobuf::RepeatedPtrField< ::cc::proto::SkRRect >&
      rounded_rects() const;
  inline ::google::protobuf::RepeatedPtrField< ::cc::proto::SkRRect >*
      mutable_rounded_rects();

  // @@protoc_insertion_point(class_scope:cc.proto.ClipDisplayItem)
 private:
  inline void set_has_clip_rect();
  inline void clear_has_clip_rect();

  ::cc::proto::Rect* clip_rect_;
  ::google::protobuf::RepeatedPtrField< ::cc::proto::SkRRect > rounded_rects_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
  #endif
  friend void protobuf_AssignDesc_display_5fitem_2eproto();
  friend void protobuf_ShutdownFile_display_5fitem_2eproto();

  void InitAsDefaultInstance();
  static ClipDisplayItem* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT ClipPathDisplayItem : public ::google::protobuf::MessageLite {
 public:
  ClipPathDisplayItem();
  virtual ~ClipPathDisplayItem();

  ClipPathDisplayItem(const ClipPathDisplayItem& from);

  inline ClipPathDisplayItem& operator=(const ClipPathDisplayItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClipPathDisplayItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClipPathDisplayItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClipPathDisplayItem* other);

  // implements Message ----------------------------------------------

  ClipPathDisplayItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClipPathDisplayItem& from);
  void MergeFrom(const ClipPathDisplayItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cc.proto.SkRegion.Op clip_op = 1;
  inline bool has_clip_op() const;
  inline void clear_clip_op();
  static const int kClipOpFieldNumber = 1;
  inline ::cc::proto::SkRegion_Op clip_op() const;
  inline void set_clip_op(::cc::proto::SkRegion_Op value);

  // optional bool antialias = 2;
  inline bool has_antialias() const;
  inline void clear_antialias();
  static const int kAntialiasFieldNumber = 2;
  inline bool antialias() const;
  inline void set_antialias(bool value);

  // optional bytes clip_path = 3;
  inline bool has_clip_path() const;
  inline void clear_clip_path();
  static const int kClipPathFieldNumber = 3;
  inline const ::std::string& clip_path() const;
  inline void set_clip_path(const ::std::string& value);
  inline void set_clip_path(const char* value);
  inline void set_clip_path(const void* value, size_t size);
  inline ::std::string* mutable_clip_path();
  inline ::std::string* release_clip_path();
  inline void set_allocated_clip_path(::std::string* clip_path);

  // @@protoc_insertion_point(class_scope:cc.proto.ClipPathDisplayItem)
 private:
  inline void set_has_clip_op();
  inline void clear_has_clip_op();
  inline void set_has_antialias();
  inline void clear_has_antialias();
  inline void set_has_clip_path();
  inline void clear_has_clip_path();

  int clip_op_;
  bool antialias_;
  ::std::string* clip_path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
  #endif
  friend void protobuf_AssignDesc_display_5fitem_2eproto();
  friend void protobuf_ShutdownFile_display_5fitem_2eproto();

  void InitAsDefaultInstance();
  static ClipPathDisplayItem* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT CompositingDisplayItem : public ::google::protobuf::MessageLite {
 public:
  CompositingDisplayItem();
  virtual ~CompositingDisplayItem();

  CompositingDisplayItem(const CompositingDisplayItem& from);

  inline CompositingDisplayItem& operator=(const CompositingDisplayItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const CompositingDisplayItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CompositingDisplayItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CompositingDisplayItem* other);

  // implements Message ----------------------------------------------

  CompositingDisplayItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CompositingDisplayItem& from);
  void MergeFrom(const CompositingDisplayItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 alpha = 1;
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  inline ::google::protobuf::uint32 alpha() const;
  inline void set_alpha(::google::protobuf::uint32 value);

  // optional .cc.proto.SkXfermode.Mode mode = 2;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 2;
  inline ::cc::proto::SkXfermode_Mode mode() const;
  inline void set_mode(::cc::proto::SkXfermode_Mode value);

  // optional .cc.proto.RectF bounds = 3;
  inline bool has_bounds() const;
  inline void clear_bounds();
  static const int kBoundsFieldNumber = 3;
  inline const ::cc::proto::RectF& bounds() const;
  inline ::cc::proto::RectF* mutable_bounds();
  inline ::cc::proto::RectF* release_bounds();
  inline void set_allocated_bounds(::cc::proto::RectF* bounds);

  // optional bytes color_filter = 4;
  inline bool has_color_filter() const;
  inline void clear_color_filter();
  static const int kColorFilterFieldNumber = 4;
  inline const ::std::string& color_filter() const;
  inline void set_color_filter(const ::std::string& value);
  inline void set_color_filter(const char* value);
  inline void set_color_filter(const void* value, size_t size);
  inline ::std::string* mutable_color_filter();
  inline ::std::string* release_color_filter();
  inline void set_allocated_color_filter(::std::string* color_filter);

  // optional bool lcd_text_requires_opaque_layer = 5;
  inline bool has_lcd_text_requires_opaque_layer() const;
  inline void clear_lcd_text_requires_opaque_layer();
  static const int kLcdTextRequiresOpaqueLayerFieldNumber = 5;
  inline bool lcd_text_requires_opaque_layer() const;
  inline void set_lcd_text_requires_opaque_layer(bool value);

  // @@protoc_insertion_point(class_scope:cc.proto.CompositingDisplayItem)
 private:
  inline void set_has_alpha();
  inline void clear_has_alpha();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_bounds();
  inline void clear_has_bounds();
  inline void set_has_color_filter();
  inline void clear_has_color_filter();
  inline void set_has_lcd_text_requires_opaque_layer();
  inline void clear_has_lcd_text_requires_opaque_layer();

  ::google::protobuf::uint32 alpha_;
  int mode_;
  ::cc::proto::RectF* bounds_;
  ::std::string* color_filter_;
  bool lcd_text_requires_opaque_layer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
  #endif
  friend void protobuf_AssignDesc_display_5fitem_2eproto();
  friend void protobuf_ShutdownFile_display_5fitem_2eproto();

  void InitAsDefaultInstance();
  static CompositingDisplayItem* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT DrawingDisplayItem : public ::google::protobuf::MessageLite {
 public:
  DrawingDisplayItem();
  virtual ~DrawingDisplayItem();

  DrawingDisplayItem(const DrawingDisplayItem& from);

  inline DrawingDisplayItem& operator=(const DrawingDisplayItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const DrawingDisplayItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DrawingDisplayItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DrawingDisplayItem* other);

  // implements Message ----------------------------------------------

  DrawingDisplayItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DrawingDisplayItem& from);
  void MergeFrom(const DrawingDisplayItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes picture = 1;
  inline bool has_picture() const;
  inline void clear_picture();
  static const int kPictureFieldNumber = 1;
  inline const ::std::string& picture() const;
  inline void set_picture(const ::std::string& value);
  inline void set_picture(const char* value);
  inline void set_picture(const void* value, size_t size);
  inline ::std::string* mutable_picture();
  inline ::std::string* release_picture();
  inline void set_allocated_picture(::std::string* picture);

  // @@protoc_insertion_point(class_scope:cc.proto.DrawingDisplayItem)
 private:
  inline void set_has_picture();
  inline void clear_has_picture();

  ::std::string* picture_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
  #endif
  friend void protobuf_AssignDesc_display_5fitem_2eproto();
  friend void protobuf_ShutdownFile_display_5fitem_2eproto();

  void InitAsDefaultInstance();
  static DrawingDisplayItem* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT FilterDisplayItem : public ::google::protobuf::MessageLite {
 public:
  FilterDisplayItem();
  virtual ~FilterDisplayItem();

  FilterDisplayItem(const FilterDisplayItem& from);

  inline FilterDisplayItem& operator=(const FilterDisplayItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const FilterDisplayItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FilterDisplayItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FilterDisplayItem* other);

  // implements Message ----------------------------------------------

  FilterDisplayItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FilterDisplayItem& from);
  void MergeFrom(const FilterDisplayItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cc.proto.RectF bounds = 1;
  inline bool has_bounds() const;
  inline void clear_bounds();
  static const int kBoundsFieldNumber = 1;
  inline const ::cc::proto::RectF& bounds() const;
  inline ::cc::proto::RectF* mutable_bounds();
  inline ::cc::proto::RectF* release_bounds();
  inline void set_allocated_bounds(::cc::proto::RectF* bounds);

  // @@protoc_insertion_point(class_scope:cc.proto.FilterDisplayItem)
 private:
  inline void set_has_bounds();
  inline void clear_has_bounds();

  ::cc::proto::RectF* bounds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
  #endif
  friend void protobuf_AssignDesc_display_5fitem_2eproto();
  friend void protobuf_ShutdownFile_display_5fitem_2eproto();

  void InitAsDefaultInstance();
  static FilterDisplayItem* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT FloatClipDisplayItem : public ::google::protobuf::MessageLite {
 public:
  FloatClipDisplayItem();
  virtual ~FloatClipDisplayItem();

  FloatClipDisplayItem(const FloatClipDisplayItem& from);

  inline FloatClipDisplayItem& operator=(const FloatClipDisplayItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const FloatClipDisplayItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FloatClipDisplayItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FloatClipDisplayItem* other);

  // implements Message ----------------------------------------------

  FloatClipDisplayItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FloatClipDisplayItem& from);
  void MergeFrom(const FloatClipDisplayItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cc.proto.RectF clip_rect = 1;
  inline bool has_clip_rect() const;
  inline void clear_clip_rect();
  static const int kClipRectFieldNumber = 1;
  inline const ::cc::proto::RectF& clip_rect() const;
  inline ::cc::proto::RectF* mutable_clip_rect();
  inline ::cc::proto::RectF* release_clip_rect();
  inline void set_allocated_clip_rect(::cc::proto::RectF* clip_rect);

  // @@protoc_insertion_point(class_scope:cc.proto.FloatClipDisplayItem)
 private:
  inline void set_has_clip_rect();
  inline void clear_has_clip_rect();

  ::cc::proto::RectF* clip_rect_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
  #endif
  friend void protobuf_AssignDesc_display_5fitem_2eproto();
  friend void protobuf_ShutdownFile_display_5fitem_2eproto();

  void InitAsDefaultInstance();
  static FloatClipDisplayItem* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT TransformDisplayItem : public ::google::protobuf::MessageLite {
 public:
  TransformDisplayItem();
  virtual ~TransformDisplayItem();

  TransformDisplayItem(const TransformDisplayItem& from);

  inline TransformDisplayItem& operator=(const TransformDisplayItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const TransformDisplayItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransformDisplayItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransformDisplayItem* other);

  // implements Message ----------------------------------------------

  TransformDisplayItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransformDisplayItem& from);
  void MergeFrom(const TransformDisplayItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cc.proto.Transform transform = 1;
  inline bool has_transform() const;
  inline void clear_transform();
  static const int kTransformFieldNumber = 1;
  inline const ::cc::proto::Transform& transform() const;
  inline ::cc::proto::Transform* mutable_transform();
  inline ::cc::proto::Transform* release_transform();
  inline void set_allocated_transform(::cc::proto::Transform* transform);

  // @@protoc_insertion_point(class_scope:cc.proto.TransformDisplayItem)
 private:
  inline void set_has_transform();
  inline void clear_has_transform();

  ::cc::proto::Transform* transform_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_display_5fitem_2eproto();
  #endif
  friend void protobuf_AssignDesc_display_5fitem_2eproto();
  friend void protobuf_ShutdownFile_display_5fitem_2eproto();

  void InitAsDefaultInstance();
  static TransformDisplayItem* default_instance_;
};
// ===================================================================


// ===================================================================

// DisplayItemListSettings

// optional bool use_cached_picture = 1;
inline bool DisplayItemListSettings::has_use_cached_picture() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DisplayItemListSettings::set_has_use_cached_picture() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DisplayItemListSettings::clear_has_use_cached_picture() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DisplayItemListSettings::clear_use_cached_picture() {
  use_cached_picture_ = false;
  clear_has_use_cached_picture();
}
inline bool DisplayItemListSettings::use_cached_picture() const {
  return use_cached_picture_;
}
inline void DisplayItemListSettings::set_use_cached_picture(bool value) {
  set_has_use_cached_picture();
  use_cached_picture_ = value;
}

// -------------------------------------------------------------------

// DisplayItemList

// repeated .cc.proto.DisplayItem items = 1;
inline int DisplayItemList::items_size() const {
  return items_.size();
}
inline void DisplayItemList::clear_items() {
  items_.Clear();
}
inline const ::cc::proto::DisplayItem& DisplayItemList::items(int index) const {
  return items_.Get(index);
}
inline ::cc::proto::DisplayItem* DisplayItemList::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::cc::proto::DisplayItem* DisplayItemList::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cc::proto::DisplayItem >&
DisplayItemList::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::cc::proto::DisplayItem >*
DisplayItemList::mutable_items() {
  return &items_;
}

// optional .cc.proto.Rect layer_rect = 2;
inline bool DisplayItemList::has_layer_rect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DisplayItemList::set_has_layer_rect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DisplayItemList::clear_has_layer_rect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DisplayItemList::clear_layer_rect() {
  if (layer_rect_ != NULL) layer_rect_->::cc::proto::Rect::Clear();
  clear_has_layer_rect();
}
inline const ::cc::proto::Rect& DisplayItemList::layer_rect() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return layer_rect_ != NULL ? *layer_rect_ : *default_instance().layer_rect_;
#else
  return layer_rect_ != NULL ? *layer_rect_ : *default_instance_->layer_rect_;
#endif
}
inline ::cc::proto::Rect* DisplayItemList::mutable_layer_rect() {
  set_has_layer_rect();
  if (layer_rect_ == NULL) layer_rect_ = new ::cc::proto::Rect;
  return layer_rect_;
}
inline ::cc::proto::Rect* DisplayItemList::release_layer_rect() {
  clear_has_layer_rect();
  ::cc::proto::Rect* temp = layer_rect_;
  layer_rect_ = NULL;
  return temp;
}
inline void DisplayItemList::set_allocated_layer_rect(::cc::proto::Rect* layer_rect) {
  delete layer_rect_;
  layer_rect_ = layer_rect;
  if (layer_rect) {
    set_has_layer_rect();
  } else {
    clear_has_layer_rect();
  }
}

// optional .cc.proto.DisplayItemListSettings settings = 3;
inline bool DisplayItemList::has_settings() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DisplayItemList::set_has_settings() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DisplayItemList::clear_has_settings() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DisplayItemList::clear_settings() {
  if (settings_ != NULL) settings_->::cc::proto::DisplayItemListSettings::Clear();
  clear_has_settings();
}
inline const ::cc::proto::DisplayItemListSettings& DisplayItemList::settings() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return settings_ != NULL ? *settings_ : *default_instance().settings_;
#else
  return settings_ != NULL ? *settings_ : *default_instance_->settings_;
#endif
}
inline ::cc::proto::DisplayItemListSettings* DisplayItemList::mutable_settings() {
  set_has_settings();
  if (settings_ == NULL) settings_ = new ::cc::proto::DisplayItemListSettings;
  return settings_;
}
inline ::cc::proto::DisplayItemListSettings* DisplayItemList::release_settings() {
  clear_has_settings();
  ::cc::proto::DisplayItemListSettings* temp = settings_;
  settings_ = NULL;
  return temp;
}
inline void DisplayItemList::set_allocated_settings(::cc::proto::DisplayItemListSettings* settings) {
  delete settings_;
  settings_ = settings;
  if (settings) {
    set_has_settings();
  } else {
    clear_has_settings();
  }
}

// -------------------------------------------------------------------

// DisplayItem

// optional .cc.proto.DisplayItem.Type type = 1;
inline bool DisplayItem::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DisplayItem::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DisplayItem::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DisplayItem::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::cc::proto::DisplayItem_Type DisplayItem::type() const {
  return static_cast< ::cc::proto::DisplayItem_Type >(type_);
}
inline void DisplayItem::set_type(::cc::proto::DisplayItem_Type value) {
  assert(::cc::proto::DisplayItem_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .cc.proto.ClipDisplayItem clip_item = 1000;
inline bool DisplayItem::has_clip_item() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DisplayItem::set_has_clip_item() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DisplayItem::clear_has_clip_item() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DisplayItem::clear_clip_item() {
  if (clip_item_ != NULL) clip_item_->::cc::proto::ClipDisplayItem::Clear();
  clear_has_clip_item();
}
inline const ::cc::proto::ClipDisplayItem& DisplayItem::clip_item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return clip_item_ != NULL ? *clip_item_ : *default_instance().clip_item_;
#else
  return clip_item_ != NULL ? *clip_item_ : *default_instance_->clip_item_;
#endif
}
inline ::cc::proto::ClipDisplayItem* DisplayItem::mutable_clip_item() {
  set_has_clip_item();
  if (clip_item_ == NULL) clip_item_ = new ::cc::proto::ClipDisplayItem;
  return clip_item_;
}
inline ::cc::proto::ClipDisplayItem* DisplayItem::release_clip_item() {
  clear_has_clip_item();
  ::cc::proto::ClipDisplayItem* temp = clip_item_;
  clip_item_ = NULL;
  return temp;
}
inline void DisplayItem::set_allocated_clip_item(::cc::proto::ClipDisplayItem* clip_item) {
  delete clip_item_;
  clip_item_ = clip_item;
  if (clip_item) {
    set_has_clip_item();
  } else {
    clear_has_clip_item();
  }
}

// optional .cc.proto.ClipPathDisplayItem clip_path_item = 1001;
inline bool DisplayItem::has_clip_path_item() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DisplayItem::set_has_clip_path_item() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DisplayItem::clear_has_clip_path_item() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DisplayItem::clear_clip_path_item() {
  if (clip_path_item_ != NULL) clip_path_item_->::cc::proto::ClipPathDisplayItem::Clear();
  clear_has_clip_path_item();
}
inline const ::cc::proto::ClipPathDisplayItem& DisplayItem::clip_path_item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return clip_path_item_ != NULL ? *clip_path_item_ : *default_instance().clip_path_item_;
#else
  return clip_path_item_ != NULL ? *clip_path_item_ : *default_instance_->clip_path_item_;
#endif
}
inline ::cc::proto::ClipPathDisplayItem* DisplayItem::mutable_clip_path_item() {
  set_has_clip_path_item();
  if (clip_path_item_ == NULL) clip_path_item_ = new ::cc::proto::ClipPathDisplayItem;
  return clip_path_item_;
}
inline ::cc::proto::ClipPathDisplayItem* DisplayItem::release_clip_path_item() {
  clear_has_clip_path_item();
  ::cc::proto::ClipPathDisplayItem* temp = clip_path_item_;
  clip_path_item_ = NULL;
  return temp;
}
inline void DisplayItem::set_allocated_clip_path_item(::cc::proto::ClipPathDisplayItem* clip_path_item) {
  delete clip_path_item_;
  clip_path_item_ = clip_path_item;
  if (clip_path_item) {
    set_has_clip_path_item();
  } else {
    clear_has_clip_path_item();
  }
}

// optional .cc.proto.CompositingDisplayItem compositing_item = 1002;
inline bool DisplayItem::has_compositing_item() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DisplayItem::set_has_compositing_item() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DisplayItem::clear_has_compositing_item() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DisplayItem::clear_compositing_item() {
  if (compositing_item_ != NULL) compositing_item_->::cc::proto::CompositingDisplayItem::Clear();
  clear_has_compositing_item();
}
inline const ::cc::proto::CompositingDisplayItem& DisplayItem::compositing_item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return compositing_item_ != NULL ? *compositing_item_ : *default_instance().compositing_item_;
#else
  return compositing_item_ != NULL ? *compositing_item_ : *default_instance_->compositing_item_;
#endif
}
inline ::cc::proto::CompositingDisplayItem* DisplayItem::mutable_compositing_item() {
  set_has_compositing_item();
  if (compositing_item_ == NULL) compositing_item_ = new ::cc::proto::CompositingDisplayItem;
  return compositing_item_;
}
inline ::cc::proto::CompositingDisplayItem* DisplayItem::release_compositing_item() {
  clear_has_compositing_item();
  ::cc::proto::CompositingDisplayItem* temp = compositing_item_;
  compositing_item_ = NULL;
  return temp;
}
inline void DisplayItem::set_allocated_compositing_item(::cc::proto::CompositingDisplayItem* compositing_item) {
  delete compositing_item_;
  compositing_item_ = compositing_item;
  if (compositing_item) {
    set_has_compositing_item();
  } else {
    clear_has_compositing_item();
  }
}

// optional .cc.proto.DrawingDisplayItem drawing_item = 1003;
inline bool DisplayItem::has_drawing_item() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DisplayItem::set_has_drawing_item() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DisplayItem::clear_has_drawing_item() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DisplayItem::clear_drawing_item() {
  if (drawing_item_ != NULL) drawing_item_->::cc::proto::DrawingDisplayItem::Clear();
  clear_has_drawing_item();
}
inline const ::cc::proto::DrawingDisplayItem& DisplayItem::drawing_item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return drawing_item_ != NULL ? *drawing_item_ : *default_instance().drawing_item_;
#else
  return drawing_item_ != NULL ? *drawing_item_ : *default_instance_->drawing_item_;
#endif
}
inline ::cc::proto::DrawingDisplayItem* DisplayItem::mutable_drawing_item() {
  set_has_drawing_item();
  if (drawing_item_ == NULL) drawing_item_ = new ::cc::proto::DrawingDisplayItem;
  return drawing_item_;
}
inline ::cc::proto::DrawingDisplayItem* DisplayItem::release_drawing_item() {
  clear_has_drawing_item();
  ::cc::proto::DrawingDisplayItem* temp = drawing_item_;
  drawing_item_ = NULL;
  return temp;
}
inline void DisplayItem::set_allocated_drawing_item(::cc::proto::DrawingDisplayItem* drawing_item) {
  delete drawing_item_;
  drawing_item_ = drawing_item;
  if (drawing_item) {
    set_has_drawing_item();
  } else {
    clear_has_drawing_item();
  }
}

// optional .cc.proto.FilterDisplayItem filter_item = 1004;
inline bool DisplayItem::has_filter_item() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DisplayItem::set_has_filter_item() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DisplayItem::clear_has_filter_item() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DisplayItem::clear_filter_item() {
  if (filter_item_ != NULL) filter_item_->::cc::proto::FilterDisplayItem::Clear();
  clear_has_filter_item();
}
inline const ::cc::proto::FilterDisplayItem& DisplayItem::filter_item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return filter_item_ != NULL ? *filter_item_ : *default_instance().filter_item_;
#else
  return filter_item_ != NULL ? *filter_item_ : *default_instance_->filter_item_;
#endif
}
inline ::cc::proto::FilterDisplayItem* DisplayItem::mutable_filter_item() {
  set_has_filter_item();
  if (filter_item_ == NULL) filter_item_ = new ::cc::proto::FilterDisplayItem;
  return filter_item_;
}
inline ::cc::proto::FilterDisplayItem* DisplayItem::release_filter_item() {
  clear_has_filter_item();
  ::cc::proto::FilterDisplayItem* temp = filter_item_;
  filter_item_ = NULL;
  return temp;
}
inline void DisplayItem::set_allocated_filter_item(::cc::proto::FilterDisplayItem* filter_item) {
  delete filter_item_;
  filter_item_ = filter_item;
  if (filter_item) {
    set_has_filter_item();
  } else {
    clear_has_filter_item();
  }
}

// optional .cc.proto.FloatClipDisplayItem float_clip_item = 1005;
inline bool DisplayItem::has_float_clip_item() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DisplayItem::set_has_float_clip_item() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DisplayItem::clear_has_float_clip_item() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DisplayItem::clear_float_clip_item() {
  if (float_clip_item_ != NULL) float_clip_item_->::cc::proto::FloatClipDisplayItem::Clear();
  clear_has_float_clip_item();
}
inline const ::cc::proto::FloatClipDisplayItem& DisplayItem::float_clip_item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return float_clip_item_ != NULL ? *float_clip_item_ : *default_instance().float_clip_item_;
#else
  return float_clip_item_ != NULL ? *float_clip_item_ : *default_instance_->float_clip_item_;
#endif
}
inline ::cc::proto::FloatClipDisplayItem* DisplayItem::mutable_float_clip_item() {
  set_has_float_clip_item();
  if (float_clip_item_ == NULL) float_clip_item_ = new ::cc::proto::FloatClipDisplayItem;
  return float_clip_item_;
}
inline ::cc::proto::FloatClipDisplayItem* DisplayItem::release_float_clip_item() {
  clear_has_float_clip_item();
  ::cc::proto::FloatClipDisplayItem* temp = float_clip_item_;
  float_clip_item_ = NULL;
  return temp;
}
inline void DisplayItem::set_allocated_float_clip_item(::cc::proto::FloatClipDisplayItem* float_clip_item) {
  delete float_clip_item_;
  float_clip_item_ = float_clip_item;
  if (float_clip_item) {
    set_has_float_clip_item();
  } else {
    clear_has_float_clip_item();
  }
}

// optional .cc.proto.TransformDisplayItem transform_item = 1006;
inline bool DisplayItem::has_transform_item() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DisplayItem::set_has_transform_item() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DisplayItem::clear_has_transform_item() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DisplayItem::clear_transform_item() {
  if (transform_item_ != NULL) transform_item_->::cc::proto::TransformDisplayItem::Clear();
  clear_has_transform_item();
}
inline const ::cc::proto::TransformDisplayItem& DisplayItem::transform_item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transform_item_ != NULL ? *transform_item_ : *default_instance().transform_item_;
#else
  return transform_item_ != NULL ? *transform_item_ : *default_instance_->transform_item_;
#endif
}
inline ::cc::proto::TransformDisplayItem* DisplayItem::mutable_transform_item() {
  set_has_transform_item();
  if (transform_item_ == NULL) transform_item_ = new ::cc::proto::TransformDisplayItem;
  return transform_item_;
}
inline ::cc::proto::TransformDisplayItem* DisplayItem::release_transform_item() {
  clear_has_transform_item();
  ::cc::proto::TransformDisplayItem* temp = transform_item_;
  transform_item_ = NULL;
  return temp;
}
inline void DisplayItem::set_allocated_transform_item(::cc::proto::TransformDisplayItem* transform_item) {
  delete transform_item_;
  transform_item_ = transform_item;
  if (transform_item) {
    set_has_transform_item();
  } else {
    clear_has_transform_item();
  }
}

// -------------------------------------------------------------------

// ClipDisplayItem

// optional .cc.proto.Rect clip_rect = 1;
inline bool ClipDisplayItem::has_clip_rect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClipDisplayItem::set_has_clip_rect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClipDisplayItem::clear_has_clip_rect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClipDisplayItem::clear_clip_rect() {
  if (clip_rect_ != NULL) clip_rect_->::cc::proto::Rect::Clear();
  clear_has_clip_rect();
}
inline const ::cc::proto::Rect& ClipDisplayItem::clip_rect() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return clip_rect_ != NULL ? *clip_rect_ : *default_instance().clip_rect_;
#else
  return clip_rect_ != NULL ? *clip_rect_ : *default_instance_->clip_rect_;
#endif
}
inline ::cc::proto::Rect* ClipDisplayItem::mutable_clip_rect() {
  set_has_clip_rect();
  if (clip_rect_ == NULL) clip_rect_ = new ::cc::proto::Rect;
  return clip_rect_;
}
inline ::cc::proto::Rect* ClipDisplayItem::release_clip_rect() {
  clear_has_clip_rect();
  ::cc::proto::Rect* temp = clip_rect_;
  clip_rect_ = NULL;
  return temp;
}
inline void ClipDisplayItem::set_allocated_clip_rect(::cc::proto::Rect* clip_rect) {
  delete clip_rect_;
  clip_rect_ = clip_rect;
  if (clip_rect) {
    set_has_clip_rect();
  } else {
    clear_has_clip_rect();
  }
}

// repeated .cc.proto.SkRRect rounded_rects = 2;
inline int ClipDisplayItem::rounded_rects_size() const {
  return rounded_rects_.size();
}
inline void ClipDisplayItem::clear_rounded_rects() {
  rounded_rects_.Clear();
}
inline const ::cc::proto::SkRRect& ClipDisplayItem::rounded_rects(int index) const {
  return rounded_rects_.Get(index);
}
inline ::cc::proto::SkRRect* ClipDisplayItem::mutable_rounded_rects(int index) {
  return rounded_rects_.Mutable(index);
}
inline ::cc::proto::SkRRect* ClipDisplayItem::add_rounded_rects() {
  return rounded_rects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cc::proto::SkRRect >&
ClipDisplayItem::rounded_rects() const {
  return rounded_rects_;
}
inline ::google::protobuf::RepeatedPtrField< ::cc::proto::SkRRect >*
ClipDisplayItem::mutable_rounded_rects() {
  return &rounded_rects_;
}

// -------------------------------------------------------------------

// ClipPathDisplayItem

// optional .cc.proto.SkRegion.Op clip_op = 1;
inline bool ClipPathDisplayItem::has_clip_op() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClipPathDisplayItem::set_has_clip_op() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClipPathDisplayItem::clear_has_clip_op() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClipPathDisplayItem::clear_clip_op() {
  clip_op_ = 0;
  clear_has_clip_op();
}
inline ::cc::proto::SkRegion_Op ClipPathDisplayItem::clip_op() const {
  return static_cast< ::cc::proto::SkRegion_Op >(clip_op_);
}
inline void ClipPathDisplayItem::set_clip_op(::cc::proto::SkRegion_Op value) {
  assert(::cc::proto::SkRegion_Op_IsValid(value));
  set_has_clip_op();
  clip_op_ = value;
}

// optional bool antialias = 2;
inline bool ClipPathDisplayItem::has_antialias() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClipPathDisplayItem::set_has_antialias() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClipPathDisplayItem::clear_has_antialias() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClipPathDisplayItem::clear_antialias() {
  antialias_ = false;
  clear_has_antialias();
}
inline bool ClipPathDisplayItem::antialias() const {
  return antialias_;
}
inline void ClipPathDisplayItem::set_antialias(bool value) {
  set_has_antialias();
  antialias_ = value;
}

// optional bytes clip_path = 3;
inline bool ClipPathDisplayItem::has_clip_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClipPathDisplayItem::set_has_clip_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClipPathDisplayItem::clear_has_clip_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClipPathDisplayItem::clear_clip_path() {
  if (clip_path_ != &::google::protobuf::internal::GetEmptyString()) {
    clip_path_->clear();
  }
  clear_has_clip_path();
}
inline const ::std::string& ClipPathDisplayItem::clip_path() const {
  return *clip_path_;
}
inline void ClipPathDisplayItem::set_clip_path(const ::std::string& value) {
  set_has_clip_path();
  if (clip_path_ == &::google::protobuf::internal::GetEmptyString()) {
    clip_path_ = new ::std::string;
  }
  clip_path_->assign(value);
}
inline void ClipPathDisplayItem::set_clip_path(const char* value) {
  set_has_clip_path();
  if (clip_path_ == &::google::protobuf::internal::GetEmptyString()) {
    clip_path_ = new ::std::string;
  }
  clip_path_->assign(value);
}
inline void ClipPathDisplayItem::set_clip_path(const void* value, size_t size) {
  set_has_clip_path();
  if (clip_path_ == &::google::protobuf::internal::GetEmptyString()) {
    clip_path_ = new ::std::string;
  }
  clip_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClipPathDisplayItem::mutable_clip_path() {
  set_has_clip_path();
  if (clip_path_ == &::google::protobuf::internal::GetEmptyString()) {
    clip_path_ = new ::std::string;
  }
  return clip_path_;
}
inline ::std::string* ClipPathDisplayItem::release_clip_path() {
  clear_has_clip_path();
  if (clip_path_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = clip_path_;
    clip_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ClipPathDisplayItem::set_allocated_clip_path(::std::string* clip_path) {
  if (clip_path_ != &::google::protobuf::internal::GetEmptyString()) {
    delete clip_path_;
  }
  if (clip_path) {
    set_has_clip_path();
    clip_path_ = clip_path;
  } else {
    clear_has_clip_path();
    clip_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// CompositingDisplayItem

// optional uint32 alpha = 1;
inline bool CompositingDisplayItem::has_alpha() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompositingDisplayItem::set_has_alpha() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CompositingDisplayItem::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CompositingDisplayItem::clear_alpha() {
  alpha_ = 0u;
  clear_has_alpha();
}
inline ::google::protobuf::uint32 CompositingDisplayItem::alpha() const {
  return alpha_;
}
inline void CompositingDisplayItem::set_alpha(::google::protobuf::uint32 value) {
  set_has_alpha();
  alpha_ = value;
}

// optional .cc.proto.SkXfermode.Mode mode = 2;
inline bool CompositingDisplayItem::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompositingDisplayItem::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CompositingDisplayItem::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CompositingDisplayItem::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::cc::proto::SkXfermode_Mode CompositingDisplayItem::mode() const {
  return static_cast< ::cc::proto::SkXfermode_Mode >(mode_);
}
inline void CompositingDisplayItem::set_mode(::cc::proto::SkXfermode_Mode value) {
  assert(::cc::proto::SkXfermode_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// optional .cc.proto.RectF bounds = 3;
inline bool CompositingDisplayItem::has_bounds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CompositingDisplayItem::set_has_bounds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CompositingDisplayItem::clear_has_bounds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CompositingDisplayItem::clear_bounds() {
  if (bounds_ != NULL) bounds_->::cc::proto::RectF::Clear();
  clear_has_bounds();
}
inline const ::cc::proto::RectF& CompositingDisplayItem::bounds() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bounds_ != NULL ? *bounds_ : *default_instance().bounds_;
#else
  return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
#endif
}
inline ::cc::proto::RectF* CompositingDisplayItem::mutable_bounds() {
  set_has_bounds();
  if (bounds_ == NULL) bounds_ = new ::cc::proto::RectF;
  return bounds_;
}
inline ::cc::proto::RectF* CompositingDisplayItem::release_bounds() {
  clear_has_bounds();
  ::cc::proto::RectF* temp = bounds_;
  bounds_ = NULL;
  return temp;
}
inline void CompositingDisplayItem::set_allocated_bounds(::cc::proto::RectF* bounds) {
  delete bounds_;
  bounds_ = bounds;
  if (bounds) {
    set_has_bounds();
  } else {
    clear_has_bounds();
  }
}

// optional bytes color_filter = 4;
inline bool CompositingDisplayItem::has_color_filter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CompositingDisplayItem::set_has_color_filter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CompositingDisplayItem::clear_has_color_filter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CompositingDisplayItem::clear_color_filter() {
  if (color_filter_ != &::google::protobuf::internal::GetEmptyString()) {
    color_filter_->clear();
  }
  clear_has_color_filter();
}
inline const ::std::string& CompositingDisplayItem::color_filter() const {
  return *color_filter_;
}
inline void CompositingDisplayItem::set_color_filter(const ::std::string& value) {
  set_has_color_filter();
  if (color_filter_ == &::google::protobuf::internal::GetEmptyString()) {
    color_filter_ = new ::std::string;
  }
  color_filter_->assign(value);
}
inline void CompositingDisplayItem::set_color_filter(const char* value) {
  set_has_color_filter();
  if (color_filter_ == &::google::protobuf::internal::GetEmptyString()) {
    color_filter_ = new ::std::string;
  }
  color_filter_->assign(value);
}
inline void CompositingDisplayItem::set_color_filter(const void* value, size_t size) {
  set_has_color_filter();
  if (color_filter_ == &::google::protobuf::internal::GetEmptyString()) {
    color_filter_ = new ::std::string;
  }
  color_filter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CompositingDisplayItem::mutable_color_filter() {
  set_has_color_filter();
  if (color_filter_ == &::google::protobuf::internal::GetEmptyString()) {
    color_filter_ = new ::std::string;
  }
  return color_filter_;
}
inline ::std::string* CompositingDisplayItem::release_color_filter() {
  clear_has_color_filter();
  if (color_filter_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = color_filter_;
    color_filter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void CompositingDisplayItem::set_allocated_color_filter(::std::string* color_filter) {
  if (color_filter_ != &::google::protobuf::internal::GetEmptyString()) {
    delete color_filter_;
  }
  if (color_filter) {
    set_has_color_filter();
    color_filter_ = color_filter;
  } else {
    clear_has_color_filter();
    color_filter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bool lcd_text_requires_opaque_layer = 5;
inline bool CompositingDisplayItem::has_lcd_text_requires_opaque_layer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CompositingDisplayItem::set_has_lcd_text_requires_opaque_layer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CompositingDisplayItem::clear_has_lcd_text_requires_opaque_layer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CompositingDisplayItem::clear_lcd_text_requires_opaque_layer() {
  lcd_text_requires_opaque_layer_ = false;
  clear_has_lcd_text_requires_opaque_layer();
}
inline bool CompositingDisplayItem::lcd_text_requires_opaque_layer() const {
  return lcd_text_requires_opaque_layer_;
}
inline void CompositingDisplayItem::set_lcd_text_requires_opaque_layer(bool value) {
  set_has_lcd_text_requires_opaque_layer();
  lcd_text_requires_opaque_layer_ = value;
}

// -------------------------------------------------------------------

// DrawingDisplayItem

// optional bytes picture = 1;
inline bool DrawingDisplayItem::has_picture() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DrawingDisplayItem::set_has_picture() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DrawingDisplayItem::clear_has_picture() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DrawingDisplayItem::clear_picture() {
  if (picture_ != &::google::protobuf::internal::GetEmptyString()) {
    picture_->clear();
  }
  clear_has_picture();
}
inline const ::std::string& DrawingDisplayItem::picture() const {
  return *picture_;
}
inline void DrawingDisplayItem::set_picture(const ::std::string& value) {
  set_has_picture();
  if (picture_ == &::google::protobuf::internal::GetEmptyString()) {
    picture_ = new ::std::string;
  }
  picture_->assign(value);
}
inline void DrawingDisplayItem::set_picture(const char* value) {
  set_has_picture();
  if (picture_ == &::google::protobuf::internal::GetEmptyString()) {
    picture_ = new ::std::string;
  }
  picture_->assign(value);
}
inline void DrawingDisplayItem::set_picture(const void* value, size_t size) {
  set_has_picture();
  if (picture_ == &::google::protobuf::internal::GetEmptyString()) {
    picture_ = new ::std::string;
  }
  picture_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DrawingDisplayItem::mutable_picture() {
  set_has_picture();
  if (picture_ == &::google::protobuf::internal::GetEmptyString()) {
    picture_ = new ::std::string;
  }
  return picture_;
}
inline ::std::string* DrawingDisplayItem::release_picture() {
  clear_has_picture();
  if (picture_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = picture_;
    picture_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DrawingDisplayItem::set_allocated_picture(::std::string* picture) {
  if (picture_ != &::google::protobuf::internal::GetEmptyString()) {
    delete picture_;
  }
  if (picture) {
    set_has_picture();
    picture_ = picture;
  } else {
    clear_has_picture();
    picture_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// FilterDisplayItem

// optional .cc.proto.RectF bounds = 1;
inline bool FilterDisplayItem::has_bounds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterDisplayItem::set_has_bounds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterDisplayItem::clear_has_bounds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterDisplayItem::clear_bounds() {
  if (bounds_ != NULL) bounds_->::cc::proto::RectF::Clear();
  clear_has_bounds();
}
inline const ::cc::proto::RectF& FilterDisplayItem::bounds() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bounds_ != NULL ? *bounds_ : *default_instance().bounds_;
#else
  return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
#endif
}
inline ::cc::proto::RectF* FilterDisplayItem::mutable_bounds() {
  set_has_bounds();
  if (bounds_ == NULL) bounds_ = new ::cc::proto::RectF;
  return bounds_;
}
inline ::cc::proto::RectF* FilterDisplayItem::release_bounds() {
  clear_has_bounds();
  ::cc::proto::RectF* temp = bounds_;
  bounds_ = NULL;
  return temp;
}
inline void FilterDisplayItem::set_allocated_bounds(::cc::proto::RectF* bounds) {
  delete bounds_;
  bounds_ = bounds;
  if (bounds) {
    set_has_bounds();
  } else {
    clear_has_bounds();
  }
}

// -------------------------------------------------------------------

// FloatClipDisplayItem

// optional .cc.proto.RectF clip_rect = 1;
inline bool FloatClipDisplayItem::has_clip_rect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloatClipDisplayItem::set_has_clip_rect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FloatClipDisplayItem::clear_has_clip_rect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FloatClipDisplayItem::clear_clip_rect() {
  if (clip_rect_ != NULL) clip_rect_->::cc::proto::RectF::Clear();
  clear_has_clip_rect();
}
inline const ::cc::proto::RectF& FloatClipDisplayItem::clip_rect() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return clip_rect_ != NULL ? *clip_rect_ : *default_instance().clip_rect_;
#else
  return clip_rect_ != NULL ? *clip_rect_ : *default_instance_->clip_rect_;
#endif
}
inline ::cc::proto::RectF* FloatClipDisplayItem::mutable_clip_rect() {
  set_has_clip_rect();
  if (clip_rect_ == NULL) clip_rect_ = new ::cc::proto::RectF;
  return clip_rect_;
}
inline ::cc::proto::RectF* FloatClipDisplayItem::release_clip_rect() {
  clear_has_clip_rect();
  ::cc::proto::RectF* temp = clip_rect_;
  clip_rect_ = NULL;
  return temp;
}
inline void FloatClipDisplayItem::set_allocated_clip_rect(::cc::proto::RectF* clip_rect) {
  delete clip_rect_;
  clip_rect_ = clip_rect;
  if (clip_rect) {
    set_has_clip_rect();
  } else {
    clear_has_clip_rect();
  }
}

// -------------------------------------------------------------------

// TransformDisplayItem

// optional .cc.proto.Transform transform = 1;
inline bool TransformDisplayItem::has_transform() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransformDisplayItem::set_has_transform() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransformDisplayItem::clear_has_transform() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransformDisplayItem::clear_transform() {
  if (transform_ != NULL) transform_->::cc::proto::Transform::Clear();
  clear_has_transform();
}
inline const ::cc::proto::Transform& TransformDisplayItem::transform() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transform_ != NULL ? *transform_ : *default_instance().transform_;
#else
  return transform_ != NULL ? *transform_ : *default_instance_->transform_;
#endif
}
inline ::cc::proto::Transform* TransformDisplayItem::mutable_transform() {
  set_has_transform();
  if (transform_ == NULL) transform_ = new ::cc::proto::Transform;
  return transform_;
}
inline ::cc::proto::Transform* TransformDisplayItem::release_transform() {
  clear_has_transform();
  ::cc::proto::Transform* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline void TransformDisplayItem::set_allocated_transform(::cc::proto::Transform* transform) {
  delete transform_;
  transform_ = transform;
  if (transform) {
    set_has_transform();
  } else {
    clear_has_transform();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_display_5fitem_2eproto__INCLUDED
