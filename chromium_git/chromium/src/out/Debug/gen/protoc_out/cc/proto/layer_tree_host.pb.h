// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: layer_tree_host.proto

#ifndef PROTOBUF_layer_5ftree_5fhost_2eproto__INCLUDED
#define PROTOBUF_layer_5ftree_5fhost_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "layer.pb.h"
#include "layer_selection_bound.pb.h"
#include "layer_tree_settings.pb.h"
#include "layer_tree_debug_state.pb.h"
#include "property_tree.pb.h"
#include "size.pb.h"
#include "vector2df.pb.h"
// @@protoc_insertion_point(includes)
#include "cc/proto/cc_proto_export.h"

namespace cc {
namespace proto {

// Internal implementation detail -- do not call these.
void CC_PROTO_EXPORT protobuf_AddDesc_layer_5ftree_5fhost_2eproto();
void protobuf_AssignDesc_layer_5ftree_5fhost_2eproto();
void protobuf_ShutdownFile_layer_5ftree_5fhost_2eproto();

class LayerTreeHost;

// ===================================================================

class CC_PROTO_EXPORT LayerTreeHost : public ::google::protobuf::MessageLite {
 public:
  LayerTreeHost();
  virtual ~LayerTreeHost();

  LayerTreeHost(const LayerTreeHost& from);

  inline LayerTreeHost& operator=(const LayerTreeHost& from) {
    CopyFrom(from);
    return *this;
  }

  static const LayerTreeHost& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LayerTreeHost* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LayerTreeHost* other);

  // implements Message ----------------------------------------------

  LayerTreeHost* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LayerTreeHost& from);
  void MergeFrom(const LayerTreeHost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool needs_full_tree_sync = 1;
  inline bool has_needs_full_tree_sync() const;
  inline void clear_needs_full_tree_sync();
  static const int kNeedsFullTreeSyncFieldNumber = 1;
  inline bool needs_full_tree_sync() const;
  inline void set_needs_full_tree_sync(bool value);

  // optional bool needs_meta_info_recomputation = 2;
  inline bool has_needs_meta_info_recomputation() const;
  inline void clear_needs_meta_info_recomputation();
  static const int kNeedsMetaInfoRecomputationFieldNumber = 2;
  inline bool needs_meta_info_recomputation() const;
  inline void set_needs_meta_info_recomputation(bool value);

  // optional int32 source_frame_number = 3;
  inline bool has_source_frame_number() const;
  inline void clear_source_frame_number();
  static const int kSourceFrameNumberFieldNumber = 3;
  inline ::google::protobuf::int32 source_frame_number() const;
  inline void set_source_frame_number(::google::protobuf::int32 value);

  // optional int32 meta_information_sequence_number = 4;
  inline bool has_meta_information_sequence_number() const;
  inline void clear_meta_information_sequence_number();
  static const int kMetaInformationSequenceNumberFieldNumber = 4;
  inline ::google::protobuf::int32 meta_information_sequence_number() const;
  inline void set_meta_information_sequence_number(::google::protobuf::int32 value);

  // optional .cc.proto.LayerNode root_layer = 5;
  inline bool has_root_layer() const;
  inline void clear_root_layer();
  static const int kRootLayerFieldNumber = 5;
  inline const ::cc::proto::LayerNode& root_layer() const;
  inline ::cc::proto::LayerNode* mutable_root_layer();
  inline ::cc::proto::LayerNode* release_root_layer();
  inline void set_allocated_root_layer(::cc::proto::LayerNode* root_layer);

  // optional .cc.proto.LayerUpdate layer_updates = 6;
  inline bool has_layer_updates() const;
  inline void clear_layer_updates();
  static const int kLayerUpdatesFieldNumber = 6;
  inline const ::cc::proto::LayerUpdate& layer_updates() const;
  inline ::cc::proto::LayerUpdate* mutable_layer_updates();
  inline ::cc::proto::LayerUpdate* release_layer_updates();
  inline void set_allocated_layer_updates(::cc::proto::LayerUpdate* layer_updates);

  // optional int32 hud_layer_id = 7;
  inline bool has_hud_layer_id() const;
  inline void clear_hud_layer_id();
  static const int kHudLayerIdFieldNumber = 7;
  inline ::google::protobuf::int32 hud_layer_id() const;
  inline void set_hud_layer_id(::google::protobuf::int32 value);

  // optional .cc.proto.LayerTreeDebugState debug_state = 8;
  inline bool has_debug_state() const;
  inline void clear_debug_state();
  static const int kDebugStateFieldNumber = 8;
  inline const ::cc::proto::LayerTreeDebugState& debug_state() const;
  inline ::cc::proto::LayerTreeDebugState* mutable_debug_state();
  inline ::cc::proto::LayerTreeDebugState* release_debug_state();
  inline void set_allocated_debug_state(::cc::proto::LayerTreeDebugState* debug_state);

  // optional .cc.proto.Size device_viewport_size = 9;
  inline bool has_device_viewport_size() const;
  inline void clear_device_viewport_size();
  static const int kDeviceViewportSizeFieldNumber = 9;
  inline const ::cc::proto::Size& device_viewport_size() const;
  inline ::cc::proto::Size* mutable_device_viewport_size();
  inline ::cc::proto::Size* release_device_viewport_size();
  inline void set_allocated_device_viewport_size(::cc::proto::Size* device_viewport_size);

  // optional bool top_controls_shrink_blink_size = 10;
  inline bool has_top_controls_shrink_blink_size() const;
  inline void clear_top_controls_shrink_blink_size();
  static const int kTopControlsShrinkBlinkSizeFieldNumber = 10;
  inline bool top_controls_shrink_blink_size() const;
  inline void set_top_controls_shrink_blink_size(bool value);

  // optional float top_controls_height = 11;
  inline bool has_top_controls_height() const;
  inline void clear_top_controls_height();
  static const int kTopControlsHeightFieldNumber = 11;
  inline float top_controls_height() const;
  inline void set_top_controls_height(float value);

  // optional float top_controls_shown_ratio = 12;
  inline bool has_top_controls_shown_ratio() const;
  inline void clear_top_controls_shown_ratio();
  static const int kTopControlsShownRatioFieldNumber = 12;
  inline float top_controls_shown_ratio() const;
  inline void set_top_controls_shown_ratio(float value);

  // optional float device_scale_factor = 13;
  inline bool has_device_scale_factor() const;
  inline void clear_device_scale_factor();
  static const int kDeviceScaleFactorFieldNumber = 13;
  inline float device_scale_factor() const;
  inline void set_device_scale_factor(float value);

  // optional float painted_device_scale_factor = 14;
  inline bool has_painted_device_scale_factor() const;
  inline void clear_painted_device_scale_factor();
  static const int kPaintedDeviceScaleFactorFieldNumber = 14;
  inline float painted_device_scale_factor() const;
  inline void set_painted_device_scale_factor(float value);

  // optional float page_scale_factor = 15;
  inline bool has_page_scale_factor() const;
  inline void clear_page_scale_factor();
  static const int kPageScaleFactorFieldNumber = 15;
  inline float page_scale_factor() const;
  inline void set_page_scale_factor(float value);

  // optional float min_page_scale_factor = 16;
  inline bool has_min_page_scale_factor() const;
  inline void clear_min_page_scale_factor();
  static const int kMinPageScaleFactorFieldNumber = 16;
  inline float min_page_scale_factor() const;
  inline void set_min_page_scale_factor(float value);

  // optional float max_page_scale_factor = 17;
  inline bool has_max_page_scale_factor() const;
  inline void clear_max_page_scale_factor();
  static const int kMaxPageScaleFactorFieldNumber = 17;
  inline float max_page_scale_factor() const;
  inline void set_max_page_scale_factor(float value);

  // optional .cc.proto.Vector2dF elastic_overscroll = 18;
  inline bool has_elastic_overscroll() const;
  inline void clear_elastic_overscroll();
  static const int kElasticOverscrollFieldNumber = 18;
  inline const ::cc::proto::Vector2dF& elastic_overscroll() const;
  inline ::cc::proto::Vector2dF* mutable_elastic_overscroll();
  inline ::cc::proto::Vector2dF* release_elastic_overscroll();
  inline void set_allocated_elastic_overscroll(::cc::proto::Vector2dF* elastic_overscroll);

  // optional bool has_gpu_rasterization_trigger = 19;
  inline bool has_has_gpu_rasterization_trigger() const;
  inline void clear_has_gpu_rasterization_trigger();
  static const int kHasGpuRasterizationTriggerFieldNumber = 19;
  inline bool has_gpu_rasterization_trigger() const;
  inline void set_has_gpu_rasterization_trigger(bool value);

  // optional bool content_is_suitable_for_gpu_rasterization = 20;
  inline bool has_content_is_suitable_for_gpu_rasterization() const;
  inline void clear_content_is_suitable_for_gpu_rasterization();
  static const int kContentIsSuitableForGpuRasterizationFieldNumber = 20;
  inline bool content_is_suitable_for_gpu_rasterization() const;
  inline void set_content_is_suitable_for_gpu_rasterization(bool value);

  // optional uint32 background_color = 21;
  inline bool has_background_color() const;
  inline void clear_background_color();
  static const int kBackgroundColorFieldNumber = 21;
  inline ::google::protobuf::uint32 background_color() const;
  inline void set_background_color(::google::protobuf::uint32 value);

  // optional bool has_transparent_background = 22;
  inline bool has_has_transparent_background() const;
  inline void clear_has_transparent_background();
  static const int kHasTransparentBackgroundFieldNumber = 22;
  inline bool has_transparent_background() const;
  inline void set_has_transparent_background(bool value);

  // optional bool in_paint_layer_contents = 23;
  inline bool has_in_paint_layer_contents() const;
  inline void clear_in_paint_layer_contents();
  static const int kInPaintLayerContentsFieldNumber = 23;
  inline bool in_paint_layer_contents() const;
  inline void set_in_paint_layer_contents(bool value);

  // optional int32 id = 24;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 24;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional bool next_commit_forces_redraw = 25;
  inline bool has_next_commit_forces_redraw() const;
  inline void clear_next_commit_forces_redraw();
  static const int kNextCommitForcesRedrawFieldNumber = 25;
  inline bool next_commit_forces_redraw() const;
  inline void set_next_commit_forces_redraw(bool value);

  // optional int32 overscroll_elasticity_layer_id = 26;
  inline bool has_overscroll_elasticity_layer_id() const;
  inline void clear_overscroll_elasticity_layer_id();
  static const int kOverscrollElasticityLayerIdFieldNumber = 26;
  inline ::google::protobuf::int32 overscroll_elasticity_layer_id() const;
  inline void set_overscroll_elasticity_layer_id(::google::protobuf::int32 value);

  // optional int32 page_scale_layer_id = 27;
  inline bool has_page_scale_layer_id() const;
  inline void clear_page_scale_layer_id();
  static const int kPageScaleLayerIdFieldNumber = 27;
  inline ::google::protobuf::int32 page_scale_layer_id() const;
  inline void set_page_scale_layer_id(::google::protobuf::int32 value);

  // optional int32 inner_viewport_scroll_layer_id = 28;
  inline bool has_inner_viewport_scroll_layer_id() const;
  inline void clear_inner_viewport_scroll_layer_id();
  static const int kInnerViewportScrollLayerIdFieldNumber = 28;
  inline ::google::protobuf::int32 inner_viewport_scroll_layer_id() const;
  inline void set_inner_viewport_scroll_layer_id(::google::protobuf::int32 value);

  // optional int32 outer_viewport_scroll_layer_id = 29;
  inline bool has_outer_viewport_scroll_layer_id() const;
  inline void clear_outer_viewport_scroll_layer_id();
  static const int kOuterViewportScrollLayerIdFieldNumber = 29;
  inline ::google::protobuf::int32 outer_viewport_scroll_layer_id() const;
  inline void set_outer_viewport_scroll_layer_id(::google::protobuf::int32 value);

  // optional .cc.proto.LayerSelection selection = 30;
  inline bool has_selection() const;
  inline void clear_selection();
  static const int kSelectionFieldNumber = 30;
  inline const ::cc::proto::LayerSelection& selection() const;
  inline ::cc::proto::LayerSelection* mutable_selection();
  inline ::cc::proto::LayerSelection* release_selection();
  inline void set_allocated_selection(::cc::proto::LayerSelection* selection);

  // optional .cc.proto.PropertyTrees property_trees = 31;
  inline bool has_property_trees() const;
  inline void clear_property_trees();
  static const int kPropertyTreesFieldNumber = 31;
  inline const ::cc::proto::PropertyTrees& property_trees() const;
  inline ::cc::proto::PropertyTrees* mutable_property_trees();
  inline ::cc::proto::PropertyTrees* release_property_trees();
  inline void set_allocated_property_trees(::cc::proto::PropertyTrees* property_trees);

  // optional uint32 surface_id_namespace = 32;
  inline bool has_surface_id_namespace() const;
  inline void clear_surface_id_namespace();
  static const int kSurfaceIdNamespaceFieldNumber = 32;
  inline ::google::protobuf::uint32 surface_id_namespace() const;
  inline void set_surface_id_namespace(::google::protobuf::uint32 value);

  // optional uint32 next_surface_sequence = 33;
  inline bool has_next_surface_sequence() const;
  inline void clear_next_surface_sequence();
  static const int kNextSurfaceSequenceFieldNumber = 33;
  inline ::google::protobuf::uint32 next_surface_sequence() const;
  inline void set_next_surface_sequence(::google::protobuf::uint32 value);

  // optional bool have_wheel_event_handlers = 34;
  inline bool has_have_wheel_event_handlers() const;
  inline void clear_have_wheel_event_handlers();
  static const int kHaveWheelEventHandlersFieldNumber = 34;
  inline bool have_wheel_event_handlers() const;
  inline void set_have_wheel_event_handlers(bool value);

  // optional bool have_scroll_event_handlers = 35;
  inline bool has_have_scroll_event_handlers() const;
  inline void clear_have_scroll_event_handlers();
  static const int kHaveScrollEventHandlersFieldNumber = 35;
  inline bool have_scroll_event_handlers() const;
  inline void set_have_scroll_event_handlers(bool value);

  // @@protoc_insertion_point(class_scope:cc.proto.LayerTreeHost)
 private:
  inline void set_has_needs_full_tree_sync();
  inline void clear_has_needs_full_tree_sync();
  inline void set_has_needs_meta_info_recomputation();
  inline void clear_has_needs_meta_info_recomputation();
  inline void set_has_source_frame_number();
  inline void clear_has_source_frame_number();
  inline void set_has_meta_information_sequence_number();
  inline void clear_has_meta_information_sequence_number();
  inline void set_has_root_layer();
  inline void clear_has_root_layer();
  inline void set_has_layer_updates();
  inline void clear_has_layer_updates();
  inline void set_has_hud_layer_id();
  inline void clear_has_hud_layer_id();
  inline void set_has_debug_state();
  inline void clear_has_debug_state();
  inline void set_has_device_viewport_size();
  inline void clear_has_device_viewport_size();
  inline void set_has_top_controls_shrink_blink_size();
  inline void clear_has_top_controls_shrink_blink_size();
  inline void set_has_top_controls_height();
  inline void clear_has_top_controls_height();
  inline void set_has_top_controls_shown_ratio();
  inline void clear_has_top_controls_shown_ratio();
  inline void set_has_device_scale_factor();
  inline void clear_has_device_scale_factor();
  inline void set_has_painted_device_scale_factor();
  inline void clear_has_painted_device_scale_factor();
  inline void set_has_page_scale_factor();
  inline void clear_has_page_scale_factor();
  inline void set_has_min_page_scale_factor();
  inline void clear_has_min_page_scale_factor();
  inline void set_has_max_page_scale_factor();
  inline void clear_has_max_page_scale_factor();
  inline void set_has_elastic_overscroll();
  inline void clear_has_elastic_overscroll();
  inline void set_has_has_gpu_rasterization_trigger();
  inline void clear_has_has_gpu_rasterization_trigger();
  inline void set_has_content_is_suitable_for_gpu_rasterization();
  inline void clear_has_content_is_suitable_for_gpu_rasterization();
  inline void set_has_background_color();
  inline void clear_has_background_color();
  inline void set_has_has_transparent_background();
  inline void clear_has_has_transparent_background();
  inline void set_has_in_paint_layer_contents();
  inline void clear_has_in_paint_layer_contents();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_next_commit_forces_redraw();
  inline void clear_has_next_commit_forces_redraw();
  inline void set_has_overscroll_elasticity_layer_id();
  inline void clear_has_overscroll_elasticity_layer_id();
  inline void set_has_page_scale_layer_id();
  inline void clear_has_page_scale_layer_id();
  inline void set_has_inner_viewport_scroll_layer_id();
  inline void clear_has_inner_viewport_scroll_layer_id();
  inline void set_has_outer_viewport_scroll_layer_id();
  inline void clear_has_outer_viewport_scroll_layer_id();
  inline void set_has_selection();
  inline void clear_has_selection();
  inline void set_has_property_trees();
  inline void clear_has_property_trees();
  inline void set_has_surface_id_namespace();
  inline void clear_has_surface_id_namespace();
  inline void set_has_next_surface_sequence();
  inline void clear_has_next_surface_sequence();
  inline void set_has_have_wheel_event_handlers();
  inline void clear_has_have_wheel_event_handlers();
  inline void set_has_have_scroll_event_handlers();
  inline void clear_has_have_scroll_event_handlers();

  ::google::protobuf::int32 source_frame_number_;
  ::google::protobuf::int32 meta_information_sequence_number_;
  ::cc::proto::LayerNode* root_layer_;
  ::cc::proto::LayerUpdate* layer_updates_;
  ::google::protobuf::int32 hud_layer_id_;
  bool needs_full_tree_sync_;
  bool needs_meta_info_recomputation_;
  bool top_controls_shrink_blink_size_;
  bool has_gpu_rasterization_trigger_;
  ::cc::proto::LayerTreeDebugState* debug_state_;
  ::cc::proto::Size* device_viewport_size_;
  float top_controls_height_;
  float top_controls_shown_ratio_;
  float device_scale_factor_;
  float painted_device_scale_factor_;
  float page_scale_factor_;
  float min_page_scale_factor_;
  ::cc::proto::Vector2dF* elastic_overscroll_;
  float max_page_scale_factor_;
  ::google::protobuf::uint32 background_color_;
  bool content_is_suitable_for_gpu_rasterization_;
  bool has_transparent_background_;
  bool in_paint_layer_contents_;
  bool next_commit_forces_redraw_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 overscroll_elasticity_layer_id_;
  ::google::protobuf::int32 page_scale_layer_id_;
  ::google::protobuf::int32 inner_viewport_scroll_layer_id_;
  ::google::protobuf::int32 outer_viewport_scroll_layer_id_;
  ::cc::proto::LayerSelection* selection_;
  ::cc::proto::PropertyTrees* property_trees_;
  ::google::protobuf::uint32 surface_id_namespace_;
  ::google::protobuf::uint32 next_surface_sequence_;
  bool have_wheel_event_handlers_;
  bool have_scroll_event_handlers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(35 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_5ftree_5fhost_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_5ftree_5fhost_2eproto();
  #endif
  friend void protobuf_AssignDesc_layer_5ftree_5fhost_2eproto();
  friend void protobuf_ShutdownFile_layer_5ftree_5fhost_2eproto();

  void InitAsDefaultInstance();
  static LayerTreeHost* default_instance_;
};
// ===================================================================


// ===================================================================

// LayerTreeHost

// optional bool needs_full_tree_sync = 1;
inline bool LayerTreeHost::has_needs_full_tree_sync() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerTreeHost::set_has_needs_full_tree_sync() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayerTreeHost::clear_has_needs_full_tree_sync() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayerTreeHost::clear_needs_full_tree_sync() {
  needs_full_tree_sync_ = false;
  clear_has_needs_full_tree_sync();
}
inline bool LayerTreeHost::needs_full_tree_sync() const {
  return needs_full_tree_sync_;
}
inline void LayerTreeHost::set_needs_full_tree_sync(bool value) {
  set_has_needs_full_tree_sync();
  needs_full_tree_sync_ = value;
}

// optional bool needs_meta_info_recomputation = 2;
inline bool LayerTreeHost::has_needs_meta_info_recomputation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayerTreeHost::set_has_needs_meta_info_recomputation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LayerTreeHost::clear_has_needs_meta_info_recomputation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LayerTreeHost::clear_needs_meta_info_recomputation() {
  needs_meta_info_recomputation_ = false;
  clear_has_needs_meta_info_recomputation();
}
inline bool LayerTreeHost::needs_meta_info_recomputation() const {
  return needs_meta_info_recomputation_;
}
inline void LayerTreeHost::set_needs_meta_info_recomputation(bool value) {
  set_has_needs_meta_info_recomputation();
  needs_meta_info_recomputation_ = value;
}

// optional int32 source_frame_number = 3;
inline bool LayerTreeHost::has_source_frame_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LayerTreeHost::set_has_source_frame_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LayerTreeHost::clear_has_source_frame_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LayerTreeHost::clear_source_frame_number() {
  source_frame_number_ = 0;
  clear_has_source_frame_number();
}
inline ::google::protobuf::int32 LayerTreeHost::source_frame_number() const {
  return source_frame_number_;
}
inline void LayerTreeHost::set_source_frame_number(::google::protobuf::int32 value) {
  set_has_source_frame_number();
  source_frame_number_ = value;
}

// optional int32 meta_information_sequence_number = 4;
inline bool LayerTreeHost::has_meta_information_sequence_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LayerTreeHost::set_has_meta_information_sequence_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LayerTreeHost::clear_has_meta_information_sequence_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LayerTreeHost::clear_meta_information_sequence_number() {
  meta_information_sequence_number_ = 0;
  clear_has_meta_information_sequence_number();
}
inline ::google::protobuf::int32 LayerTreeHost::meta_information_sequence_number() const {
  return meta_information_sequence_number_;
}
inline void LayerTreeHost::set_meta_information_sequence_number(::google::protobuf::int32 value) {
  set_has_meta_information_sequence_number();
  meta_information_sequence_number_ = value;
}

// optional .cc.proto.LayerNode root_layer = 5;
inline bool LayerTreeHost::has_root_layer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LayerTreeHost::set_has_root_layer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LayerTreeHost::clear_has_root_layer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LayerTreeHost::clear_root_layer() {
  if (root_layer_ != NULL) root_layer_->::cc::proto::LayerNode::Clear();
  clear_has_root_layer();
}
inline const ::cc::proto::LayerNode& LayerTreeHost::root_layer() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return root_layer_ != NULL ? *root_layer_ : *default_instance().root_layer_;
#else
  return root_layer_ != NULL ? *root_layer_ : *default_instance_->root_layer_;
#endif
}
inline ::cc::proto::LayerNode* LayerTreeHost::mutable_root_layer() {
  set_has_root_layer();
  if (root_layer_ == NULL) root_layer_ = new ::cc::proto::LayerNode;
  return root_layer_;
}
inline ::cc::proto::LayerNode* LayerTreeHost::release_root_layer() {
  clear_has_root_layer();
  ::cc::proto::LayerNode* temp = root_layer_;
  root_layer_ = NULL;
  return temp;
}
inline void LayerTreeHost::set_allocated_root_layer(::cc::proto::LayerNode* root_layer) {
  delete root_layer_;
  root_layer_ = root_layer;
  if (root_layer) {
    set_has_root_layer();
  } else {
    clear_has_root_layer();
  }
}

// optional .cc.proto.LayerUpdate layer_updates = 6;
inline bool LayerTreeHost::has_layer_updates() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LayerTreeHost::set_has_layer_updates() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LayerTreeHost::clear_has_layer_updates() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LayerTreeHost::clear_layer_updates() {
  if (layer_updates_ != NULL) layer_updates_->::cc::proto::LayerUpdate::Clear();
  clear_has_layer_updates();
}
inline const ::cc::proto::LayerUpdate& LayerTreeHost::layer_updates() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return layer_updates_ != NULL ? *layer_updates_ : *default_instance().layer_updates_;
#else
  return layer_updates_ != NULL ? *layer_updates_ : *default_instance_->layer_updates_;
#endif
}
inline ::cc::proto::LayerUpdate* LayerTreeHost::mutable_layer_updates() {
  set_has_layer_updates();
  if (layer_updates_ == NULL) layer_updates_ = new ::cc::proto::LayerUpdate;
  return layer_updates_;
}
inline ::cc::proto::LayerUpdate* LayerTreeHost::release_layer_updates() {
  clear_has_layer_updates();
  ::cc::proto::LayerUpdate* temp = layer_updates_;
  layer_updates_ = NULL;
  return temp;
}
inline void LayerTreeHost::set_allocated_layer_updates(::cc::proto::LayerUpdate* layer_updates) {
  delete layer_updates_;
  layer_updates_ = layer_updates;
  if (layer_updates) {
    set_has_layer_updates();
  } else {
    clear_has_layer_updates();
  }
}

// optional int32 hud_layer_id = 7;
inline bool LayerTreeHost::has_hud_layer_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LayerTreeHost::set_has_hud_layer_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LayerTreeHost::clear_has_hud_layer_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LayerTreeHost::clear_hud_layer_id() {
  hud_layer_id_ = 0;
  clear_has_hud_layer_id();
}
inline ::google::protobuf::int32 LayerTreeHost::hud_layer_id() const {
  return hud_layer_id_;
}
inline void LayerTreeHost::set_hud_layer_id(::google::protobuf::int32 value) {
  set_has_hud_layer_id();
  hud_layer_id_ = value;
}

// optional .cc.proto.LayerTreeDebugState debug_state = 8;
inline bool LayerTreeHost::has_debug_state() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LayerTreeHost::set_has_debug_state() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LayerTreeHost::clear_has_debug_state() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LayerTreeHost::clear_debug_state() {
  if (debug_state_ != NULL) debug_state_->::cc::proto::LayerTreeDebugState::Clear();
  clear_has_debug_state();
}
inline const ::cc::proto::LayerTreeDebugState& LayerTreeHost::debug_state() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return debug_state_ != NULL ? *debug_state_ : *default_instance().debug_state_;
#else
  return debug_state_ != NULL ? *debug_state_ : *default_instance_->debug_state_;
#endif
}
inline ::cc::proto::LayerTreeDebugState* LayerTreeHost::mutable_debug_state() {
  set_has_debug_state();
  if (debug_state_ == NULL) debug_state_ = new ::cc::proto::LayerTreeDebugState;
  return debug_state_;
}
inline ::cc::proto::LayerTreeDebugState* LayerTreeHost::release_debug_state() {
  clear_has_debug_state();
  ::cc::proto::LayerTreeDebugState* temp = debug_state_;
  debug_state_ = NULL;
  return temp;
}
inline void LayerTreeHost::set_allocated_debug_state(::cc::proto::LayerTreeDebugState* debug_state) {
  delete debug_state_;
  debug_state_ = debug_state;
  if (debug_state) {
    set_has_debug_state();
  } else {
    clear_has_debug_state();
  }
}

// optional .cc.proto.Size device_viewport_size = 9;
inline bool LayerTreeHost::has_device_viewport_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LayerTreeHost::set_has_device_viewport_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LayerTreeHost::clear_has_device_viewport_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LayerTreeHost::clear_device_viewport_size() {
  if (device_viewport_size_ != NULL) device_viewport_size_->::cc::proto::Size::Clear();
  clear_has_device_viewport_size();
}
inline const ::cc::proto::Size& LayerTreeHost::device_viewport_size() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_viewport_size_ != NULL ? *device_viewport_size_ : *default_instance().device_viewport_size_;
#else
  return device_viewport_size_ != NULL ? *device_viewport_size_ : *default_instance_->device_viewport_size_;
#endif
}
inline ::cc::proto::Size* LayerTreeHost::mutable_device_viewport_size() {
  set_has_device_viewport_size();
  if (device_viewport_size_ == NULL) device_viewport_size_ = new ::cc::proto::Size;
  return device_viewport_size_;
}
inline ::cc::proto::Size* LayerTreeHost::release_device_viewport_size() {
  clear_has_device_viewport_size();
  ::cc::proto::Size* temp = device_viewport_size_;
  device_viewport_size_ = NULL;
  return temp;
}
inline void LayerTreeHost::set_allocated_device_viewport_size(::cc::proto::Size* device_viewport_size) {
  delete device_viewport_size_;
  device_viewport_size_ = device_viewport_size;
  if (device_viewport_size) {
    set_has_device_viewport_size();
  } else {
    clear_has_device_viewport_size();
  }
}

// optional bool top_controls_shrink_blink_size = 10;
inline bool LayerTreeHost::has_top_controls_shrink_blink_size() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LayerTreeHost::set_has_top_controls_shrink_blink_size() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LayerTreeHost::clear_has_top_controls_shrink_blink_size() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LayerTreeHost::clear_top_controls_shrink_blink_size() {
  top_controls_shrink_blink_size_ = false;
  clear_has_top_controls_shrink_blink_size();
}
inline bool LayerTreeHost::top_controls_shrink_blink_size() const {
  return top_controls_shrink_blink_size_;
}
inline void LayerTreeHost::set_top_controls_shrink_blink_size(bool value) {
  set_has_top_controls_shrink_blink_size();
  top_controls_shrink_blink_size_ = value;
}

// optional float top_controls_height = 11;
inline bool LayerTreeHost::has_top_controls_height() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LayerTreeHost::set_has_top_controls_height() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LayerTreeHost::clear_has_top_controls_height() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LayerTreeHost::clear_top_controls_height() {
  top_controls_height_ = 0;
  clear_has_top_controls_height();
}
inline float LayerTreeHost::top_controls_height() const {
  return top_controls_height_;
}
inline void LayerTreeHost::set_top_controls_height(float value) {
  set_has_top_controls_height();
  top_controls_height_ = value;
}

// optional float top_controls_shown_ratio = 12;
inline bool LayerTreeHost::has_top_controls_shown_ratio() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LayerTreeHost::set_has_top_controls_shown_ratio() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LayerTreeHost::clear_has_top_controls_shown_ratio() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LayerTreeHost::clear_top_controls_shown_ratio() {
  top_controls_shown_ratio_ = 0;
  clear_has_top_controls_shown_ratio();
}
inline float LayerTreeHost::top_controls_shown_ratio() const {
  return top_controls_shown_ratio_;
}
inline void LayerTreeHost::set_top_controls_shown_ratio(float value) {
  set_has_top_controls_shown_ratio();
  top_controls_shown_ratio_ = value;
}

// optional float device_scale_factor = 13;
inline bool LayerTreeHost::has_device_scale_factor() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LayerTreeHost::set_has_device_scale_factor() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LayerTreeHost::clear_has_device_scale_factor() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LayerTreeHost::clear_device_scale_factor() {
  device_scale_factor_ = 0;
  clear_has_device_scale_factor();
}
inline float LayerTreeHost::device_scale_factor() const {
  return device_scale_factor_;
}
inline void LayerTreeHost::set_device_scale_factor(float value) {
  set_has_device_scale_factor();
  device_scale_factor_ = value;
}

// optional float painted_device_scale_factor = 14;
inline bool LayerTreeHost::has_painted_device_scale_factor() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LayerTreeHost::set_has_painted_device_scale_factor() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LayerTreeHost::clear_has_painted_device_scale_factor() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LayerTreeHost::clear_painted_device_scale_factor() {
  painted_device_scale_factor_ = 0;
  clear_has_painted_device_scale_factor();
}
inline float LayerTreeHost::painted_device_scale_factor() const {
  return painted_device_scale_factor_;
}
inline void LayerTreeHost::set_painted_device_scale_factor(float value) {
  set_has_painted_device_scale_factor();
  painted_device_scale_factor_ = value;
}

// optional float page_scale_factor = 15;
inline bool LayerTreeHost::has_page_scale_factor() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LayerTreeHost::set_has_page_scale_factor() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LayerTreeHost::clear_has_page_scale_factor() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LayerTreeHost::clear_page_scale_factor() {
  page_scale_factor_ = 0;
  clear_has_page_scale_factor();
}
inline float LayerTreeHost::page_scale_factor() const {
  return page_scale_factor_;
}
inline void LayerTreeHost::set_page_scale_factor(float value) {
  set_has_page_scale_factor();
  page_scale_factor_ = value;
}

// optional float min_page_scale_factor = 16;
inline bool LayerTreeHost::has_min_page_scale_factor() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LayerTreeHost::set_has_min_page_scale_factor() {
  _has_bits_[0] |= 0x00008000u;
}
inline void LayerTreeHost::clear_has_min_page_scale_factor() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void LayerTreeHost::clear_min_page_scale_factor() {
  min_page_scale_factor_ = 0;
  clear_has_min_page_scale_factor();
}
inline float LayerTreeHost::min_page_scale_factor() const {
  return min_page_scale_factor_;
}
inline void LayerTreeHost::set_min_page_scale_factor(float value) {
  set_has_min_page_scale_factor();
  min_page_scale_factor_ = value;
}

// optional float max_page_scale_factor = 17;
inline bool LayerTreeHost::has_max_page_scale_factor() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LayerTreeHost::set_has_max_page_scale_factor() {
  _has_bits_[0] |= 0x00010000u;
}
inline void LayerTreeHost::clear_has_max_page_scale_factor() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void LayerTreeHost::clear_max_page_scale_factor() {
  max_page_scale_factor_ = 0;
  clear_has_max_page_scale_factor();
}
inline float LayerTreeHost::max_page_scale_factor() const {
  return max_page_scale_factor_;
}
inline void LayerTreeHost::set_max_page_scale_factor(float value) {
  set_has_max_page_scale_factor();
  max_page_scale_factor_ = value;
}

// optional .cc.proto.Vector2dF elastic_overscroll = 18;
inline bool LayerTreeHost::has_elastic_overscroll() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void LayerTreeHost::set_has_elastic_overscroll() {
  _has_bits_[0] |= 0x00020000u;
}
inline void LayerTreeHost::clear_has_elastic_overscroll() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void LayerTreeHost::clear_elastic_overscroll() {
  if (elastic_overscroll_ != NULL) elastic_overscroll_->::cc::proto::Vector2dF::Clear();
  clear_has_elastic_overscroll();
}
inline const ::cc::proto::Vector2dF& LayerTreeHost::elastic_overscroll() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return elastic_overscroll_ != NULL ? *elastic_overscroll_ : *default_instance().elastic_overscroll_;
#else
  return elastic_overscroll_ != NULL ? *elastic_overscroll_ : *default_instance_->elastic_overscroll_;
#endif
}
inline ::cc::proto::Vector2dF* LayerTreeHost::mutable_elastic_overscroll() {
  set_has_elastic_overscroll();
  if (elastic_overscroll_ == NULL) elastic_overscroll_ = new ::cc::proto::Vector2dF;
  return elastic_overscroll_;
}
inline ::cc::proto::Vector2dF* LayerTreeHost::release_elastic_overscroll() {
  clear_has_elastic_overscroll();
  ::cc::proto::Vector2dF* temp = elastic_overscroll_;
  elastic_overscroll_ = NULL;
  return temp;
}
inline void LayerTreeHost::set_allocated_elastic_overscroll(::cc::proto::Vector2dF* elastic_overscroll) {
  delete elastic_overscroll_;
  elastic_overscroll_ = elastic_overscroll;
  if (elastic_overscroll) {
    set_has_elastic_overscroll();
  } else {
    clear_has_elastic_overscroll();
  }
}

// optional bool has_gpu_rasterization_trigger = 19;
inline bool LayerTreeHost::has_has_gpu_rasterization_trigger() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void LayerTreeHost::set_has_has_gpu_rasterization_trigger() {
  _has_bits_[0] |= 0x00040000u;
}
inline void LayerTreeHost::clear_has_has_gpu_rasterization_trigger() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void LayerTreeHost::clear_has_gpu_rasterization_trigger() {
  has_gpu_rasterization_trigger_ = false;
  clear_has_has_gpu_rasterization_trigger();
}
inline bool LayerTreeHost::has_gpu_rasterization_trigger() const {
  return has_gpu_rasterization_trigger_;
}
inline void LayerTreeHost::set_has_gpu_rasterization_trigger(bool value) {
  set_has_has_gpu_rasterization_trigger();
  has_gpu_rasterization_trigger_ = value;
}

// optional bool content_is_suitable_for_gpu_rasterization = 20;
inline bool LayerTreeHost::has_content_is_suitable_for_gpu_rasterization() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void LayerTreeHost::set_has_content_is_suitable_for_gpu_rasterization() {
  _has_bits_[0] |= 0x00080000u;
}
inline void LayerTreeHost::clear_has_content_is_suitable_for_gpu_rasterization() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void LayerTreeHost::clear_content_is_suitable_for_gpu_rasterization() {
  content_is_suitable_for_gpu_rasterization_ = false;
  clear_has_content_is_suitable_for_gpu_rasterization();
}
inline bool LayerTreeHost::content_is_suitable_for_gpu_rasterization() const {
  return content_is_suitable_for_gpu_rasterization_;
}
inline void LayerTreeHost::set_content_is_suitable_for_gpu_rasterization(bool value) {
  set_has_content_is_suitable_for_gpu_rasterization();
  content_is_suitable_for_gpu_rasterization_ = value;
}

// optional uint32 background_color = 21;
inline bool LayerTreeHost::has_background_color() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void LayerTreeHost::set_has_background_color() {
  _has_bits_[0] |= 0x00100000u;
}
inline void LayerTreeHost::clear_has_background_color() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void LayerTreeHost::clear_background_color() {
  background_color_ = 0u;
  clear_has_background_color();
}
inline ::google::protobuf::uint32 LayerTreeHost::background_color() const {
  return background_color_;
}
inline void LayerTreeHost::set_background_color(::google::protobuf::uint32 value) {
  set_has_background_color();
  background_color_ = value;
}

// optional bool has_transparent_background = 22;
inline bool LayerTreeHost::has_has_transparent_background() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void LayerTreeHost::set_has_has_transparent_background() {
  _has_bits_[0] |= 0x00200000u;
}
inline void LayerTreeHost::clear_has_has_transparent_background() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void LayerTreeHost::clear_has_transparent_background() {
  has_transparent_background_ = false;
  clear_has_has_transparent_background();
}
inline bool LayerTreeHost::has_transparent_background() const {
  return has_transparent_background_;
}
inline void LayerTreeHost::set_has_transparent_background(bool value) {
  set_has_has_transparent_background();
  has_transparent_background_ = value;
}

// optional bool in_paint_layer_contents = 23;
inline bool LayerTreeHost::has_in_paint_layer_contents() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void LayerTreeHost::set_has_in_paint_layer_contents() {
  _has_bits_[0] |= 0x00400000u;
}
inline void LayerTreeHost::clear_has_in_paint_layer_contents() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void LayerTreeHost::clear_in_paint_layer_contents() {
  in_paint_layer_contents_ = false;
  clear_has_in_paint_layer_contents();
}
inline bool LayerTreeHost::in_paint_layer_contents() const {
  return in_paint_layer_contents_;
}
inline void LayerTreeHost::set_in_paint_layer_contents(bool value) {
  set_has_in_paint_layer_contents();
  in_paint_layer_contents_ = value;
}

// optional int32 id = 24;
inline bool LayerTreeHost::has_id() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void LayerTreeHost::set_has_id() {
  _has_bits_[0] |= 0x00800000u;
}
inline void LayerTreeHost::clear_has_id() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void LayerTreeHost::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 LayerTreeHost::id() const {
  return id_;
}
inline void LayerTreeHost::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional bool next_commit_forces_redraw = 25;
inline bool LayerTreeHost::has_next_commit_forces_redraw() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void LayerTreeHost::set_has_next_commit_forces_redraw() {
  _has_bits_[0] |= 0x01000000u;
}
inline void LayerTreeHost::clear_has_next_commit_forces_redraw() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void LayerTreeHost::clear_next_commit_forces_redraw() {
  next_commit_forces_redraw_ = false;
  clear_has_next_commit_forces_redraw();
}
inline bool LayerTreeHost::next_commit_forces_redraw() const {
  return next_commit_forces_redraw_;
}
inline void LayerTreeHost::set_next_commit_forces_redraw(bool value) {
  set_has_next_commit_forces_redraw();
  next_commit_forces_redraw_ = value;
}

// optional int32 overscroll_elasticity_layer_id = 26;
inline bool LayerTreeHost::has_overscroll_elasticity_layer_id() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void LayerTreeHost::set_has_overscroll_elasticity_layer_id() {
  _has_bits_[0] |= 0x02000000u;
}
inline void LayerTreeHost::clear_has_overscroll_elasticity_layer_id() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void LayerTreeHost::clear_overscroll_elasticity_layer_id() {
  overscroll_elasticity_layer_id_ = 0;
  clear_has_overscroll_elasticity_layer_id();
}
inline ::google::protobuf::int32 LayerTreeHost::overscroll_elasticity_layer_id() const {
  return overscroll_elasticity_layer_id_;
}
inline void LayerTreeHost::set_overscroll_elasticity_layer_id(::google::protobuf::int32 value) {
  set_has_overscroll_elasticity_layer_id();
  overscroll_elasticity_layer_id_ = value;
}

// optional int32 page_scale_layer_id = 27;
inline bool LayerTreeHost::has_page_scale_layer_id() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void LayerTreeHost::set_has_page_scale_layer_id() {
  _has_bits_[0] |= 0x04000000u;
}
inline void LayerTreeHost::clear_has_page_scale_layer_id() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void LayerTreeHost::clear_page_scale_layer_id() {
  page_scale_layer_id_ = 0;
  clear_has_page_scale_layer_id();
}
inline ::google::protobuf::int32 LayerTreeHost::page_scale_layer_id() const {
  return page_scale_layer_id_;
}
inline void LayerTreeHost::set_page_scale_layer_id(::google::protobuf::int32 value) {
  set_has_page_scale_layer_id();
  page_scale_layer_id_ = value;
}

// optional int32 inner_viewport_scroll_layer_id = 28;
inline bool LayerTreeHost::has_inner_viewport_scroll_layer_id() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void LayerTreeHost::set_has_inner_viewport_scroll_layer_id() {
  _has_bits_[0] |= 0x08000000u;
}
inline void LayerTreeHost::clear_has_inner_viewport_scroll_layer_id() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void LayerTreeHost::clear_inner_viewport_scroll_layer_id() {
  inner_viewport_scroll_layer_id_ = 0;
  clear_has_inner_viewport_scroll_layer_id();
}
inline ::google::protobuf::int32 LayerTreeHost::inner_viewport_scroll_layer_id() const {
  return inner_viewport_scroll_layer_id_;
}
inline void LayerTreeHost::set_inner_viewport_scroll_layer_id(::google::protobuf::int32 value) {
  set_has_inner_viewport_scroll_layer_id();
  inner_viewport_scroll_layer_id_ = value;
}

// optional int32 outer_viewport_scroll_layer_id = 29;
inline bool LayerTreeHost::has_outer_viewport_scroll_layer_id() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void LayerTreeHost::set_has_outer_viewport_scroll_layer_id() {
  _has_bits_[0] |= 0x10000000u;
}
inline void LayerTreeHost::clear_has_outer_viewport_scroll_layer_id() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void LayerTreeHost::clear_outer_viewport_scroll_layer_id() {
  outer_viewport_scroll_layer_id_ = 0;
  clear_has_outer_viewport_scroll_layer_id();
}
inline ::google::protobuf::int32 LayerTreeHost::outer_viewport_scroll_layer_id() const {
  return outer_viewport_scroll_layer_id_;
}
inline void LayerTreeHost::set_outer_viewport_scroll_layer_id(::google::protobuf::int32 value) {
  set_has_outer_viewport_scroll_layer_id();
  outer_viewport_scroll_layer_id_ = value;
}

// optional .cc.proto.LayerSelection selection = 30;
inline bool LayerTreeHost::has_selection() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void LayerTreeHost::set_has_selection() {
  _has_bits_[0] |= 0x20000000u;
}
inline void LayerTreeHost::clear_has_selection() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void LayerTreeHost::clear_selection() {
  if (selection_ != NULL) selection_->::cc::proto::LayerSelection::Clear();
  clear_has_selection();
}
inline const ::cc::proto::LayerSelection& LayerTreeHost::selection() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return selection_ != NULL ? *selection_ : *default_instance().selection_;
#else
  return selection_ != NULL ? *selection_ : *default_instance_->selection_;
#endif
}
inline ::cc::proto::LayerSelection* LayerTreeHost::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) selection_ = new ::cc::proto::LayerSelection;
  return selection_;
}
inline ::cc::proto::LayerSelection* LayerTreeHost::release_selection() {
  clear_has_selection();
  ::cc::proto::LayerSelection* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline void LayerTreeHost::set_allocated_selection(::cc::proto::LayerSelection* selection) {
  delete selection_;
  selection_ = selection;
  if (selection) {
    set_has_selection();
  } else {
    clear_has_selection();
  }
}

// optional .cc.proto.PropertyTrees property_trees = 31;
inline bool LayerTreeHost::has_property_trees() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void LayerTreeHost::set_has_property_trees() {
  _has_bits_[0] |= 0x40000000u;
}
inline void LayerTreeHost::clear_has_property_trees() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void LayerTreeHost::clear_property_trees() {
  if (property_trees_ != NULL) property_trees_->::cc::proto::PropertyTrees::Clear();
  clear_has_property_trees();
}
inline const ::cc::proto::PropertyTrees& LayerTreeHost::property_trees() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return property_trees_ != NULL ? *property_trees_ : *default_instance().property_trees_;
#else
  return property_trees_ != NULL ? *property_trees_ : *default_instance_->property_trees_;
#endif
}
inline ::cc::proto::PropertyTrees* LayerTreeHost::mutable_property_trees() {
  set_has_property_trees();
  if (property_trees_ == NULL) property_trees_ = new ::cc::proto::PropertyTrees;
  return property_trees_;
}
inline ::cc::proto::PropertyTrees* LayerTreeHost::release_property_trees() {
  clear_has_property_trees();
  ::cc::proto::PropertyTrees* temp = property_trees_;
  property_trees_ = NULL;
  return temp;
}
inline void LayerTreeHost::set_allocated_property_trees(::cc::proto::PropertyTrees* property_trees) {
  delete property_trees_;
  property_trees_ = property_trees;
  if (property_trees) {
    set_has_property_trees();
  } else {
    clear_has_property_trees();
  }
}

// optional uint32 surface_id_namespace = 32;
inline bool LayerTreeHost::has_surface_id_namespace() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void LayerTreeHost::set_has_surface_id_namespace() {
  _has_bits_[0] |= 0x80000000u;
}
inline void LayerTreeHost::clear_has_surface_id_namespace() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void LayerTreeHost::clear_surface_id_namespace() {
  surface_id_namespace_ = 0u;
  clear_has_surface_id_namespace();
}
inline ::google::protobuf::uint32 LayerTreeHost::surface_id_namespace() const {
  return surface_id_namespace_;
}
inline void LayerTreeHost::set_surface_id_namespace(::google::protobuf::uint32 value) {
  set_has_surface_id_namespace();
  surface_id_namespace_ = value;
}

// optional uint32 next_surface_sequence = 33;
inline bool LayerTreeHost::has_next_surface_sequence() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void LayerTreeHost::set_has_next_surface_sequence() {
  _has_bits_[1] |= 0x00000001u;
}
inline void LayerTreeHost::clear_has_next_surface_sequence() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void LayerTreeHost::clear_next_surface_sequence() {
  next_surface_sequence_ = 0u;
  clear_has_next_surface_sequence();
}
inline ::google::protobuf::uint32 LayerTreeHost::next_surface_sequence() const {
  return next_surface_sequence_;
}
inline void LayerTreeHost::set_next_surface_sequence(::google::protobuf::uint32 value) {
  set_has_next_surface_sequence();
  next_surface_sequence_ = value;
}

// optional bool have_wheel_event_handlers = 34;
inline bool LayerTreeHost::has_have_wheel_event_handlers() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void LayerTreeHost::set_has_have_wheel_event_handlers() {
  _has_bits_[1] |= 0x00000002u;
}
inline void LayerTreeHost::clear_has_have_wheel_event_handlers() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void LayerTreeHost::clear_have_wheel_event_handlers() {
  have_wheel_event_handlers_ = false;
  clear_has_have_wheel_event_handlers();
}
inline bool LayerTreeHost::have_wheel_event_handlers() const {
  return have_wheel_event_handlers_;
}
inline void LayerTreeHost::set_have_wheel_event_handlers(bool value) {
  set_has_have_wheel_event_handlers();
  have_wheel_event_handlers_ = value;
}

// optional bool have_scroll_event_handlers = 35;
inline bool LayerTreeHost::has_have_scroll_event_handlers() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void LayerTreeHost::set_has_have_scroll_event_handlers() {
  _has_bits_[1] |= 0x00000004u;
}
inline void LayerTreeHost::clear_has_have_scroll_event_handlers() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void LayerTreeHost::clear_have_scroll_event_handlers() {
  have_scroll_event_handlers_ = false;
  clear_has_have_scroll_event_handlers();
}
inline bool LayerTreeHost::have_scroll_event_handlers() const {
  return have_scroll_event_handlers_;
}
inline void LayerTreeHost::set_have_scroll_event_handlers(bool value) {
  set_has_have_scroll_event_handlers();
  have_scroll_event_handlers_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_layer_5ftree_5fhost_2eproto__INCLUDED
