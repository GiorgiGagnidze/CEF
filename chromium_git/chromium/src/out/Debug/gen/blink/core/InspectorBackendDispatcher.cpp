// File is generated by Source/core/inspector/CodeGeneratorInspector.py

// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


#include "InspectorBackendDispatcher.h"

#include "core/inspector/InspectorFrontendChannel.h"
#include "platform/JSONParser.h"
#include "platform/JSONValues.h"
#include "wtf/text/CString.h"
#include "wtf/text/WTFString.h"

namespace blink {

const char InspectorBackendDispatcher::commandNames[] = {
    "Inspector.enable\0"
    "Inspector.disable\0"
    "Memory.getDOMCounters\0"
    "Page.enable\0"
    "Page.disable\0"
    "Page.addScriptToEvaluateOnLoad\0"
    "Page.removeScriptToEvaluateOnLoad\0"
    "Page.setAutoAttachToCreatedPages\0"
    "Page.reload\0"
    "Page.navigate\0"
    "Page.getResourceTree\0"
    "Page.getResourceContent\0"
    "Page.searchInResource\0"
    "Page.setDocumentContent\0"
    "Page.setDeviceOrientationOverride\0"
    "Page.clearDeviceOrientationOverride\0"
    "Page.setTouchEmulationEnabled\0"
    "Page.startScreencast\0"
    "Page.stopScreencast\0"
    "Page.setOverlayMessage\0"
    "Rendering.setShowPaintRects\0"
    "Rendering.setShowDebugBorders\0"
    "Rendering.setShowFPSCounter\0"
    "Rendering.setShowScrollBottleneckRects\0"
    "Emulation.resetPageScaleFactor\0"
    "Emulation.setPageScaleFactor\0"
    "Emulation.setScriptExecutionDisabled\0"
    "Emulation.setTouchEmulationEnabled\0"
    "Emulation.setEmulatedMedia\0"
    "Emulation.setCPUThrottlingRate\0"
    "Runtime.evaluate\0"
    "Runtime.callFunctionOn\0"
    "Runtime.getProperties\0"
    "Runtime.releaseObject\0"
    "Runtime.releaseObjectGroup\0"
    "Runtime.run\0"
    "Runtime.enable\0"
    "Runtime.disable\0"
    "Runtime.isRunRequired\0"
    "Runtime.setCustomObjectFormatterEnabled\0"
    "Runtime.compileScript\0"
    "Runtime.runScript\0"
    "Console.enable\0"
    "Console.disable\0"
    "Console.clearMessages\0"
    "Network.enable\0"
    "Network.disable\0"
    "Network.setUserAgentOverride\0"
    "Network.setExtraHTTPHeaders\0"
    "Network.getResponseBody\0"
    "Network.addBlockedURL\0"
    "Network.removeBlockedURL\0"
    "Network.replayXHR\0"
    "Network.setMonitoringXHREnabled\0"
    "Network.canClearBrowserCache\0"
    "Network.canClearBrowserCookies\0"
    "Network.emulateNetworkConditions\0"
    "Network.setCacheDisabled\0"
    "Network.setDataSizeLimitsForTest\0"
    "Database.enable\0"
    "Database.disable\0"
    "Database.getDatabaseTableNames\0"
    "Database.executeSQL\0"
    "IndexedDB.enable\0"
    "IndexedDB.disable\0"
    "IndexedDB.requestDatabaseNames\0"
    "IndexedDB.requestDatabase\0"
    "IndexedDB.requestData\0"
    "IndexedDB.clearObjectStore\0"
    "CacheStorage.requestCacheNames\0"
    "CacheStorage.requestEntries\0"
    "CacheStorage.deleteCache\0"
    "CacheStorage.deleteEntry\0"
    "DOMStorage.enable\0"
    "DOMStorage.disable\0"
    "DOMStorage.getDOMStorageItems\0"
    "DOMStorage.setDOMStorageItem\0"
    "DOMStorage.removeDOMStorageItem\0"
    "ApplicationCache.getFramesWithManifests\0"
    "ApplicationCache.enable\0"
    "ApplicationCache.getManifestForFrame\0"
    "ApplicationCache.getApplicationCacheForFrame\0"
    "FileSystem.enable\0"
    "FileSystem.disable\0"
    "FileSystem.requestFileSystemRoot\0"
    "FileSystem.requestDirectoryContent\0"
    "FileSystem.requestMetadata\0"
    "FileSystem.requestFileContent\0"
    "FileSystem.deleteEntry\0"
    "DOM.enable\0"
    "DOM.disable\0"
    "DOM.getDocument\0"
    "DOM.requestChildNodes\0"
    "DOM.querySelector\0"
    "DOM.querySelectorAll\0"
    "DOM.setNodeName\0"
    "DOM.setNodeValue\0"
    "DOM.removeNode\0"
    "DOM.setAttributeValue\0"
    "DOM.setAttributesAsText\0"
    "DOM.removeAttribute\0"
    "DOM.getOuterHTML\0"
    "DOM.setOuterHTML\0"
    "DOM.performSearch\0"
    "DOM.getSearchResults\0"
    "DOM.discardSearchResults\0"
    "DOM.requestNode\0"
    "DOM.setInspectMode\0"
    "DOM.highlightRect\0"
    "DOM.highlightQuad\0"
    "DOM.highlightNode\0"
    "DOM.hideHighlight\0"
    "DOM.highlightFrame\0"
    "DOM.pushNodeByPathToFrontend\0"
    "DOM.pushNodesByBackendIdsToFrontend\0"
    "DOM.setInspectedNode\0"
    "DOM.resolveNode\0"
    "DOM.getAttributes\0"
    "DOM.copyTo\0"
    "DOM.moveTo\0"
    "DOM.undo\0"
    "DOM.redo\0"
    "DOM.markUndoableState\0"
    "DOM.focus\0"
    "DOM.setFileInputFiles\0"
    "DOM.getBoxModel\0"
    "DOM.getNodeForLocation\0"
    "DOM.getRelayoutBoundary\0"
    "DOM.getHighlightObjectForTest\0"
    "CSS.enable\0"
    "CSS.disable\0"
    "CSS.getMatchedStylesForNode\0"
    "CSS.getInlineStylesForNode\0"
    "CSS.getComputedStyleForNode\0"
    "CSS.getPlatformFontsForNode\0"
    "CSS.getStyleSheetText\0"
    "CSS.setStyleSheetText\0"
    "CSS.setRuleSelector\0"
    "CSS.setKeyframeKey\0"
    "CSS.setStyleText\0"
    "CSS.setMediaText\0"
    "CSS.createStyleSheet\0"
    "CSS.addRule\0"
    "CSS.forcePseudoState\0"
    "CSS.getMediaQueries\0"
    "CSS.setEffectivePropertyValueForNode\0"
    "CSS.getBackgroundColors\0"
    "Debugger.enable\0"
    "Debugger.disable\0"
    "Debugger.setBreakpointsActive\0"
    "Debugger.setSkipAllPauses\0"
    "Debugger.setBreakpointByUrl\0"
    "Debugger.setBreakpoint\0"
    "Debugger.removeBreakpoint\0"
    "Debugger.continueToLocation\0"
    "Debugger.stepOver\0"
    "Debugger.stepInto\0"
    "Debugger.stepOut\0"
    "Debugger.pause\0"
    "Debugger.resume\0"
    "Debugger.stepIntoAsync\0"
    "Debugger.searchInContent\0"
    "Debugger.canSetScriptSource\0"
    "Debugger.setScriptSource\0"
    "Debugger.restartFrame\0"
    "Debugger.getScriptSource\0"
    "Debugger.getFunctionDetails\0"
    "Debugger.getGeneratorObjectDetails\0"
    "Debugger.getCollectionEntries\0"
    "Debugger.setPauseOnExceptions\0"
    "Debugger.evaluateOnCallFrame\0"
    "Debugger.setVariableValue\0"
    "Debugger.getStepInPositions\0"
    "Debugger.getBacktrace\0"
    "Debugger.setAsyncCallStackDepth\0"
    "Debugger.enablePromiseTracker\0"
    "Debugger.disablePromiseTracker\0"
    "Debugger.getPromiseById\0"
    "Debugger.flushAsyncOperationEvents\0"
    "Debugger.setAsyncOperationBreakpoint\0"
    "Debugger.removeAsyncOperationBreakpoint\0"
    "Debugger.setBlackboxedRanges\0"
    "DOMDebugger.setDOMBreakpoint\0"
    "DOMDebugger.removeDOMBreakpoint\0"
    "DOMDebugger.setEventListenerBreakpoint\0"
    "DOMDebugger.removeEventListenerBreakpoint\0"
    "DOMDebugger.setInstrumentationBreakpoint\0"
    "DOMDebugger.removeInstrumentationBreakpoint\0"
    "DOMDebugger.setXHRBreakpoint\0"
    "DOMDebugger.removeXHRBreakpoint\0"
    "DOMDebugger.getEventListeners\0"
    "Profiler.enable\0"
    "Profiler.disable\0"
    "Profiler.setSamplingInterval\0"
    "Profiler.start\0"
    "Profiler.stop\0"
    "HeapProfiler.enable\0"
    "HeapProfiler.disable\0"
    "HeapProfiler.startTrackingHeapObjects\0"
    "HeapProfiler.stopTrackingHeapObjects\0"
    "HeapProfiler.takeHeapSnapshot\0"
    "HeapProfiler.collectGarbage\0"
    "HeapProfiler.getObjectByHeapObjectId\0"
    "HeapProfiler.addInspectedHeapObject\0"
    "HeapProfiler.getHeapObjectId\0"
    "Worker.enable\0"
    "Worker.disable\0"
    "Worker.sendMessageToWorker\0"
    "Worker.connectToWorker\0"
    "Worker.disconnectFromWorker\0"
    "Worker.setAutoconnectToWorkers\0"
    "Input.dispatchTouchEvent\0"
    "LayerTree.enable\0"
    "LayerTree.disable\0"
    "LayerTree.compositingReasons\0"
    "LayerTree.makeSnapshot\0"
    "LayerTree.loadSnapshot\0"
    "LayerTree.releaseSnapshot\0"
    "LayerTree.profileSnapshot\0"
    "LayerTree.replaySnapshot\0"
    "LayerTree.snapshotCommandLog\0"
    "DeviceOrientation.setDeviceOrientationOverride\0"
    "DeviceOrientation.clearDeviceOrientationOverride\0"
    "ScreenOrientation.setScreenOrientationOverride\0"
    "ScreenOrientation.clearScreenOrientationOverride\0"
    "Tracing.start\0"
    "Tracing.end\0"
    "Animation.enable\0"
    "Animation.disable\0"
    "Animation.getPlaybackRate\0"
    "Animation.setPlaybackRate\0"
    "Animation.getCurrentTime\0"
    "Animation.setPaused\0"
    "Animation.setTiming\0"
    "Animation.seekAnimations\0"
    "Animation.releaseAnimations\0"
    "Animation.resolveAnimation\0"
    "Accessibility.getAXNode\0"
};

const unsigned short InspectorBackendDispatcher::commandNamesIndex[] = {
    0,
    17,
    35,
    57,
    69,
    82,
    113,
    147,
    180,
    192,
    206,
    227,
    251,
    273,
    297,
    331,
    367,
    397,
    418,
    438,
    461,
    489,
    519,
    547,
    586,
    617,
    646,
    683,
    718,
    745,
    776,
    793,
    816,
    838,
    860,
    887,
    899,
    914,
    930,
    952,
    992,
    1014,
    1032,
    1047,
    1063,
    1085,
    1100,
    1116,
    1145,
    1173,
    1197,
    1219,
    1244,
    1262,
    1294,
    1323,
    1354,
    1387,
    1412,
    1445,
    1461,
    1478,
    1509,
    1529,
    1546,
    1564,
    1595,
    1621,
    1643,
    1670,
    1701,
    1729,
    1754,
    1779,
    1797,
    1816,
    1846,
    1875,
    1907,
    1947,
    1971,
    2008,
    2053,
    2071,
    2090,
    2123,
    2158,
    2185,
    2215,
    2238,
    2249,
    2261,
    2277,
    2299,
    2317,
    2338,
    2354,
    2371,
    2386,
    2408,
    2432,
    2452,
    2469,
    2486,
    2504,
    2525,
    2550,
    2566,
    2585,
    2603,
    2621,
    2639,
    2657,
    2676,
    2705,
    2741,
    2762,
    2778,
    2796,
    2807,
    2818,
    2827,
    2836,
    2858,
    2868,
    2890,
    2906,
    2929,
    2953,
    2983,
    2994,
    3006,
    3034,
    3061,
    3089,
    3117,
    3139,
    3161,
    3181,
    3200,
    3217,
    3234,
    3255,
    3267,
    3288,
    3308,
    3345,
    3369,
    3385,
    3402,
    3432,
    3458,
    3486,
    3509,
    3535,
    3563,
    3581,
    3599,
    3616,
    3631,
    3647,
    3670,
    3695,
    3723,
    3748,
    3770,
    3795,
    3823,
    3858,
    3888,
    3918,
    3947,
    3973,
    4001,
    4023,
    4055,
    4085,
    4116,
    4140,
    4175,
    4212,
    4252,
    4281,
    4310,
    4342,
    4381,
    4423,
    4464,
    4508,
    4537,
    4569,
    4599,
    4615,
    4632,
    4661,
    4676,
    4690,
    4710,
    4731,
    4769,
    4806,
    4836,
    4864,
    4901,
    4937,
    4966,
    4980,
    4995,
    5022,
    5045,
    5073,
    5104,
    5129,
    5146,
    5164,
    5193,
    5216,
    5239,
    5265,
    5291,
    5316,
    5345,
    5392,
    5441,
    5488,
    5537,
    5551,
    5563,
    5580,
    5598,
    5624,
    5650,
    5675,
    5695,
    5715,
    5740,
    5768,
    5795,
};

const char* InspectorBackendDispatcher::commandName(MethodNames index) {
    static_assert(static_cast<int>(kMethodNamesEnumSize) == WTF_ARRAY_LENGTH(commandNamesIndex), "MethodNames enum should have the same number of elements as commandNamesIndex");
    return commandNames + commandNamesIndex[index];
}

class InspectorBackendDispatcherImpl : public InspectorBackendDispatcher {
public:
    InspectorBackendDispatcherImpl(InspectorFrontendChannel* inspectorFrontendChannel)
        : m_inspectorFrontendChannel(inspectorFrontendChannel)
        , m_inspectorAgent(0)
        , m_memoryAgent(0)
        , m_pageAgent(0)
        , m_renderingAgent(0)
        , m_emulationAgent(0)
        , m_runtimeAgent(0)
        , m_consoleAgent(0)
        , m_securityAgent(0)
        , m_networkAgent(0)
        , m_databaseAgent(0)
        , m_indexedDBAgent(0)
        , m_cacheStorageAgent(0)
        , m_domStorageAgent(0)
        , m_applicationCacheAgent(0)
        , m_fileSystemAgent(0)
        , m_domAgent(0)
        , m_cssAgent(0)
        , m_ioAgent(0)
        , m_debuggerAgent(0)
        , m_domDebuggerAgent(0)
        , m_profilerAgent(0)
        , m_heapProfilerAgent(0)
        , m_workerAgent(0)
        , m_serviceWorkerAgent(0)
        , m_inputAgent(0)
        , m_layerTreeAgent(0)
        , m_deviceOrientationAgent(0)
        , m_screenOrientationAgent(0)
        , m_tracingAgent(0)
        , m_animationAgent(0)
        , m_accessibilityAgent(0)
    {
        // Initialize dispatch map.
        const CallHandler handlers[] = {
              &InspectorBackendDispatcherImpl::Inspector_enable,
            &InspectorBackendDispatcherImpl::Inspector_disable,
            &InspectorBackendDispatcherImpl::Memory_getDOMCounters,
            &InspectorBackendDispatcherImpl::Page_enable,
            &InspectorBackendDispatcherImpl::Page_disable,
            &InspectorBackendDispatcherImpl::Page_addScriptToEvaluateOnLoad,
            &InspectorBackendDispatcherImpl::Page_removeScriptToEvaluateOnLoad,
            &InspectorBackendDispatcherImpl::Page_setAutoAttachToCreatedPages,
            &InspectorBackendDispatcherImpl::Page_reload,
            &InspectorBackendDispatcherImpl::Page_navigate,
            &InspectorBackendDispatcherImpl::Page_getResourceTree,
            &InspectorBackendDispatcherImpl::Page_getResourceContent,
            &InspectorBackendDispatcherImpl::Page_searchInResource,
            &InspectorBackendDispatcherImpl::Page_setDocumentContent,
            &InspectorBackendDispatcherImpl::Page_setDeviceOrientationOverride,
            &InspectorBackendDispatcherImpl::Page_clearDeviceOrientationOverride,
            &InspectorBackendDispatcherImpl::Page_setTouchEmulationEnabled,
            &InspectorBackendDispatcherImpl::Page_startScreencast,
            &InspectorBackendDispatcherImpl::Page_stopScreencast,
            &InspectorBackendDispatcherImpl::Page_setOverlayMessage,
            &InspectorBackendDispatcherImpl::Rendering_setShowPaintRects,
            &InspectorBackendDispatcherImpl::Rendering_setShowDebugBorders,
            &InspectorBackendDispatcherImpl::Rendering_setShowFPSCounter,
            &InspectorBackendDispatcherImpl::Rendering_setShowScrollBottleneckRects,
            &InspectorBackendDispatcherImpl::Emulation_resetPageScaleFactor,
            &InspectorBackendDispatcherImpl::Emulation_setPageScaleFactor,
            &InspectorBackendDispatcherImpl::Emulation_setScriptExecutionDisabled,
            &InspectorBackendDispatcherImpl::Emulation_setTouchEmulationEnabled,
            &InspectorBackendDispatcherImpl::Emulation_setEmulatedMedia,
            &InspectorBackendDispatcherImpl::Emulation_setCPUThrottlingRate,
            &InspectorBackendDispatcherImpl::Runtime_evaluate,
            &InspectorBackendDispatcherImpl::Runtime_callFunctionOn,
            &InspectorBackendDispatcherImpl::Runtime_getProperties,
            &InspectorBackendDispatcherImpl::Runtime_releaseObject,
            &InspectorBackendDispatcherImpl::Runtime_releaseObjectGroup,
            &InspectorBackendDispatcherImpl::Runtime_run,
            &InspectorBackendDispatcherImpl::Runtime_enable,
            &InspectorBackendDispatcherImpl::Runtime_disable,
            &InspectorBackendDispatcherImpl::Runtime_isRunRequired,
            &InspectorBackendDispatcherImpl::Runtime_setCustomObjectFormatterEnabled,
            &InspectorBackendDispatcherImpl::Runtime_compileScript,
            &InspectorBackendDispatcherImpl::Runtime_runScript,
            &InspectorBackendDispatcherImpl::Console_enable,
            &InspectorBackendDispatcherImpl::Console_disable,
            &InspectorBackendDispatcherImpl::Console_clearMessages,
            &InspectorBackendDispatcherImpl::Network_enable,
            &InspectorBackendDispatcherImpl::Network_disable,
            &InspectorBackendDispatcherImpl::Network_setUserAgentOverride,
            &InspectorBackendDispatcherImpl::Network_setExtraHTTPHeaders,
            &InspectorBackendDispatcherImpl::Network_getResponseBody,
            &InspectorBackendDispatcherImpl::Network_addBlockedURL,
            &InspectorBackendDispatcherImpl::Network_removeBlockedURL,
            &InspectorBackendDispatcherImpl::Network_replayXHR,
            &InspectorBackendDispatcherImpl::Network_setMonitoringXHREnabled,
            &InspectorBackendDispatcherImpl::Network_canClearBrowserCache,
            &InspectorBackendDispatcherImpl::Network_canClearBrowserCookies,
            &InspectorBackendDispatcherImpl::Network_emulateNetworkConditions,
            &InspectorBackendDispatcherImpl::Network_setCacheDisabled,
            &InspectorBackendDispatcherImpl::Network_setDataSizeLimitsForTest,
            &InspectorBackendDispatcherImpl::Database_enable,
            &InspectorBackendDispatcherImpl::Database_disable,
            &InspectorBackendDispatcherImpl::Database_getDatabaseTableNames,
            &InspectorBackendDispatcherImpl::Database_executeSQL,
            &InspectorBackendDispatcherImpl::IndexedDB_enable,
            &InspectorBackendDispatcherImpl::IndexedDB_disable,
            &InspectorBackendDispatcherImpl::IndexedDB_requestDatabaseNames,
            &InspectorBackendDispatcherImpl::IndexedDB_requestDatabase,
            &InspectorBackendDispatcherImpl::IndexedDB_requestData,
            &InspectorBackendDispatcherImpl::IndexedDB_clearObjectStore,
            &InspectorBackendDispatcherImpl::CacheStorage_requestCacheNames,
            &InspectorBackendDispatcherImpl::CacheStorage_requestEntries,
            &InspectorBackendDispatcherImpl::CacheStorage_deleteCache,
            &InspectorBackendDispatcherImpl::CacheStorage_deleteEntry,
            &InspectorBackendDispatcherImpl::DOMStorage_enable,
            &InspectorBackendDispatcherImpl::DOMStorage_disable,
            &InspectorBackendDispatcherImpl::DOMStorage_getDOMStorageItems,
            &InspectorBackendDispatcherImpl::DOMStorage_setDOMStorageItem,
            &InspectorBackendDispatcherImpl::DOMStorage_removeDOMStorageItem,
            &InspectorBackendDispatcherImpl::ApplicationCache_getFramesWithManifests,
            &InspectorBackendDispatcherImpl::ApplicationCache_enable,
            &InspectorBackendDispatcherImpl::ApplicationCache_getManifestForFrame,
            &InspectorBackendDispatcherImpl::ApplicationCache_getApplicationCacheForFrame,
            &InspectorBackendDispatcherImpl::FileSystem_enable,
            &InspectorBackendDispatcherImpl::FileSystem_disable,
            &InspectorBackendDispatcherImpl::FileSystem_requestFileSystemRoot,
            &InspectorBackendDispatcherImpl::FileSystem_requestDirectoryContent,
            &InspectorBackendDispatcherImpl::FileSystem_requestMetadata,
            &InspectorBackendDispatcherImpl::FileSystem_requestFileContent,
            &InspectorBackendDispatcherImpl::FileSystem_deleteEntry,
            &InspectorBackendDispatcherImpl::DOM_enable,
            &InspectorBackendDispatcherImpl::DOM_disable,
            &InspectorBackendDispatcherImpl::DOM_getDocument,
            &InspectorBackendDispatcherImpl::DOM_requestChildNodes,
            &InspectorBackendDispatcherImpl::DOM_querySelector,
            &InspectorBackendDispatcherImpl::DOM_querySelectorAll,
            &InspectorBackendDispatcherImpl::DOM_setNodeName,
            &InspectorBackendDispatcherImpl::DOM_setNodeValue,
            &InspectorBackendDispatcherImpl::DOM_removeNode,
            &InspectorBackendDispatcherImpl::DOM_setAttributeValue,
            &InspectorBackendDispatcherImpl::DOM_setAttributesAsText,
            &InspectorBackendDispatcherImpl::DOM_removeAttribute,
            &InspectorBackendDispatcherImpl::DOM_getOuterHTML,
            &InspectorBackendDispatcherImpl::DOM_setOuterHTML,
            &InspectorBackendDispatcherImpl::DOM_performSearch,
            &InspectorBackendDispatcherImpl::DOM_getSearchResults,
            &InspectorBackendDispatcherImpl::DOM_discardSearchResults,
            &InspectorBackendDispatcherImpl::DOM_requestNode,
            &InspectorBackendDispatcherImpl::DOM_setInspectMode,
            &InspectorBackendDispatcherImpl::DOM_highlightRect,
            &InspectorBackendDispatcherImpl::DOM_highlightQuad,
            &InspectorBackendDispatcherImpl::DOM_highlightNode,
            &InspectorBackendDispatcherImpl::DOM_hideHighlight,
            &InspectorBackendDispatcherImpl::DOM_highlightFrame,
            &InspectorBackendDispatcherImpl::DOM_pushNodeByPathToFrontend,
            &InspectorBackendDispatcherImpl::DOM_pushNodesByBackendIdsToFrontend,
            &InspectorBackendDispatcherImpl::DOM_setInspectedNode,
            &InspectorBackendDispatcherImpl::DOM_resolveNode,
            &InspectorBackendDispatcherImpl::DOM_getAttributes,
            &InspectorBackendDispatcherImpl::DOM_copyTo,
            &InspectorBackendDispatcherImpl::DOM_moveTo,
            &InspectorBackendDispatcherImpl::DOM_undo,
            &InspectorBackendDispatcherImpl::DOM_redo,
            &InspectorBackendDispatcherImpl::DOM_markUndoableState,
            &InspectorBackendDispatcherImpl::DOM_focus,
            &InspectorBackendDispatcherImpl::DOM_setFileInputFiles,
            &InspectorBackendDispatcherImpl::DOM_getBoxModel,
            &InspectorBackendDispatcherImpl::DOM_getNodeForLocation,
            &InspectorBackendDispatcherImpl::DOM_getRelayoutBoundary,
            &InspectorBackendDispatcherImpl::DOM_getHighlightObjectForTest,
            &InspectorBackendDispatcherImpl::CSS_enable,
            &InspectorBackendDispatcherImpl::CSS_disable,
            &InspectorBackendDispatcherImpl::CSS_getMatchedStylesForNode,
            &InspectorBackendDispatcherImpl::CSS_getInlineStylesForNode,
            &InspectorBackendDispatcherImpl::CSS_getComputedStyleForNode,
            &InspectorBackendDispatcherImpl::CSS_getPlatformFontsForNode,
            &InspectorBackendDispatcherImpl::CSS_getStyleSheetText,
            &InspectorBackendDispatcherImpl::CSS_setStyleSheetText,
            &InspectorBackendDispatcherImpl::CSS_setRuleSelector,
            &InspectorBackendDispatcherImpl::CSS_setKeyframeKey,
            &InspectorBackendDispatcherImpl::CSS_setStyleText,
            &InspectorBackendDispatcherImpl::CSS_setMediaText,
            &InspectorBackendDispatcherImpl::CSS_createStyleSheet,
            &InspectorBackendDispatcherImpl::CSS_addRule,
            &InspectorBackendDispatcherImpl::CSS_forcePseudoState,
            &InspectorBackendDispatcherImpl::CSS_getMediaQueries,
            &InspectorBackendDispatcherImpl::CSS_setEffectivePropertyValueForNode,
            &InspectorBackendDispatcherImpl::CSS_getBackgroundColors,
            &InspectorBackendDispatcherImpl::Debugger_enable,
            &InspectorBackendDispatcherImpl::Debugger_disable,
            &InspectorBackendDispatcherImpl::Debugger_setBreakpointsActive,
            &InspectorBackendDispatcherImpl::Debugger_setSkipAllPauses,
            &InspectorBackendDispatcherImpl::Debugger_setBreakpointByUrl,
            &InspectorBackendDispatcherImpl::Debugger_setBreakpoint,
            &InspectorBackendDispatcherImpl::Debugger_removeBreakpoint,
            &InspectorBackendDispatcherImpl::Debugger_continueToLocation,
            &InspectorBackendDispatcherImpl::Debugger_stepOver,
            &InspectorBackendDispatcherImpl::Debugger_stepInto,
            &InspectorBackendDispatcherImpl::Debugger_stepOut,
            &InspectorBackendDispatcherImpl::Debugger_pause,
            &InspectorBackendDispatcherImpl::Debugger_resume,
            &InspectorBackendDispatcherImpl::Debugger_stepIntoAsync,
            &InspectorBackendDispatcherImpl::Debugger_searchInContent,
            &InspectorBackendDispatcherImpl::Debugger_canSetScriptSource,
            &InspectorBackendDispatcherImpl::Debugger_setScriptSource,
            &InspectorBackendDispatcherImpl::Debugger_restartFrame,
            &InspectorBackendDispatcherImpl::Debugger_getScriptSource,
            &InspectorBackendDispatcherImpl::Debugger_getFunctionDetails,
            &InspectorBackendDispatcherImpl::Debugger_getGeneratorObjectDetails,
            &InspectorBackendDispatcherImpl::Debugger_getCollectionEntries,
            &InspectorBackendDispatcherImpl::Debugger_setPauseOnExceptions,
            &InspectorBackendDispatcherImpl::Debugger_evaluateOnCallFrame,
            &InspectorBackendDispatcherImpl::Debugger_setVariableValue,
            &InspectorBackendDispatcherImpl::Debugger_getStepInPositions,
            &InspectorBackendDispatcherImpl::Debugger_getBacktrace,
            &InspectorBackendDispatcherImpl::Debugger_setAsyncCallStackDepth,
            &InspectorBackendDispatcherImpl::Debugger_enablePromiseTracker,
            &InspectorBackendDispatcherImpl::Debugger_disablePromiseTracker,
            &InspectorBackendDispatcherImpl::Debugger_getPromiseById,
            &InspectorBackendDispatcherImpl::Debugger_flushAsyncOperationEvents,
            &InspectorBackendDispatcherImpl::Debugger_setAsyncOperationBreakpoint,
            &InspectorBackendDispatcherImpl::Debugger_removeAsyncOperationBreakpoint,
            &InspectorBackendDispatcherImpl::Debugger_setBlackboxedRanges,
            &InspectorBackendDispatcherImpl::DOMDebugger_setDOMBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_removeDOMBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_setEventListenerBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_removeEventListenerBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_setInstrumentationBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_removeInstrumentationBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_setXHRBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_removeXHRBreakpoint,
            &InspectorBackendDispatcherImpl::DOMDebugger_getEventListeners,
            &InspectorBackendDispatcherImpl::Profiler_enable,
            &InspectorBackendDispatcherImpl::Profiler_disable,
            &InspectorBackendDispatcherImpl::Profiler_setSamplingInterval,
            &InspectorBackendDispatcherImpl::Profiler_start,
            &InspectorBackendDispatcherImpl::Profiler_stop,
            &InspectorBackendDispatcherImpl::HeapProfiler_enable,
            &InspectorBackendDispatcherImpl::HeapProfiler_disable,
            &InspectorBackendDispatcherImpl::HeapProfiler_startTrackingHeapObjects,
            &InspectorBackendDispatcherImpl::HeapProfiler_stopTrackingHeapObjects,
            &InspectorBackendDispatcherImpl::HeapProfiler_takeHeapSnapshot,
            &InspectorBackendDispatcherImpl::HeapProfiler_collectGarbage,
            &InspectorBackendDispatcherImpl::HeapProfiler_getObjectByHeapObjectId,
            &InspectorBackendDispatcherImpl::HeapProfiler_addInspectedHeapObject,
            &InspectorBackendDispatcherImpl::HeapProfiler_getHeapObjectId,
            &InspectorBackendDispatcherImpl::Worker_enable,
            &InspectorBackendDispatcherImpl::Worker_disable,
            &InspectorBackendDispatcherImpl::Worker_sendMessageToWorker,
            &InspectorBackendDispatcherImpl::Worker_connectToWorker,
            &InspectorBackendDispatcherImpl::Worker_disconnectFromWorker,
            &InspectorBackendDispatcherImpl::Worker_setAutoconnectToWorkers,
            &InspectorBackendDispatcherImpl::Input_dispatchTouchEvent,
            &InspectorBackendDispatcherImpl::LayerTree_enable,
            &InspectorBackendDispatcherImpl::LayerTree_disable,
            &InspectorBackendDispatcherImpl::LayerTree_compositingReasons,
            &InspectorBackendDispatcherImpl::LayerTree_makeSnapshot,
            &InspectorBackendDispatcherImpl::LayerTree_loadSnapshot,
            &InspectorBackendDispatcherImpl::LayerTree_releaseSnapshot,
            &InspectorBackendDispatcherImpl::LayerTree_profileSnapshot,
            &InspectorBackendDispatcherImpl::LayerTree_replaySnapshot,
            &InspectorBackendDispatcherImpl::LayerTree_snapshotCommandLog,
            &InspectorBackendDispatcherImpl::DeviceOrientation_setDeviceOrientationOverride,
            &InspectorBackendDispatcherImpl::DeviceOrientation_clearDeviceOrientationOverride,
            &InspectorBackendDispatcherImpl::ScreenOrientation_setScreenOrientationOverride,
            &InspectorBackendDispatcherImpl::ScreenOrientation_clearScreenOrientationOverride,
            &InspectorBackendDispatcherImpl::Tracing_start,
            &InspectorBackendDispatcherImpl::Tracing_end,
            &InspectorBackendDispatcherImpl::Animation_enable,
            &InspectorBackendDispatcherImpl::Animation_disable,
            &InspectorBackendDispatcherImpl::Animation_getPlaybackRate,
            &InspectorBackendDispatcherImpl::Animation_setPlaybackRate,
            &InspectorBackendDispatcherImpl::Animation_getCurrentTime,
            &InspectorBackendDispatcherImpl::Animation_setPaused,
            &InspectorBackendDispatcherImpl::Animation_setTiming,
            &InspectorBackendDispatcherImpl::Animation_seekAnimations,
            &InspectorBackendDispatcherImpl::Animation_releaseAnimations,
            &InspectorBackendDispatcherImpl::Animation_resolveAnimation,
            &InspectorBackendDispatcherImpl::Accessibility_getAXNode,
        };
        for (size_t i = 0; i < kMethodNamesEnumSize; ++i)
            m_dispatchMap.add(commandName(static_cast<MethodNames>(i)), handlers[i]);

        // Initialize common errors.
        m_commonErrors.insert(ParseError, -32700);
        m_commonErrors.insert(InvalidRequest, -32600);
        m_commonErrors.insert(MethodNotFound, -32601);
        m_commonErrors.insert(InvalidParams, -32602);
        m_commonErrors.insert(InternalError, -32603);
        m_commonErrors.insert(ServerError, -32000);
    }

    virtual void clearFrontend() { m_inspectorFrontendChannel = 0; }
    virtual void dispatch(int sessionId, const String& message);
    virtual void reportProtocolError(int sessionId, int callId, CommonErrorCode, const String& errorMessage, PassRefPtr<JSONValue> data) const;
    using InspectorBackendDispatcher::reportProtocolError;

    void sendResponse(int sessionId, int callId, const ErrorString& invocationError, PassRefPtr<JSONValue> errorData, PassRefPtr<JSONObject> result);
    bool isActive() { return m_inspectorFrontendChannel; }

    virtual void registerAgent(InspectorCommandHandler* inspectorAgent) { ASSERT(!m_inspectorAgent); m_inspectorAgent = inspectorAgent; }
    virtual void registerAgent(MemoryCommandHandler* memoryAgent) { ASSERT(!m_memoryAgent); m_memoryAgent = memoryAgent; }
    virtual void registerAgent(PageCommandHandler* pageAgent) { ASSERT(!m_pageAgent); m_pageAgent = pageAgent; }
    virtual void registerAgent(RenderingCommandHandler* renderingAgent) { ASSERT(!m_renderingAgent); m_renderingAgent = renderingAgent; }
    virtual void registerAgent(EmulationCommandHandler* emulationAgent) { ASSERT(!m_emulationAgent); m_emulationAgent = emulationAgent; }
    virtual void registerAgent(RuntimeCommandHandler* runtimeAgent) { ASSERT(!m_runtimeAgent); m_runtimeAgent = runtimeAgent; }
    virtual void registerAgent(ConsoleCommandHandler* consoleAgent) { ASSERT(!m_consoleAgent); m_consoleAgent = consoleAgent; }
    virtual void registerAgent(SecurityCommandHandler* securityAgent) { ASSERT(!m_securityAgent); m_securityAgent = securityAgent; }
    virtual void registerAgent(NetworkCommandHandler* networkAgent) { ASSERT(!m_networkAgent); m_networkAgent = networkAgent; }
    virtual void registerAgent(DatabaseCommandHandler* databaseAgent) { ASSERT(!m_databaseAgent); m_databaseAgent = databaseAgent; }
    virtual void registerAgent(IndexedDBCommandHandler* indexedDBAgent) { ASSERT(!m_indexedDBAgent); m_indexedDBAgent = indexedDBAgent; }
    virtual void registerAgent(CacheStorageCommandHandler* cacheStorageAgent) { ASSERT(!m_cacheStorageAgent); m_cacheStorageAgent = cacheStorageAgent; }
    virtual void registerAgent(DOMStorageCommandHandler* domStorageAgent) { ASSERT(!m_domStorageAgent); m_domStorageAgent = domStorageAgent; }
    virtual void registerAgent(ApplicationCacheCommandHandler* applicationCacheAgent) { ASSERT(!m_applicationCacheAgent); m_applicationCacheAgent = applicationCacheAgent; }
    virtual void registerAgent(FileSystemCommandHandler* fileSystemAgent) { ASSERT(!m_fileSystemAgent); m_fileSystemAgent = fileSystemAgent; }
    virtual void registerAgent(DOMCommandHandler* domAgent) { ASSERT(!m_domAgent); m_domAgent = domAgent; }
    virtual void registerAgent(CSSCommandHandler* cssAgent) { ASSERT(!m_cssAgent); m_cssAgent = cssAgent; }
    virtual void registerAgent(IOCommandHandler* ioAgent) { ASSERT(!m_ioAgent); m_ioAgent = ioAgent; }
    virtual void registerAgent(DebuggerCommandHandler* debuggerAgent) { ASSERT(!m_debuggerAgent); m_debuggerAgent = debuggerAgent; }
    virtual void registerAgent(DOMDebuggerCommandHandler* domDebuggerAgent) { ASSERT(!m_domDebuggerAgent); m_domDebuggerAgent = domDebuggerAgent; }
    virtual void registerAgent(ProfilerCommandHandler* profilerAgent) { ASSERT(!m_profilerAgent); m_profilerAgent = profilerAgent; }
    virtual void registerAgent(HeapProfilerCommandHandler* heapProfilerAgent) { ASSERT(!m_heapProfilerAgent); m_heapProfilerAgent = heapProfilerAgent; }
    virtual void registerAgent(WorkerCommandHandler* workerAgent) { ASSERT(!m_workerAgent); m_workerAgent = workerAgent; }
    virtual void registerAgent(ServiceWorkerCommandHandler* serviceWorkerAgent) { ASSERT(!m_serviceWorkerAgent); m_serviceWorkerAgent = serviceWorkerAgent; }
    virtual void registerAgent(InputCommandHandler* inputAgent) { ASSERT(!m_inputAgent); m_inputAgent = inputAgent; }
    virtual void registerAgent(LayerTreeCommandHandler* layerTreeAgent) { ASSERT(!m_layerTreeAgent); m_layerTreeAgent = layerTreeAgent; }
    virtual void registerAgent(DeviceOrientationCommandHandler* deviceOrientationAgent) { ASSERT(!m_deviceOrientationAgent); m_deviceOrientationAgent = deviceOrientationAgent; }
    virtual void registerAgent(ScreenOrientationCommandHandler* screenOrientationAgent) { ASSERT(!m_screenOrientationAgent); m_screenOrientationAgent = screenOrientationAgent; }
    virtual void registerAgent(TracingCommandHandler* tracingAgent) { ASSERT(!m_tracingAgent); m_tracingAgent = tracingAgent; }
    virtual void registerAgent(AnimationCommandHandler* animationAgent) { ASSERT(!m_animationAgent); m_animationAgent = animationAgent; }
    virtual void registerAgent(AccessibilityCommandHandler* accessibilityAgent) { ASSERT(!m_accessibilityAgent); m_accessibilityAgent = accessibilityAgent; }
private:
    using CallHandler = void (InspectorBackendDispatcherImpl::*)(int sessionId, int callId, JSONObject* messageObject, JSONArray* protocolErrors);
    using DispatchMap = HashMap<String, CallHandler>;

    void Inspector_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Inspector_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Memory_getDOMCounters(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_addScriptToEvaluateOnLoad(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_removeScriptToEvaluateOnLoad(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setAutoAttachToCreatedPages(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_reload(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_navigate(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_getResourceTree(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_getResourceContent(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_searchInResource(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setDocumentContent(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setDeviceOrientationOverride(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_clearDeviceOrientationOverride(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setTouchEmulationEnabled(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_startScreencast(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_stopScreencast(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Page_setOverlayMessage(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Rendering_setShowPaintRects(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Rendering_setShowDebugBorders(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Rendering_setShowFPSCounter(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Rendering_setShowScrollBottleneckRects(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Emulation_resetPageScaleFactor(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Emulation_setPageScaleFactor(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Emulation_setScriptExecutionDisabled(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Emulation_setTouchEmulationEnabled(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Emulation_setEmulatedMedia(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Emulation_setCPUThrottlingRate(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_evaluate(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_callFunctionOn(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_getProperties(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_releaseObject(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_releaseObjectGroup(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_run(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_isRunRequired(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_setCustomObjectFormatterEnabled(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_compileScript(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Runtime_runScript(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Console_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Console_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Console_clearMessages(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_setUserAgentOverride(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_setExtraHTTPHeaders(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_getResponseBody(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_addBlockedURL(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_removeBlockedURL(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_replayXHR(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_setMonitoringXHREnabled(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_canClearBrowserCache(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_canClearBrowserCookies(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_emulateNetworkConditions(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_setCacheDisabled(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Network_setDataSizeLimitsForTest(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Database_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Database_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Database_getDatabaseTableNames(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Database_executeSQL(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_requestDatabaseNames(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_requestDatabase(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_requestData(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void IndexedDB_clearObjectStore(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CacheStorage_requestCacheNames(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CacheStorage_requestEntries(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CacheStorage_deleteCache(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CacheStorage_deleteEntry(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMStorage_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMStorage_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMStorage_getDOMStorageItems(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMStorage_setDOMStorageItem(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMStorage_removeDOMStorageItem(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void ApplicationCache_getFramesWithManifests(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void ApplicationCache_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void ApplicationCache_getManifestForFrame(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void ApplicationCache_getApplicationCacheForFrame(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_requestFileSystemRoot(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_requestDirectoryContent(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_requestMetadata(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_requestFileContent(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void FileSystem_deleteEntry(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getDocument(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_requestChildNodes(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_querySelector(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_querySelectorAll(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setNodeName(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setNodeValue(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_removeNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setAttributeValue(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setAttributesAsText(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_removeAttribute(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getOuterHTML(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setOuterHTML(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_performSearch(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getSearchResults(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_discardSearchResults(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_requestNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setInspectMode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_highlightRect(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_highlightQuad(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_highlightNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_hideHighlight(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_highlightFrame(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_pushNodeByPathToFrontend(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_pushNodesByBackendIdsToFrontend(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setInspectedNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_resolveNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getAttributes(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_copyTo(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_moveTo(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_undo(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_redo(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_markUndoableState(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_focus(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_setFileInputFiles(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getBoxModel(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getNodeForLocation(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getRelayoutBoundary(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOM_getHighlightObjectForTest(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getMatchedStylesForNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getInlineStylesForNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getComputedStyleForNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getPlatformFontsForNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getStyleSheetText(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_setStyleSheetText(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_setRuleSelector(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_setKeyframeKey(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_setStyleText(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_setMediaText(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_createStyleSheet(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_addRule(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_forcePseudoState(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getMediaQueries(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_setEffectivePropertyValueForNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void CSS_getBackgroundColors(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setBreakpointsActive(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setSkipAllPauses(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setBreakpointByUrl(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_removeBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_continueToLocation(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_stepOver(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_stepInto(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_stepOut(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_pause(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_resume(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_stepIntoAsync(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_searchInContent(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_canSetScriptSource(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setScriptSource(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_restartFrame(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getScriptSource(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getFunctionDetails(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getGeneratorObjectDetails(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getCollectionEntries(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setPauseOnExceptions(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_evaluateOnCallFrame(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setVariableValue(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getStepInPositions(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getBacktrace(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setAsyncCallStackDepth(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_enablePromiseTracker(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_disablePromiseTracker(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_getPromiseById(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_flushAsyncOperationEvents(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setAsyncOperationBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_removeAsyncOperationBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Debugger_setBlackboxedRanges(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_setDOMBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_removeDOMBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_setEventListenerBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_removeEventListenerBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_setInstrumentationBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_removeInstrumentationBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_setXHRBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_removeXHRBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DOMDebugger_getEventListeners(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Profiler_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Profiler_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Profiler_setSamplingInterval(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Profiler_start(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Profiler_stop(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_startTrackingHeapObjects(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_stopTrackingHeapObjects(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_takeHeapSnapshot(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_collectGarbage(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_getObjectByHeapObjectId(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_addInspectedHeapObject(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void HeapProfiler_getHeapObjectId(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_sendMessageToWorker(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_connectToWorker(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_disconnectFromWorker(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Worker_setAutoconnectToWorkers(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Input_dispatchTouchEvent(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_compositingReasons(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_makeSnapshot(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_loadSnapshot(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_releaseSnapshot(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_profileSnapshot(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_replaySnapshot(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void LayerTree_snapshotCommandLog(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DeviceOrientation_setDeviceOrientationOverride(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void DeviceOrientation_clearDeviceOrientationOverride(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void ScreenOrientation_setScreenOrientationOverride(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void ScreenOrientation_clearScreenOrientationOverride(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Tracing_start(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Tracing_end(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Animation_enable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Animation_disable(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Animation_getPlaybackRate(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Animation_setPlaybackRate(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Animation_getCurrentTime(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Animation_setPaused(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Animation_setTiming(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Animation_seekAnimations(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Animation_releaseAnimations(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Animation_resolveAnimation(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);
    void Accessibility_getAXNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors);

    InspectorFrontendChannel* m_inspectorFrontendChannel;
    InspectorCommandHandler* m_inspectorAgent;
    MemoryCommandHandler* m_memoryAgent;
    PageCommandHandler* m_pageAgent;
    RenderingCommandHandler* m_renderingAgent;
    EmulationCommandHandler* m_emulationAgent;
    RuntimeCommandHandler* m_runtimeAgent;
    ConsoleCommandHandler* m_consoleAgent;
    SecurityCommandHandler* m_securityAgent;
    NetworkCommandHandler* m_networkAgent;
    DatabaseCommandHandler* m_databaseAgent;
    IndexedDBCommandHandler* m_indexedDBAgent;
    CacheStorageCommandHandler* m_cacheStorageAgent;
    DOMStorageCommandHandler* m_domStorageAgent;
    ApplicationCacheCommandHandler* m_applicationCacheAgent;
    FileSystemCommandHandler* m_fileSystemAgent;
    DOMCommandHandler* m_domAgent;
    CSSCommandHandler* m_cssAgent;
    IOCommandHandler* m_ioAgent;
    DebuggerCommandHandler* m_debuggerAgent;
    DOMDebuggerCommandHandler* m_domDebuggerAgent;
    ProfilerCommandHandler* m_profilerAgent;
    HeapProfilerCommandHandler* m_heapProfilerAgent;
    WorkerCommandHandler* m_workerAgent;
    ServiceWorkerCommandHandler* m_serviceWorkerAgent;
    InputCommandHandler* m_inputAgent;
    LayerTreeCommandHandler* m_layerTreeAgent;
    DeviceOrientationCommandHandler* m_deviceOrientationAgent;
    ScreenOrientationCommandHandler* m_screenOrientationAgent;
    TracingCommandHandler* m_tracingAgent;
    AnimationCommandHandler* m_animationAgent;
    AccessibilityCommandHandler* m_accessibilityAgent;

    template<typename R, typename V, typename V0>
    static R getPropertyValueImpl(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors, V0 initial_value, bool (*as_method)(JSONValue*, V*), const char* type_name);

    static int getInt(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);
    static double getDouble(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);
    static String getString(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);
    static bool getBoolean(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);
    static PassRefPtr<JSONObject> getObject(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);
    static PassRefPtr<JSONArray> getArray(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors);

    void sendResponse(int sessionId, int callId, ErrorString invocationError, PassRefPtr<JSONObject> result)
    {
        sendResponse(sessionId, callId, invocationError, RefPtr<JSONValue>(), result);
    }
    void sendResponse(int sessionId, int callId, ErrorString invocationError)
    {
        sendResponse(sessionId, callId, invocationError, RefPtr<JSONValue>(), JSONObject::create());
    }
    static const char InvalidParamsFormatString[];

    DispatchMap m_dispatchMap;
    Vector<int> m_commonErrors;
};

const char InspectorBackendDispatcherImpl::InvalidParamsFormatString[] = "Some arguments of method '%s' can't be processed";

void InspectorBackendDispatcherImpl::Inspector_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_inspectorAgent)
        protocolErrors->pushString("Inspector handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kInspector_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_inspectorAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Inspector_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_inspectorAgent)
        protocolErrors->pushString("Inspector handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kInspector_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_inspectorAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Memory_getDOMCounters(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_memoryAgent)
        protocolErrors->pushString("Memory handler is not available.");

    int out_documents;
    int out_nodes;
    int out_jsEventListeners;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kMemory_getDOMCountersCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_memoryAgent->getDOMCounters(&error, &out_documents, &out_nodes, &out_jsEventListeners);
    if (!error.length()) {
        result->setNumber("documents", out_documents);
        result->setNumber("nodes", out_nodes);
        result->setNumber("jsEventListeners", out_jsEventListeners);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Page_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Page_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Page_addScriptToEvaluateOnLoad(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_scriptSource = getString(paramsContainerPtr, "scriptSource", 0, protocolErrors);

    TypeBuilder::Page::ScriptIdentifier out_identifier;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_addScriptToEvaluateOnLoadCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_pageAgent->addScriptToEvaluateOnLoad(&error, in_scriptSource, &out_identifier);
    if (!error.length()) {
        result->setString("identifier", out_identifier);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Page_removeScriptToEvaluateOnLoad(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_identifier = getString(paramsContainerPtr, "identifier", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_removeScriptToEvaluateOnLoadCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->removeScriptToEvaluateOnLoad(&error, in_identifier);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Page_setAutoAttachToCreatedPages(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_autoAttach = getBoolean(paramsContainerPtr, "autoAttach", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setAutoAttachToCreatedPagesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setAutoAttachToCreatedPages(&error, in_autoAttach);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Page_reload(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool ignoreCache_valueFound = false;
    bool in_ignoreCache = getBoolean(paramsContainerPtr, "ignoreCache", &ignoreCache_valueFound, protocolErrors);
    bool scriptToEvaluateOnLoad_valueFound = false;
    String in_scriptToEvaluateOnLoad = getString(paramsContainerPtr, "scriptToEvaluateOnLoad", &scriptToEvaluateOnLoad_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_reloadCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->reload(&error, ignoreCache_valueFound ? &in_ignoreCache : 0, scriptToEvaluateOnLoad_valueFound ? &in_scriptToEvaluateOnLoad : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Page_navigate(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);

    TypeBuilder::Page::FrameId out_frameId;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_navigateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_pageAgent->navigate(&error, in_url, &out_frameId);
    if (!error.length()) {
        result->setString("frameId", out_frameId);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Page_getResourceTree(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<TypeBuilder::Page::FrameResourceTree> out_frameTree;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_getResourceTreeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_pageAgent->getResourceTree(&error, out_frameTree);
    if (!error.length()) {
        result->setValue("frameTree", static_pointer_cast<JSONValue>(out_frameTree));
    }
    sendResponse(sessionId, callId, error, result);
}

InspectorBackendDispatcher::PageCommandHandler::GetResourceContentCallback::GetResourceContentCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::PageCommandHandler::GetResourceContentCallback::sendSuccess(const String& content, bool base64Encoded)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setString("content", content);
    jsonMessage->setBoolean("base64Encoded", base64Encoded);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::Page_getResourceContent(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    RefPtrWillBeRawPtr<PageCommandHandler::GetResourceContentCallback> callback = adoptRefWillBeNoop(new PageCommandHandler::GetResourceContentCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_getResourceContentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->getResourceContent(&error, in_frameId, in_url, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::PageCommandHandler::SearchInResourceCallback::SearchInResourceCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::PageCommandHandler::SearchInResourceCallback::sendSuccess(PassRefPtr<TypeBuilder::Array<TypeBuilder::Debugger::SearchMatch> > result)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setValue("result", result);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::Page_searchInResource(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    String in_query = getString(paramsContainerPtr, "query", 0, protocolErrors);
    bool caseSensitive_valueFound = false;
    bool in_caseSensitive = getBoolean(paramsContainerPtr, "caseSensitive", &caseSensitive_valueFound, protocolErrors);
    bool isRegex_valueFound = false;
    bool in_isRegex = getBoolean(paramsContainerPtr, "isRegex", &isRegex_valueFound, protocolErrors);
    RefPtrWillBeRawPtr<PageCommandHandler::SearchInResourceCallback> callback = adoptRefWillBeNoop(new PageCommandHandler::SearchInResourceCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_searchInResourceCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->searchInResource(&error, in_frameId, in_url, in_query, caseSensitive_valueFound ? &in_caseSensitive : 0, isRegex_valueFound ? &in_isRegex : 0, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Page_setDocumentContent(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);
    String in_html = getString(paramsContainerPtr, "html", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setDocumentContentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setDocumentContent(&error, in_frameId, in_html);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Page_setDeviceOrientationOverride(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_deviceOrientationAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    double in_alpha = getDouble(paramsContainerPtr, "alpha", 0, protocolErrors);
    double in_beta = getDouble(paramsContainerPtr, "beta", 0, protocolErrors);
    double in_gamma = getDouble(paramsContainerPtr, "gamma", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setDeviceOrientationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_deviceOrientationAgent->setDeviceOrientationOverride(&error, in_alpha, in_beta, in_gamma);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Page_clearDeviceOrientationOverride(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_deviceOrientationAgent)
        protocolErrors->pushString("Page handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_clearDeviceOrientationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_deviceOrientationAgent->clearDeviceOrientationOverride(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Page_setTouchEmulationEnabled(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_emulationAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrors);
    bool configuration_valueFound = false;
    String in_configuration = getString(paramsContainerPtr, "configuration", &configuration_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setTouchEmulationEnabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_emulationAgent->setTouchEmulationEnabled(&error, in_enabled, configuration_valueFound ? &in_configuration : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Page_startScreencast(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool format_valueFound = false;
    String in_format = getString(paramsContainerPtr, "format", &format_valueFound, protocolErrors);
    bool quality_valueFound = false;
    int in_quality = getInt(paramsContainerPtr, "quality", &quality_valueFound, protocolErrors);
    bool maxWidth_valueFound = false;
    int in_maxWidth = getInt(paramsContainerPtr, "maxWidth", &maxWidth_valueFound, protocolErrors);
    bool maxHeight_valueFound = false;
    int in_maxHeight = getInt(paramsContainerPtr, "maxHeight", &maxHeight_valueFound, protocolErrors);
    bool everyNthFrame_valueFound = false;
    int in_everyNthFrame = getInt(paramsContainerPtr, "everyNthFrame", &everyNthFrame_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_startScreencastCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->startScreencast(&error, format_valueFound ? &in_format : 0, quality_valueFound ? &in_quality : 0, maxWidth_valueFound ? &in_maxWidth : 0, maxHeight_valueFound ? &in_maxHeight : 0, everyNthFrame_valueFound ? &in_everyNthFrame : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Page_stopScreencast(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_stopScreencastCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->stopScreencast(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Page_setOverlayMessage(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_pageAgent)
        protocolErrors->pushString("Page handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool message_valueFound = false;
    String in_message = getString(paramsContainerPtr, "message", &message_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kPage_setOverlayMessageCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_pageAgent->setOverlayMessage(&error, message_valueFound ? &in_message : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Rendering_setShowPaintRects(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_renderingAgent)
        protocolErrors->pushString("Rendering handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_result = getBoolean(paramsContainerPtr, "result", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRendering_setShowPaintRectsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_renderingAgent->setShowPaintRects(&error, in_result);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Rendering_setShowDebugBorders(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_renderingAgent)
        protocolErrors->pushString("Rendering handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_show = getBoolean(paramsContainerPtr, "show", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRendering_setShowDebugBordersCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_renderingAgent->setShowDebugBorders(&error, in_show);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Rendering_setShowFPSCounter(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_renderingAgent)
        protocolErrors->pushString("Rendering handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_show = getBoolean(paramsContainerPtr, "show", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRendering_setShowFPSCounterCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_renderingAgent->setShowFPSCounter(&error, in_show);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Rendering_setShowScrollBottleneckRects(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_renderingAgent)
        protocolErrors->pushString("Rendering handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_show = getBoolean(paramsContainerPtr, "show", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRendering_setShowScrollBottleneckRectsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_renderingAgent->setShowScrollBottleneckRects(&error, in_show);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Emulation_resetPageScaleFactor(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_emulationAgent)
        protocolErrors->pushString("Emulation handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kEmulation_resetPageScaleFactorCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_emulationAgent->resetPageScaleFactor(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Emulation_setPageScaleFactor(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_emulationAgent)
        protocolErrors->pushString("Emulation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    double in_pageScaleFactor = getDouble(paramsContainerPtr, "pageScaleFactor", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kEmulation_setPageScaleFactorCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_emulationAgent->setPageScaleFactor(&error, in_pageScaleFactor);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Emulation_setScriptExecutionDisabled(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_emulationAgent)
        protocolErrors->pushString("Emulation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_value = getBoolean(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kEmulation_setScriptExecutionDisabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_emulationAgent->setScriptExecutionDisabled(&error, in_value);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Emulation_setTouchEmulationEnabled(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_emulationAgent)
        protocolErrors->pushString("Emulation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrors);
    bool configuration_valueFound = false;
    String in_configuration = getString(paramsContainerPtr, "configuration", &configuration_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kEmulation_setTouchEmulationEnabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_emulationAgent->setTouchEmulationEnabled(&error, in_enabled, configuration_valueFound ? &in_configuration : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Emulation_setEmulatedMedia(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_emulationAgent)
        protocolErrors->pushString("Emulation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_media = getString(paramsContainerPtr, "media", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kEmulation_setEmulatedMediaCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_emulationAgent->setEmulatedMedia(&error, in_media);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Emulation_setCPUThrottlingRate(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_emulationAgent)
        protocolErrors->pushString("Emulation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    double in_rate = getDouble(paramsContainerPtr, "rate", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kEmulation_setCPUThrottlingRateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_emulationAgent->setCPUThrottlingRate(&error, in_rate);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_evaluate(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_expression = getString(paramsContainerPtr, "expression", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);
    bool includeCommandLineAPI_valueFound = false;
    bool in_includeCommandLineAPI = getBoolean(paramsContainerPtr, "includeCommandLineAPI", &includeCommandLineAPI_valueFound, protocolErrors);
    bool doNotPauseOnExceptionsAndMuteConsole_valueFound = false;
    bool in_doNotPauseOnExceptionsAndMuteConsole = getBoolean(paramsContainerPtr, "doNotPauseOnExceptionsAndMuteConsole", &doNotPauseOnExceptionsAndMuteConsole_valueFound, protocolErrors);
    bool contextId_valueFound = false;
    int in_contextId = getInt(paramsContainerPtr, "contextId", &contextId_valueFound, protocolErrors);
    bool returnByValue_valueFound = false;
    bool in_returnByValue = getBoolean(paramsContainerPtr, "returnByValue", &returnByValue_valueFound, protocolErrors);
    bool generatePreview_valueFound = false;
    bool in_generatePreview = getBoolean(paramsContainerPtr, "generatePreview", &generatePreview_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;
    TypeBuilder::OptOutput<bool> out_wasThrown;
    RefPtr<TypeBuilder::Runtime::ExceptionDetails> out_exceptionDetails;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_evaluateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_runtimeAgent->evaluate(&error, in_expression, objectGroup_valueFound ? &in_objectGroup : 0, includeCommandLineAPI_valueFound ? &in_includeCommandLineAPI : 0, doNotPauseOnExceptionsAndMuteConsole_valueFound ? &in_doNotPauseOnExceptionsAndMuteConsole : 0, contextId_valueFound ? &in_contextId : 0, returnByValue_valueFound ? &in_returnByValue : 0, generatePreview_valueFound ? &in_generatePreview : 0, out_result, &out_wasThrown, out_exceptionDetails);
    if (!error.length()) {
        result->setValue("result", static_pointer_cast<JSONValue>(out_result));
        if (out_wasThrown.isAssigned())
            result->setBoolean("wasThrown", out_wasThrown.getValue());
        if (out_exceptionDetails)
            result->setValue("exceptionDetails", static_pointer_cast<JSONValue>(out_exceptionDetails));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Runtime_callFunctionOn(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);
    String in_functionDeclaration = getString(paramsContainerPtr, "functionDeclaration", 0, protocolErrors);
    bool arguments_valueFound = false;
    RefPtr<JSONArray> in_arguments = getArray(paramsContainerPtr, "arguments", &arguments_valueFound, protocolErrors);
    bool doNotPauseOnExceptionsAndMuteConsole_valueFound = false;
    bool in_doNotPauseOnExceptionsAndMuteConsole = getBoolean(paramsContainerPtr, "doNotPauseOnExceptionsAndMuteConsole", &doNotPauseOnExceptionsAndMuteConsole_valueFound, protocolErrors);
    bool returnByValue_valueFound = false;
    bool in_returnByValue = getBoolean(paramsContainerPtr, "returnByValue", &returnByValue_valueFound, protocolErrors);
    bool generatePreview_valueFound = false;
    bool in_generatePreview = getBoolean(paramsContainerPtr, "generatePreview", &generatePreview_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;
    TypeBuilder::OptOutput<bool> out_wasThrown;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_callFunctionOnCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_runtimeAgent->callFunctionOn(&error, in_objectId, in_functionDeclaration, arguments_valueFound ? &in_arguments : 0, doNotPauseOnExceptionsAndMuteConsole_valueFound ? &in_doNotPauseOnExceptionsAndMuteConsole : 0, returnByValue_valueFound ? &in_returnByValue : 0, generatePreview_valueFound ? &in_generatePreview : 0, out_result, &out_wasThrown);
    if (!error.length()) {
        result->setValue("result", static_pointer_cast<JSONValue>(out_result));
        if (out_wasThrown.isAssigned())
            result->setBoolean("wasThrown", out_wasThrown.getValue());
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Runtime_getProperties(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);
    bool ownProperties_valueFound = false;
    bool in_ownProperties = getBoolean(paramsContainerPtr, "ownProperties", &ownProperties_valueFound, protocolErrors);
    bool accessorPropertiesOnly_valueFound = false;
    bool in_accessorPropertiesOnly = getBoolean(paramsContainerPtr, "accessorPropertiesOnly", &accessorPropertiesOnly_valueFound, protocolErrors);
    bool generatePreview_valueFound = false;
    bool in_generatePreview = getBoolean(paramsContainerPtr, "generatePreview", &generatePreview_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Runtime::PropertyDescriptor> > out_result;
    RefPtr<TypeBuilder::Array<TypeBuilder::Runtime::InternalPropertyDescriptor> > out_internalProperties;
    RefPtr<TypeBuilder::Runtime::ExceptionDetails> out_exceptionDetails;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_getPropertiesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_runtimeAgent->getProperties(&error, in_objectId, ownProperties_valueFound ? &in_ownProperties : 0, accessorPropertiesOnly_valueFound ? &in_accessorPropertiesOnly : 0, generatePreview_valueFound ? &in_generatePreview : 0, out_result, out_internalProperties, out_exceptionDetails);
    if (!error.length()) {
        result->setValue("result", out_result);
        if (out_internalProperties)
            result->setValue("internalProperties", out_internalProperties);
        if (out_exceptionDetails)
            result->setValue("exceptionDetails", static_pointer_cast<JSONValue>(out_exceptionDetails));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Runtime_releaseObject(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_releaseObjectCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->releaseObject(&error, in_objectId);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_releaseObjectGroup(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_releaseObjectGroupCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->releaseObjectGroup(&error, in_objectGroup);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_run(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_runCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->run(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_isRunRequired(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    bool out_result;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_isRunRequiredCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_runtimeAgent->isRunRequired(&error, &out_result);
    if (!error.length()) {
        result->setBoolean("result", out_result);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Runtime_setCustomObjectFormatterEnabled(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_setCustomObjectFormatterEnabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_runtimeAgent->setCustomObjectFormatterEnabled(&error, in_enabled);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Runtime_compileScript(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_expression = getString(paramsContainerPtr, "expression", 0, protocolErrors);
    String in_sourceURL = getString(paramsContainerPtr, "sourceURL", 0, protocolErrors);
    bool in_persistScript = getBoolean(paramsContainerPtr, "persistScript", 0, protocolErrors);
    int in_executionContextId = getInt(paramsContainerPtr, "executionContextId", 0, protocolErrors);

    TypeBuilder::OptOutput<TypeBuilder::Runtime::ScriptId> out_scriptId;
    RefPtr<TypeBuilder::Runtime::ExceptionDetails> out_exceptionDetails;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_compileScriptCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_runtimeAgent->compileScript(&error, in_expression, in_sourceURL, in_persistScript, in_executionContextId, &out_scriptId, out_exceptionDetails);
    if (!error.length()) {
        if (out_scriptId.isAssigned())
            result->setString("scriptId", out_scriptId.getValue());
        if (out_exceptionDetails)
            result->setValue("exceptionDetails", static_pointer_cast<JSONValue>(out_exceptionDetails));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Runtime_runScript(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_runtimeAgent)
        protocolErrors->pushString("Runtime handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_scriptId = getString(paramsContainerPtr, "scriptId", 0, protocolErrors);
    int in_executionContextId = getInt(paramsContainerPtr, "executionContextId", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);
    bool doNotPauseOnExceptionsAndMuteConsole_valueFound = false;
    bool in_doNotPauseOnExceptionsAndMuteConsole = getBoolean(paramsContainerPtr, "doNotPauseOnExceptionsAndMuteConsole", &doNotPauseOnExceptionsAndMuteConsole_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;
    RefPtr<TypeBuilder::Runtime::ExceptionDetails> out_exceptionDetails;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kRuntime_runScriptCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_runtimeAgent->runScript(&error, in_scriptId, in_executionContextId, objectGroup_valueFound ? &in_objectGroup : 0, doNotPauseOnExceptionsAndMuteConsole_valueFound ? &in_doNotPauseOnExceptionsAndMuteConsole : 0, out_result, out_exceptionDetails);
    if (!error.length()) {
        result->setValue("result", static_pointer_cast<JSONValue>(out_result));
        if (out_exceptionDetails)
            result->setValue("exceptionDetails", static_pointer_cast<JSONValue>(out_exceptionDetails));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Console_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kConsole_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_consoleAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Console_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kConsole_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_consoleAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Console_clearMessages(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_consoleAgent)
        protocolErrors->pushString("Console handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kConsole_clearMessagesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_consoleAgent->clearMessages(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Network_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Network_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Network_setUserAgentOverride(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_userAgent = getString(paramsContainerPtr, "userAgent", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_setUserAgentOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->setUserAgentOverride(&error, in_userAgent);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Network_setExtraHTTPHeaders(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_headers = getObject(paramsContainerPtr, "headers", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_setExtraHTTPHeadersCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->setExtraHTTPHeaders(&error, in_headers);

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::NetworkCommandHandler::GetResponseBodyCallback::GetResponseBodyCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::NetworkCommandHandler::GetResponseBodyCallback::sendSuccess(const String& body, bool base64Encoded)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setString("body", body);
    jsonMessage->setBoolean("base64Encoded", base64Encoded);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::Network_getResponseBody(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_requestId = getString(paramsContainerPtr, "requestId", 0, protocolErrors);
    RefPtrWillBeRawPtr<NetworkCommandHandler::GetResponseBodyCallback> callback = adoptRefWillBeNoop(new NetworkCommandHandler::GetResponseBodyCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_getResponseBodyCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->getResponseBody(&error, in_requestId, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Network_addBlockedURL(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_addBlockedURLCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->addBlockedURL(&error, in_url);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Network_removeBlockedURL(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_removeBlockedURLCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->removeBlockedURL(&error, in_url);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Network_replayXHR(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_requestId = getString(paramsContainerPtr, "requestId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_replayXHRCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->replayXHR(&error, in_requestId);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Network_setMonitoringXHREnabled(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_enabled = getBoolean(paramsContainerPtr, "enabled", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_setMonitoringXHREnabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->setMonitoringXHREnabled(&error, in_enabled);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Network_canClearBrowserCache(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    bool out_result;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_canClearBrowserCacheCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_networkAgent->canClearBrowserCache(&error, &out_result);
    if (!error.length()) {
        result->setBoolean("result", out_result);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Network_canClearBrowserCookies(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    bool out_result;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_canClearBrowserCookiesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_networkAgent->canClearBrowserCookies(&error, &out_result);
    if (!error.length()) {
        result->setBoolean("result", out_result);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Network_emulateNetworkConditions(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_offline = getBoolean(paramsContainerPtr, "offline", 0, protocolErrors);
    double in_latency = getDouble(paramsContainerPtr, "latency", 0, protocolErrors);
    double in_downloadThroughput = getDouble(paramsContainerPtr, "downloadThroughput", 0, protocolErrors);
    double in_uploadThroughput = getDouble(paramsContainerPtr, "uploadThroughput", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_emulateNetworkConditionsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->emulateNetworkConditions(&error, in_offline, in_latency, in_downloadThroughput, in_uploadThroughput);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Network_setCacheDisabled(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_cacheDisabled = getBoolean(paramsContainerPtr, "cacheDisabled", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_setCacheDisabledCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->setCacheDisabled(&error, in_cacheDisabled);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Network_setDataSizeLimitsForTest(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_networkAgent)
        protocolErrors->pushString("Network handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_maxTotalSize = getInt(paramsContainerPtr, "maxTotalSize", 0, protocolErrors);
    int in_maxResourceSize = getInt(paramsContainerPtr, "maxResourceSize", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kNetwork_setDataSizeLimitsForTestCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_networkAgent->setDataSizeLimitsForTest(&error, in_maxTotalSize, in_maxResourceSize);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Database_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_databaseAgent)
        protocolErrors->pushString("Database handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDatabase_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_databaseAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Database_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_databaseAgent)
        protocolErrors->pushString("Database handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDatabase_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_databaseAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Database_getDatabaseTableNames(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_databaseAgent)
        protocolErrors->pushString("Database handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_databaseId = getString(paramsContainerPtr, "databaseId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<String> > out_tableNames;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDatabase_getDatabaseTableNamesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_databaseAgent->getDatabaseTableNames(&error, in_databaseId, out_tableNames);
    if (!error.length()) {
        result->setValue("tableNames", out_tableNames);
    }
    sendResponse(sessionId, callId, error, result);
}

InspectorBackendDispatcher::DatabaseCommandHandler::ExecuteSQLCallback::ExecuteSQLCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::DatabaseCommandHandler::ExecuteSQLCallback::sendSuccess(PassRefPtr<TypeBuilder::Array<String> > columnNames, PassRefPtr<TypeBuilder::Array<JSONValue> > values, PassRefPtr<TypeBuilder::Database::Error> sqlError)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    if (columnNames)
        jsonMessage->setValue("columnNames", columnNames);
    if (values)
        jsonMessage->setValue("values", values);
    if (sqlError)
        jsonMessage->setValue("sqlError", static_pointer_cast<JSONValue>(sqlError));
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::Database_executeSQL(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_databaseAgent)
        protocolErrors->pushString("Database handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_databaseId = getString(paramsContainerPtr, "databaseId", 0, protocolErrors);
    String in_query = getString(paramsContainerPtr, "query", 0, protocolErrors);
    RefPtrWillBeRawPtr<DatabaseCommandHandler::ExecuteSQLCallback> callback = adoptRefWillBeNoop(new DatabaseCommandHandler::ExecuteSQLCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDatabase_executeSQLCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_databaseAgent->executeSQL(&error, in_databaseId, in_query, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::IndexedDB_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::IndexedDB_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDatabaseNamesCallback::RequestDatabaseNamesCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDatabaseNamesCallback::sendSuccess(PassRefPtr<TypeBuilder::Array<String> > databaseNames)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setValue("databaseNames", databaseNames);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::IndexedDB_requestDatabaseNames(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_securityOrigin = getString(paramsContainerPtr, "securityOrigin", 0, protocolErrors);
    RefPtrWillBeRawPtr<IndexedDBCommandHandler::RequestDatabaseNamesCallback> callback = adoptRefWillBeNoop(new IndexedDBCommandHandler::RequestDatabaseNamesCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_requestDatabaseNamesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->requestDatabaseNames(&error, in_securityOrigin, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDatabaseCallback::RequestDatabaseCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDatabaseCallback::sendSuccess(PassRefPtr<TypeBuilder::IndexedDB::DatabaseWithObjectStores> databaseWithObjectStores)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setValue("databaseWithObjectStores", static_pointer_cast<JSONValue>(databaseWithObjectStores));
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::IndexedDB_requestDatabase(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_securityOrigin = getString(paramsContainerPtr, "securityOrigin", 0, protocolErrors);
    String in_databaseName = getString(paramsContainerPtr, "databaseName", 0, protocolErrors);
    RefPtrWillBeRawPtr<IndexedDBCommandHandler::RequestDatabaseCallback> callback = adoptRefWillBeNoop(new IndexedDBCommandHandler::RequestDatabaseCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_requestDatabaseCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->requestDatabase(&error, in_securityOrigin, in_databaseName, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDataCallback::RequestDataCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::IndexedDBCommandHandler::RequestDataCallback::sendSuccess(PassRefPtr<TypeBuilder::Array<TypeBuilder::IndexedDB::DataEntry> > objectStoreDataEntries, bool hasMore)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setValue("objectStoreDataEntries", objectStoreDataEntries);
    jsonMessage->setBoolean("hasMore", hasMore);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::IndexedDB_requestData(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_securityOrigin = getString(paramsContainerPtr, "securityOrigin", 0, protocolErrors);
    String in_databaseName = getString(paramsContainerPtr, "databaseName", 0, protocolErrors);
    String in_objectStoreName = getString(paramsContainerPtr, "objectStoreName", 0, protocolErrors);
    String in_indexName = getString(paramsContainerPtr, "indexName", 0, protocolErrors);
    int in_skipCount = getInt(paramsContainerPtr, "skipCount", 0, protocolErrors);
    int in_pageSize = getInt(paramsContainerPtr, "pageSize", 0, protocolErrors);
    bool keyRange_valueFound = false;
    RefPtr<JSONObject> in_keyRange = getObject(paramsContainerPtr, "keyRange", &keyRange_valueFound, protocolErrors);
    RefPtrWillBeRawPtr<IndexedDBCommandHandler::RequestDataCallback> callback = adoptRefWillBeNoop(new IndexedDBCommandHandler::RequestDataCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_requestDataCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->requestData(&error, in_securityOrigin, in_databaseName, in_objectStoreName, in_indexName, in_skipCount, in_pageSize, keyRange_valueFound ? &in_keyRange : 0, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::IndexedDBCommandHandler::ClearObjectStoreCallback::ClearObjectStoreCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::IndexedDBCommandHandler::ClearObjectStoreCallback::sendSuccess()
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::IndexedDB_clearObjectStore(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_indexedDBAgent)
        protocolErrors->pushString("IndexedDB handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_securityOrigin = getString(paramsContainerPtr, "securityOrigin", 0, protocolErrors);
    String in_databaseName = getString(paramsContainerPtr, "databaseName", 0, protocolErrors);
    String in_objectStoreName = getString(paramsContainerPtr, "objectStoreName", 0, protocolErrors);
    RefPtrWillBeRawPtr<IndexedDBCommandHandler::ClearObjectStoreCallback> callback = adoptRefWillBeNoop(new IndexedDBCommandHandler::ClearObjectStoreCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kIndexedDB_clearObjectStoreCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_indexedDBAgent->clearObjectStore(&error, in_securityOrigin, in_databaseName, in_objectStoreName, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::CacheStorageCommandHandler::RequestCacheNamesCallback::RequestCacheNamesCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::CacheStorageCommandHandler::RequestCacheNamesCallback::sendSuccess(PassRefPtr<TypeBuilder::Array<TypeBuilder::CacheStorage::Cache> > caches)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setValue("caches", caches);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::CacheStorage_requestCacheNames(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cacheStorageAgent)
        protocolErrors->pushString("CacheStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_securityOrigin = getString(paramsContainerPtr, "securityOrigin", 0, protocolErrors);
    RefPtrWillBeRawPtr<CacheStorageCommandHandler::RequestCacheNamesCallback> callback = adoptRefWillBeNoop(new CacheStorageCommandHandler::RequestCacheNamesCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCacheStorage_requestCacheNamesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cacheStorageAgent->requestCacheNames(&error, in_securityOrigin, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::CacheStorageCommandHandler::RequestEntriesCallback::RequestEntriesCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::CacheStorageCommandHandler::RequestEntriesCallback::sendSuccess(PassRefPtr<TypeBuilder::Array<TypeBuilder::CacheStorage::DataEntry> > cacheDataEntries, bool hasMore)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setValue("cacheDataEntries", cacheDataEntries);
    jsonMessage->setBoolean("hasMore", hasMore);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::CacheStorage_requestEntries(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cacheStorageAgent)
        protocolErrors->pushString("CacheStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_cacheId = getString(paramsContainerPtr, "cacheId", 0, protocolErrors);
    int in_skipCount = getInt(paramsContainerPtr, "skipCount", 0, protocolErrors);
    int in_pageSize = getInt(paramsContainerPtr, "pageSize", 0, protocolErrors);
    RefPtrWillBeRawPtr<CacheStorageCommandHandler::RequestEntriesCallback> callback = adoptRefWillBeNoop(new CacheStorageCommandHandler::RequestEntriesCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCacheStorage_requestEntriesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cacheStorageAgent->requestEntries(&error, in_cacheId, in_skipCount, in_pageSize, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::CacheStorageCommandHandler::DeleteCacheCallback::DeleteCacheCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::CacheStorageCommandHandler::DeleteCacheCallback::sendSuccess()
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::CacheStorage_deleteCache(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cacheStorageAgent)
        protocolErrors->pushString("CacheStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_cacheId = getString(paramsContainerPtr, "cacheId", 0, protocolErrors);
    RefPtrWillBeRawPtr<CacheStorageCommandHandler::DeleteCacheCallback> callback = adoptRefWillBeNoop(new CacheStorageCommandHandler::DeleteCacheCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCacheStorage_deleteCacheCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cacheStorageAgent->deleteCache(&error, in_cacheId, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::CacheStorageCommandHandler::DeleteEntryCallback::DeleteEntryCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::CacheStorageCommandHandler::DeleteEntryCallback::sendSuccess()
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::CacheStorage_deleteEntry(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cacheStorageAgent)
        protocolErrors->pushString("CacheStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_cacheId = getString(paramsContainerPtr, "cacheId", 0, protocolErrors);
    String in_request = getString(paramsContainerPtr, "request", 0, protocolErrors);
    RefPtrWillBeRawPtr<CacheStorageCommandHandler::DeleteEntryCallback> callback = adoptRefWillBeNoop(new CacheStorageCommandHandler::DeleteEntryCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCacheStorage_deleteEntryCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cacheStorageAgent->deleteEntry(&error, in_cacheId, in_request, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOMStorage_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMStorage_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domStorageAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOMStorage_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMStorage_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domStorageAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOMStorage_getDOMStorageItems(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_storageId = getObject(paramsContainerPtr, "storageId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Array<String> > > out_entries;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMStorage_getDOMStorageItemsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domStorageAgent->getDOMStorageItems(&error, in_storageId, out_entries);
    if (!error.length()) {
        result->setValue("entries", out_entries);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOMStorage_setDOMStorageItem(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_storageId = getObject(paramsContainerPtr, "storageId", 0, protocolErrors);
    String in_key = getString(paramsContainerPtr, "key", 0, protocolErrors);
    String in_value = getString(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMStorage_setDOMStorageItemCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domStorageAgent->setDOMStorageItem(&error, in_storageId, in_key, in_value);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOMStorage_removeDOMStorageItem(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domStorageAgent)
        protocolErrors->pushString("DOMStorage handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_storageId = getObject(paramsContainerPtr, "storageId", 0, protocolErrors);
    String in_key = getString(paramsContainerPtr, "key", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMStorage_removeDOMStorageItemCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domStorageAgent->removeDOMStorageItem(&error, in_storageId, in_key);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::ApplicationCache_getFramesWithManifests(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_applicationCacheAgent)
        protocolErrors->pushString("ApplicationCache handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::ApplicationCache::FrameWithManifest> > out_frameIds;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kApplicationCache_getFramesWithManifestsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_applicationCacheAgent->getFramesWithManifests(&error, out_frameIds);
    if (!error.length()) {
        result->setValue("frameIds", out_frameIds);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::ApplicationCache_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_applicationCacheAgent)
        protocolErrors->pushString("ApplicationCache handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kApplicationCache_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_applicationCacheAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::ApplicationCache_getManifestForFrame(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_applicationCacheAgent)
        protocolErrors->pushString("ApplicationCache handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);

    String out_manifestURL;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kApplicationCache_getManifestForFrameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_applicationCacheAgent->getManifestForFrame(&error, in_frameId, &out_manifestURL);
    if (!error.length()) {
        result->setString("manifestURL", out_manifestURL);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::ApplicationCache_getApplicationCacheForFrame(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_applicationCacheAgent)
        protocolErrors->pushString("ApplicationCache handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);

    RefPtr<TypeBuilder::ApplicationCache::ApplicationCache> out_applicationCache;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kApplicationCache_getApplicationCacheForFrameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_applicationCacheAgent->getApplicationCacheForFrame(&error, in_frameId, out_applicationCache);
    if (!error.length()) {
        result->setValue("applicationCache", static_pointer_cast<JSONValue>(out_applicationCache));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::FileSystem_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::FileSystem_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::FileSystemCommandHandler::RequestFileSystemRootCallback::RequestFileSystemRootCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::FileSystemCommandHandler::RequestFileSystemRootCallback::sendSuccess(int errorCode, PassRefPtr<TypeBuilder::FileSystem::Entry> root)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setNumber("errorCode", errorCode);
    if (root)
        jsonMessage->setValue("root", static_pointer_cast<JSONValue>(root));
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::FileSystem_requestFileSystemRoot(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_origin = getString(paramsContainerPtr, "origin", 0, protocolErrors);
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrors);
    RefPtrWillBeRawPtr<FileSystemCommandHandler::RequestFileSystemRootCallback> callback = adoptRefWillBeNoop(new FileSystemCommandHandler::RequestFileSystemRootCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_requestFileSystemRootCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->requestFileSystemRoot(&error, in_origin, in_type, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::FileSystemCommandHandler::RequestDirectoryContentCallback::RequestDirectoryContentCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::FileSystemCommandHandler::RequestDirectoryContentCallback::sendSuccess(int errorCode, PassRefPtr<TypeBuilder::Array<TypeBuilder::FileSystem::Entry> > entries)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setNumber("errorCode", errorCode);
    if (entries)
        jsonMessage->setValue("entries", entries);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::FileSystem_requestDirectoryContent(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    RefPtrWillBeRawPtr<FileSystemCommandHandler::RequestDirectoryContentCallback> callback = adoptRefWillBeNoop(new FileSystemCommandHandler::RequestDirectoryContentCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_requestDirectoryContentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->requestDirectoryContent(&error, in_url, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::FileSystemCommandHandler::RequestMetadataCallback::RequestMetadataCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::FileSystemCommandHandler::RequestMetadataCallback::sendSuccess(int errorCode, PassRefPtr<TypeBuilder::FileSystem::Metadata> metadata)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setNumber("errorCode", errorCode);
    if (metadata)
        jsonMessage->setValue("metadata", static_pointer_cast<JSONValue>(metadata));
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::FileSystem_requestMetadata(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    RefPtrWillBeRawPtr<FileSystemCommandHandler::RequestMetadataCallback> callback = adoptRefWillBeNoop(new FileSystemCommandHandler::RequestMetadataCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_requestMetadataCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->requestMetadata(&error, in_url, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::FileSystemCommandHandler::RequestFileContentCallback::RequestFileContentCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::FileSystemCommandHandler::RequestFileContentCallback::sendSuccess(int errorCode, const String* const content, const String* const charset)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setNumber("errorCode", errorCode);
    if (content)
        jsonMessage->setString("content", *content);
    if (charset)
        jsonMessage->setString("charset", *charset);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::FileSystem_requestFileContent(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    bool in_readAsText = getBoolean(paramsContainerPtr, "readAsText", 0, protocolErrors);
    bool start_valueFound = false;
    int in_start = getInt(paramsContainerPtr, "start", &start_valueFound, protocolErrors);
    bool end_valueFound = false;
    int in_end = getInt(paramsContainerPtr, "end", &end_valueFound, protocolErrors);
    bool charset_valueFound = false;
    String in_charset = getString(paramsContainerPtr, "charset", &charset_valueFound, protocolErrors);
    RefPtrWillBeRawPtr<FileSystemCommandHandler::RequestFileContentCallback> callback = adoptRefWillBeNoop(new FileSystemCommandHandler::RequestFileContentCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_requestFileContentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->requestFileContent(&error, in_url, in_readAsText, start_valueFound ? &in_start : 0, end_valueFound ? &in_end : 0, charset_valueFound ? &in_charset : 0, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::FileSystemCommandHandler::DeleteEntryCallback::DeleteEntryCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::FileSystemCommandHandler::DeleteEntryCallback::sendSuccess(int errorCode)
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    jsonMessage->setNumber("errorCode", errorCode);
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::FileSystem_deleteEntry(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_fileSystemAgent)
        protocolErrors->pushString("FileSystem handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);
    RefPtrWillBeRawPtr<FileSystemCommandHandler::DeleteEntryCallback> callback = adoptRefWillBeNoop(new FileSystemCommandHandler::DeleteEntryCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kFileSystem_deleteEntryCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_fileSystemAgent->deleteEntry(&error, in_url, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_getDocument(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<TypeBuilder::DOM::Node> out_root;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getDocumentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getDocument(&error, out_root);
    if (!error.length()) {
        result->setValue("root", static_pointer_cast<JSONValue>(out_root));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_requestChildNodes(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    bool depth_valueFound = false;
    int in_depth = getInt(paramsContainerPtr, "depth", &depth_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_requestChildNodesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->requestChildNodes(&error, in_nodeId, depth_valueFound ? &in_depth : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_querySelector(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_selector = getString(paramsContainerPtr, "selector", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_querySelectorCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->querySelector(&error, in_nodeId, in_selector, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_querySelectorAll(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_selector = getString(paramsContainerPtr, "selector", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<int> > out_nodeIds;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_querySelectorAllCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->querySelectorAll(&error, in_nodeId, in_selector, out_nodeIds);
    if (!error.length()) {
        result->setValue("nodeIds", out_nodeIds);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_setNodeName(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_name = getString(paramsContainerPtr, "name", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setNodeNameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->setNodeName(&error, in_nodeId, in_name, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_setNodeValue(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_value = getString(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setNodeValueCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setNodeValue(&error, in_nodeId, in_value);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_removeNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_removeNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->removeNode(&error, in_nodeId);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_setAttributeValue(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_name = getString(paramsContainerPtr, "name", 0, protocolErrors);
    String in_value = getString(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setAttributeValueCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setAttributeValue(&error, in_nodeId, in_name, in_value);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_setAttributesAsText(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_text = getString(paramsContainerPtr, "text", 0, protocolErrors);
    bool name_valueFound = false;
    String in_name = getString(paramsContainerPtr, "name", &name_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setAttributesAsTextCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setAttributesAsText(&error, in_nodeId, in_text, name_valueFound ? &in_name : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_removeAttribute(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_name = getString(paramsContainerPtr, "name", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_removeAttributeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->removeAttribute(&error, in_nodeId, in_name);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_getOuterHTML(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    String out_outerHTML;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getOuterHTMLCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getOuterHTML(&error, in_nodeId, &out_outerHTML);
    if (!error.length()) {
        result->setString("outerHTML", out_outerHTML);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_setOuterHTML(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_outerHTML = getString(paramsContainerPtr, "outerHTML", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setOuterHTMLCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setOuterHTML(&error, in_nodeId, in_outerHTML);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_performSearch(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_query = getString(paramsContainerPtr, "query", 0, protocolErrors);
    bool includeUserAgentShadowDOM_valueFound = false;
    bool in_includeUserAgentShadowDOM = getBoolean(paramsContainerPtr, "includeUserAgentShadowDOM", &includeUserAgentShadowDOM_valueFound, protocolErrors);

    String out_searchId;
    int out_resultCount;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_performSearchCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->performSearch(&error, in_query, includeUserAgentShadowDOM_valueFound ? &in_includeUserAgentShadowDOM : 0, &out_searchId, &out_resultCount);
    if (!error.length()) {
        result->setString("searchId", out_searchId);
        result->setNumber("resultCount", out_resultCount);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_getSearchResults(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_searchId = getString(paramsContainerPtr, "searchId", 0, protocolErrors);
    int in_fromIndex = getInt(paramsContainerPtr, "fromIndex", 0, protocolErrors);
    int in_toIndex = getInt(paramsContainerPtr, "toIndex", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<int> > out_nodeIds;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getSearchResultsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getSearchResults(&error, in_searchId, in_fromIndex, in_toIndex, out_nodeIds);
    if (!error.length()) {
        result->setValue("nodeIds", out_nodeIds);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_discardSearchResults(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_searchId = getString(paramsContainerPtr, "searchId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_discardSearchResultsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->discardSearchResults(&error, in_searchId);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_requestNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_requestNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->requestNode(&error, in_objectId, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_setInspectMode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_mode = getString(paramsContainerPtr, "mode", 0, protocolErrors);
    bool highlightConfig_valueFound = false;
    RefPtr<JSONObject> in_highlightConfig = getObject(paramsContainerPtr, "highlightConfig", &highlightConfig_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setInspectModeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setInspectMode(&error, in_mode, highlightConfig_valueFound ? &in_highlightConfig : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_highlightRect(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_x = getInt(paramsContainerPtr, "x", 0, protocolErrors);
    int in_y = getInt(paramsContainerPtr, "y", 0, protocolErrors);
    int in_width = getInt(paramsContainerPtr, "width", 0, protocolErrors);
    int in_height = getInt(paramsContainerPtr, "height", 0, protocolErrors);
    bool color_valueFound = false;
    RefPtr<JSONObject> in_color = getObject(paramsContainerPtr, "color", &color_valueFound, protocolErrors);
    bool outlineColor_valueFound = false;
    RefPtr<JSONObject> in_outlineColor = getObject(paramsContainerPtr, "outlineColor", &outlineColor_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_highlightRectCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->highlightRect(&error, in_x, in_y, in_width, in_height, color_valueFound ? &in_color : 0, outlineColor_valueFound ? &in_outlineColor : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_highlightQuad(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONArray> in_quad = getArray(paramsContainerPtr, "quad", 0, protocolErrors);
    bool color_valueFound = false;
    RefPtr<JSONObject> in_color = getObject(paramsContainerPtr, "color", &color_valueFound, protocolErrors);
    bool outlineColor_valueFound = false;
    RefPtr<JSONObject> in_outlineColor = getObject(paramsContainerPtr, "outlineColor", &outlineColor_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_highlightQuadCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->highlightQuad(&error, in_quad, color_valueFound ? &in_color : 0, outlineColor_valueFound ? &in_outlineColor : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_highlightNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_highlightConfig = getObject(paramsContainerPtr, "highlightConfig", 0, protocolErrors);
    bool nodeId_valueFound = false;
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", &nodeId_valueFound, protocolErrors);
    bool backendNodeId_valueFound = false;
    int in_backendNodeId = getInt(paramsContainerPtr, "backendNodeId", &backendNodeId_valueFound, protocolErrors);
    bool objectId_valueFound = false;
    String in_objectId = getString(paramsContainerPtr, "objectId", &objectId_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_highlightNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->highlightNode(&error, in_highlightConfig, nodeId_valueFound ? &in_nodeId : 0, backendNodeId_valueFound ? &in_backendNodeId : 0, objectId_valueFound ? &in_objectId : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_hideHighlight(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_hideHighlightCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->hideHighlight(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_highlightFrame(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);
    bool contentColor_valueFound = false;
    RefPtr<JSONObject> in_contentColor = getObject(paramsContainerPtr, "contentColor", &contentColor_valueFound, protocolErrors);
    bool contentOutlineColor_valueFound = false;
    RefPtr<JSONObject> in_contentOutlineColor = getObject(paramsContainerPtr, "contentOutlineColor", &contentOutlineColor_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_highlightFrameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->highlightFrame(&error, in_frameId, contentColor_valueFound ? &in_contentColor : 0, contentOutlineColor_valueFound ? &in_contentOutlineColor : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_pushNodeByPathToFrontend(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_path = getString(paramsContainerPtr, "path", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_pushNodeByPathToFrontendCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->pushNodeByPathToFrontend(&error, in_path, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_pushNodesByBackendIdsToFrontend(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONArray> in_backendNodeIds = getArray(paramsContainerPtr, "backendNodeIds", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<int> > out_nodeIds;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_pushNodesByBackendIdsToFrontendCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->pushNodesByBackendIdsToFrontend(&error, in_backendNodeIds, out_nodeIds);
    if (!error.length()) {
        result->setValue("nodeIds", out_nodeIds);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_setInspectedNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setInspectedNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setInspectedNode(&error, in_nodeId);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_resolveNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_object;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_resolveNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->resolveNode(&error, in_nodeId, objectGroup_valueFound ? &in_objectGroup : 0, out_object);
    if (!error.length()) {
        result->setValue("object", static_pointer_cast<JSONValue>(out_object));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_getAttributes(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<String> > out_attributes;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getAttributesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getAttributes(&error, in_nodeId, out_attributes);
    if (!error.length()) {
        result->setValue("attributes", out_attributes);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_copyTo(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    int in_targetNodeId = getInt(paramsContainerPtr, "targetNodeId", 0, protocolErrors);
    bool insertBeforeNodeId_valueFound = false;
    int in_insertBeforeNodeId = getInt(paramsContainerPtr, "insertBeforeNodeId", &insertBeforeNodeId_valueFound, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_copyToCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->copyTo(&error, in_nodeId, in_targetNodeId, insertBeforeNodeId_valueFound ? &in_insertBeforeNodeId : 0, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_moveTo(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    int in_targetNodeId = getInt(paramsContainerPtr, "targetNodeId", 0, protocolErrors);
    bool insertBeforeNodeId_valueFound = false;
    int in_insertBeforeNodeId = getInt(paramsContainerPtr, "insertBeforeNodeId", &insertBeforeNodeId_valueFound, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_moveToCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->moveTo(&error, in_nodeId, in_targetNodeId, insertBeforeNodeId_valueFound ? &in_insertBeforeNodeId : 0, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_undo(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_undoCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->undo(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_redo(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_redoCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->redo(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_markUndoableState(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_markUndoableStateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->markUndoableState(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_focus(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_focusCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->focus(&error, in_nodeId);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_setFileInputFiles(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    RefPtr<JSONArray> in_files = getArray(paramsContainerPtr, "files", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_setFileInputFilesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domAgent->setFileInputFiles(&error, in_nodeId, in_files);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOM_getBoxModel(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::DOM::BoxModel> out_model;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getBoxModelCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getBoxModel(&error, in_nodeId, out_model);
    if (!error.length()) {
        result->setValue("model", static_pointer_cast<JSONValue>(out_model));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_getNodeForLocation(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_x = getInt(paramsContainerPtr, "x", 0, protocolErrors);
    int in_y = getInt(paramsContainerPtr, "y", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getNodeForLocationCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getNodeForLocation(&error, in_x, in_y, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_getRelayoutBoundary(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    int out_nodeId;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getRelayoutBoundaryCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getRelayoutBoundary(&error, in_nodeId, &out_nodeId);
    if (!error.length()) {
        result->setNumber("nodeId", out_nodeId);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DOM_getHighlightObjectForTest(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domAgent)
        protocolErrors->pushString("DOM handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<JSONObject> out_highlight;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOM_getHighlightObjectForTestCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domAgent->getHighlightObjectForTest(&error, in_nodeId, out_highlight);
    if (!error.length()) {
        result->setValue("highlight", out_highlight);
    }
    sendResponse(sessionId, callId, error, result);
}

InspectorBackendDispatcher::CSSCommandHandler::EnableCallback::EnableCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::CSSCommandHandler::EnableCallback::sendSuccess()
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::CSS_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");
    RefPtrWillBeRawPtr<CSSCommandHandler::EnableCallback> callback = adoptRefWillBeNoop(new CSSCommandHandler::EnableCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cssAgent->enable(&error, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::CSS_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cssAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::CSS_getMatchedStylesForNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::CSS::CSSStyle> out_inlineStyle;
    RefPtr<TypeBuilder::CSS::CSSStyle> out_attributesStyle;
    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::RuleMatch> > out_matchedCSSRules;
    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::PseudoElementMatches> > out_pseudoElements;
    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::InheritedStyleEntry> > out_inherited;
    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSKeyframesRule> > out_cssKeyframesRules;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getMatchedStylesForNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getMatchedStylesForNode(&error, in_nodeId, out_inlineStyle, out_attributesStyle, out_matchedCSSRules, out_pseudoElements, out_inherited, out_cssKeyframesRules);
    if (!error.length()) {
        if (out_inlineStyle)
            result->setValue("inlineStyle", static_pointer_cast<JSONValue>(out_inlineStyle));
        if (out_attributesStyle)
            result->setValue("attributesStyle", static_pointer_cast<JSONValue>(out_attributesStyle));
        if (out_matchedCSSRules)
            result->setValue("matchedCSSRules", out_matchedCSSRules);
        if (out_pseudoElements)
            result->setValue("pseudoElements", out_pseudoElements);
        if (out_inherited)
            result->setValue("inherited", out_inherited);
        if (out_cssKeyframesRules)
            result->setValue("cssKeyframesRules", out_cssKeyframesRules);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_getInlineStylesForNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::CSS::CSSStyle> out_inlineStyle;
    RefPtr<TypeBuilder::CSS::CSSStyle> out_attributesStyle;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getInlineStylesForNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getInlineStylesForNode(&error, in_nodeId, out_inlineStyle, out_attributesStyle);
    if (!error.length()) {
        if (out_inlineStyle)
            result->setValue("inlineStyle", static_pointer_cast<JSONValue>(out_inlineStyle));
        if (out_attributesStyle)
            result->setValue("attributesStyle", static_pointer_cast<JSONValue>(out_attributesStyle));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_getComputedStyleForNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSComputedStyleProperty> > out_computedStyle;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getComputedStyleForNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getComputedStyleForNode(&error, in_nodeId, out_computedStyle);
    if (!error.length()) {
        result->setValue("computedStyle", out_computedStyle);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_getPlatformFontsForNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::PlatformFontUsage> > out_fonts;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getPlatformFontsForNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getPlatformFontsForNode(&error, in_nodeId, out_fonts);
    if (!error.length()) {
        result->setValue("fonts", out_fonts);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_getStyleSheetText(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);

    String out_text;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getStyleSheetTextCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getStyleSheetText(&error, in_styleSheetId, &out_text);
    if (!error.length()) {
        result->setString("text", out_text);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_setStyleSheetText(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);
    String in_text = getString(paramsContainerPtr, "text", 0, protocolErrors);

    TypeBuilder::OptOutput<String> out_sourceMapURL;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_setStyleSheetTextCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->setStyleSheetText(&error, in_styleSheetId, in_text, &out_sourceMapURL);
    if (!error.length()) {
        if (out_sourceMapURL.isAssigned())
            result->setString("sourceMapURL", out_sourceMapURL.getValue());
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_setRuleSelector(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);
    RefPtr<JSONObject> in_range = getObject(paramsContainerPtr, "range", 0, protocolErrors);
    String in_selector = getString(paramsContainerPtr, "selector", 0, protocolErrors);

    RefPtr<TypeBuilder::CSS::SelectorList> out_selectorList;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_setRuleSelectorCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->setRuleSelector(&error, in_styleSheetId, in_range, in_selector, out_selectorList);
    if (!error.length()) {
        result->setValue("selectorList", static_pointer_cast<JSONValue>(out_selectorList));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_setKeyframeKey(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);
    RefPtr<JSONObject> in_range = getObject(paramsContainerPtr, "range", 0, protocolErrors);
    String in_keyText = getString(paramsContainerPtr, "keyText", 0, protocolErrors);

    RefPtr<TypeBuilder::CSS::Value> out_keyText;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_setKeyframeKeyCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->setKeyframeKey(&error, in_styleSheetId, in_range, in_keyText, out_keyText);
    if (!error.length()) {
        result->setValue("keyText", static_pointer_cast<JSONValue>(out_keyText));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_setStyleText(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);
    RefPtr<JSONObject> in_range = getObject(paramsContainerPtr, "range", 0, protocolErrors);
    String in_text = getString(paramsContainerPtr, "text", 0, protocolErrors);

    RefPtr<TypeBuilder::CSS::CSSStyle> out_style;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_setStyleTextCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->setStyleText(&error, in_styleSheetId, in_range, in_text, out_style);
    if (!error.length()) {
        result->setValue("style", static_pointer_cast<JSONValue>(out_style));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_setMediaText(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);
    RefPtr<JSONObject> in_range = getObject(paramsContainerPtr, "range", 0, protocolErrors);
    String in_text = getString(paramsContainerPtr, "text", 0, protocolErrors);

    RefPtr<TypeBuilder::CSS::CSSMedia> out_media;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_setMediaTextCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->setMediaText(&error, in_styleSheetId, in_range, in_text, out_media);
    if (!error.length()) {
        result->setValue("media", static_pointer_cast<JSONValue>(out_media));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_createStyleSheet(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_frameId = getString(paramsContainerPtr, "frameId", 0, protocolErrors);

    TypeBuilder::CSS::StyleSheetId out_styleSheetId;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_createStyleSheetCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->createStyleSheet(&error, in_frameId, &out_styleSheetId);
    if (!error.length()) {
        result->setString("styleSheetId", out_styleSheetId);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_addRule(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_styleSheetId = getString(paramsContainerPtr, "styleSheetId", 0, protocolErrors);
    String in_ruleText = getString(paramsContainerPtr, "ruleText", 0, protocolErrors);
    RefPtr<JSONObject> in_location = getObject(paramsContainerPtr, "location", 0, protocolErrors);

    RefPtr<TypeBuilder::CSS::CSSRule> out_rule;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_addRuleCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->addRule(&error, in_styleSheetId, in_ruleText, in_location, out_rule);
    if (!error.length()) {
        result->setValue("rule", static_pointer_cast<JSONValue>(out_rule));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_forcePseudoState(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    RefPtr<JSONArray> in_forcedPseudoClasses = getArray(paramsContainerPtr, "forcedPseudoClasses", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_forcePseudoStateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cssAgent->forcePseudoState(&error, in_nodeId, in_forcedPseudoClasses);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::CSS_getMediaQueries(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::CSS::CSSMedia> > out_medias;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getMediaQueriesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getMediaQueries(&error, out_medias);
    if (!error.length()) {
        result->setValue("medias", out_medias);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::CSS_setEffectivePropertyValueForNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_propertyName = getString(paramsContainerPtr, "propertyName", 0, protocolErrors);
    String in_value = getString(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_setEffectivePropertyValueForNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_cssAgent->setEffectivePropertyValueForNode(&error, in_nodeId, in_propertyName, in_value);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::CSS_getBackgroundColors(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_cssAgent)
        protocolErrors->pushString("CSS handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<String> > out_backgroundColors;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kCSS_getBackgroundColorsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_cssAgent->getBackgroundColors(&error, in_nodeId, out_backgroundColors);
    if (!error.length()) {
        if (out_backgroundColors)
            result->setValue("backgroundColors", out_backgroundColors);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_setBreakpointsActive(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_active = getBoolean(paramsContainerPtr, "active", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setBreakpointsActiveCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setBreakpointsActive(&error, in_active);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_setSkipAllPauses(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_skipped = getBoolean(paramsContainerPtr, "skipped", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setSkipAllPausesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setSkipAllPauses(&error, in_skipped);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_setBreakpointByUrl(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_lineNumber = getInt(paramsContainerPtr, "lineNumber", 0, protocolErrors);
    bool url_valueFound = false;
    String in_url = getString(paramsContainerPtr, "url", &url_valueFound, protocolErrors);
    bool urlRegex_valueFound = false;
    String in_urlRegex = getString(paramsContainerPtr, "urlRegex", &urlRegex_valueFound, protocolErrors);
    bool columnNumber_valueFound = false;
    int in_columnNumber = getInt(paramsContainerPtr, "columnNumber", &columnNumber_valueFound, protocolErrors);
    bool condition_valueFound = false;
    String in_condition = getString(paramsContainerPtr, "condition", &condition_valueFound, protocolErrors);

    TypeBuilder::Debugger::BreakpointId out_breakpointId;
    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::Location> > out_locations;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setBreakpointByUrlCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->setBreakpointByUrl(&error, in_lineNumber, url_valueFound ? &in_url : 0, urlRegex_valueFound ? &in_urlRegex : 0, columnNumber_valueFound ? &in_columnNumber : 0, condition_valueFound ? &in_condition : 0, &out_breakpointId, out_locations);
    if (!error.length()) {
        result->setString("breakpointId", out_breakpointId);
        result->setValue("locations", out_locations);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_setBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_location = getObject(paramsContainerPtr, "location", 0, protocolErrors);
    bool condition_valueFound = false;
    String in_condition = getString(paramsContainerPtr, "condition", &condition_valueFound, protocolErrors);

    TypeBuilder::Debugger::BreakpointId out_breakpointId;
    RefPtr<TypeBuilder::Debugger::Location> out_actualLocation;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->setBreakpoint(&error, in_location, condition_valueFound ? &in_condition : 0, &out_breakpointId, out_actualLocation);
    if (!error.length()) {
        result->setString("breakpointId", out_breakpointId);
        result->setValue("actualLocation", static_pointer_cast<JSONValue>(out_actualLocation));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_removeBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_breakpointId = getString(paramsContainerPtr, "breakpointId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_removeBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->removeBreakpoint(&error, in_breakpointId);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_continueToLocation(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONObject> in_location = getObject(paramsContainerPtr, "location", 0, protocolErrors);
    bool interstatementLocation_valueFound = false;
    bool in_interstatementLocation = getBoolean(paramsContainerPtr, "interstatementLocation", &interstatementLocation_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_continueToLocationCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->continueToLocation(&error, in_location, interstatementLocation_valueFound ? &in_interstatementLocation : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_stepOver(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_stepOverCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->stepOver(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_stepInto(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_stepIntoCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->stepInto(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_stepOut(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_stepOutCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->stepOut(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_pause(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_pauseCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->pause(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_resume(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_resumeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->resume(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_stepIntoAsync(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_stepIntoAsyncCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->stepIntoAsync(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_searchInContent(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_scriptId = getString(paramsContainerPtr, "scriptId", 0, protocolErrors);
    String in_query = getString(paramsContainerPtr, "query", 0, protocolErrors);
    bool caseSensitive_valueFound = false;
    bool in_caseSensitive = getBoolean(paramsContainerPtr, "caseSensitive", &caseSensitive_valueFound, protocolErrors);
    bool isRegex_valueFound = false;
    bool in_isRegex = getBoolean(paramsContainerPtr, "isRegex", &isRegex_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::SearchMatch> > out_result;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_searchInContentCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->searchInContent(&error, in_scriptId, in_query, caseSensitive_valueFound ? &in_caseSensitive : 0, isRegex_valueFound ? &in_isRegex : 0, out_result);
    if (!error.length()) {
        result->setValue("result", out_result);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_canSetScriptSource(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    bool out_result;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_canSetScriptSourceCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->canSetScriptSource(&error, &out_result);
    if (!error.length()) {
        result->setBoolean("result", out_result);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_setScriptSource(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");
    RefPtr<TypeBuilder::Debugger::SetScriptSourceError> errorData;

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_scriptId = getString(paramsContainerPtr, "scriptId", 0, protocolErrors);
    String in_scriptSource = getString(paramsContainerPtr, "scriptSource", 0, protocolErrors);
    bool preview_valueFound = false;
    bool in_preview = getBoolean(paramsContainerPtr, "preview", &preview_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::CallFrame> > out_callFrames;
    TypeBuilder::OptOutput<bool> out_stackChanged;
    RefPtr<TypeBuilder::Debugger::StackTrace> out_asyncStackTrace;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setScriptSourceCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->setScriptSource(&error, errorData, in_scriptId, in_scriptSource, preview_valueFound ? &in_preview : 0, out_callFrames, &out_stackChanged, out_asyncStackTrace);
    if (!error.length()) {
        if (out_callFrames)
            result->setValue("callFrames", out_callFrames);
        if (out_stackChanged.isAssigned())
            result->setBoolean("stackChanged", out_stackChanged.getValue());
        if (out_asyncStackTrace)
            result->setValue("asyncStackTrace", static_pointer_cast<JSONValue>(out_asyncStackTrace));
    }
    sendResponse(sessionId, callId, error, errorData, result);
}

void InspectorBackendDispatcherImpl::Debugger_restartFrame(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_callFrameId = getString(paramsContainerPtr, "callFrameId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::CallFrame> > out_callFrames;
    RefPtr<TypeBuilder::Debugger::StackTrace> out_asyncStackTrace;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_restartFrameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->restartFrame(&error, in_callFrameId, out_callFrames, out_asyncStackTrace);
    if (!error.length()) {
        result->setValue("callFrames", out_callFrames);
        if (out_asyncStackTrace)
            result->setValue("asyncStackTrace", static_pointer_cast<JSONValue>(out_asyncStackTrace));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_getScriptSource(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_scriptId = getString(paramsContainerPtr, "scriptId", 0, protocolErrors);

    String out_scriptSource;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getScriptSourceCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getScriptSource(&error, in_scriptId, &out_scriptSource);
    if (!error.length()) {
        result->setString("scriptSource", out_scriptSource);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_getFunctionDetails(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_functionId = getString(paramsContainerPtr, "functionId", 0, protocolErrors);

    RefPtr<TypeBuilder::Debugger::FunctionDetails> out_details;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getFunctionDetailsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getFunctionDetails(&error, in_functionId, out_details);
    if (!error.length()) {
        result->setValue("details", static_pointer_cast<JSONValue>(out_details));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_getGeneratorObjectDetails(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);

    RefPtr<TypeBuilder::Debugger::GeneratorObjectDetails> out_details;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getGeneratorObjectDetailsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getGeneratorObjectDetails(&error, in_objectId, out_details);
    if (!error.length()) {
        result->setValue("details", static_pointer_cast<JSONValue>(out_details));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_getCollectionEntries(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::CollectionEntry> > out_entries;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getCollectionEntriesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getCollectionEntries(&error, in_objectId, out_entries);
    if (!error.length()) {
        result->setValue("entries", out_entries);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_setPauseOnExceptions(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_state = getString(paramsContainerPtr, "state", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setPauseOnExceptionsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setPauseOnExceptions(&error, in_state);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_evaluateOnCallFrame(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_callFrameId = getString(paramsContainerPtr, "callFrameId", 0, protocolErrors);
    String in_expression = getString(paramsContainerPtr, "expression", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);
    bool includeCommandLineAPI_valueFound = false;
    bool in_includeCommandLineAPI = getBoolean(paramsContainerPtr, "includeCommandLineAPI", &includeCommandLineAPI_valueFound, protocolErrors);
    bool doNotPauseOnExceptionsAndMuteConsole_valueFound = false;
    bool in_doNotPauseOnExceptionsAndMuteConsole = getBoolean(paramsContainerPtr, "doNotPauseOnExceptionsAndMuteConsole", &doNotPauseOnExceptionsAndMuteConsole_valueFound, protocolErrors);
    bool returnByValue_valueFound = false;
    bool in_returnByValue = getBoolean(paramsContainerPtr, "returnByValue", &returnByValue_valueFound, protocolErrors);
    bool generatePreview_valueFound = false;
    bool in_generatePreview = getBoolean(paramsContainerPtr, "generatePreview", &generatePreview_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;
    TypeBuilder::OptOutput<bool> out_wasThrown;
    RefPtr<TypeBuilder::Runtime::ExceptionDetails> out_exceptionDetails;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_evaluateOnCallFrameCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->evaluateOnCallFrame(&error, in_callFrameId, in_expression, objectGroup_valueFound ? &in_objectGroup : 0, includeCommandLineAPI_valueFound ? &in_includeCommandLineAPI : 0, doNotPauseOnExceptionsAndMuteConsole_valueFound ? &in_doNotPauseOnExceptionsAndMuteConsole : 0, returnByValue_valueFound ? &in_returnByValue : 0, generatePreview_valueFound ? &in_generatePreview : 0, out_result, &out_wasThrown, out_exceptionDetails);
    if (!error.length()) {
        result->setValue("result", static_pointer_cast<JSONValue>(out_result));
        if (out_wasThrown.isAssigned())
            result->setBoolean("wasThrown", out_wasThrown.getValue());
        if (out_exceptionDetails)
            result->setValue("exceptionDetails", static_pointer_cast<JSONValue>(out_exceptionDetails));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_setVariableValue(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_scopeNumber = getInt(paramsContainerPtr, "scopeNumber", 0, protocolErrors);
    String in_variableName = getString(paramsContainerPtr, "variableName", 0, protocolErrors);
    RefPtr<JSONObject> in_newValue = getObject(paramsContainerPtr, "newValue", 0, protocolErrors);
    bool callFrameId_valueFound = false;
    String in_callFrameId = getString(paramsContainerPtr, "callFrameId", &callFrameId_valueFound, protocolErrors);
    bool functionObjectId_valueFound = false;
    String in_functionObjectId = getString(paramsContainerPtr, "functionObjectId", &functionObjectId_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setVariableValueCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setVariableValue(&error, in_scopeNumber, in_variableName, in_newValue, callFrameId_valueFound ? &in_callFrameId : 0, functionObjectId_valueFound ? &in_functionObjectId : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_getStepInPositions(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_callFrameId = getString(paramsContainerPtr, "callFrameId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::Location> > out_stepInPositions;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getStepInPositionsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getStepInPositions(&error, in_callFrameId, out_stepInPositions);
    if (!error.length()) {
        if (out_stepInPositions)
            result->setValue("stepInPositions", out_stepInPositions);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_getBacktrace(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<TypeBuilder::Array<TypeBuilder::Debugger::CallFrame> > out_callFrames;
    RefPtr<TypeBuilder::Debugger::StackTrace> out_asyncStackTrace;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getBacktraceCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getBacktrace(&error, out_callFrames, out_asyncStackTrace);
    if (!error.length()) {
        result->setValue("callFrames", out_callFrames);
        if (out_asyncStackTrace)
            result->setValue("asyncStackTrace", static_pointer_cast<JSONValue>(out_asyncStackTrace));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_setAsyncCallStackDepth(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_maxDepth = getInt(paramsContainerPtr, "maxDepth", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setAsyncCallStackDepthCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setAsyncCallStackDepth(&error, in_maxDepth);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_enablePromiseTracker(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool captureStacks_valueFound = false;
    bool in_captureStacks = getBoolean(paramsContainerPtr, "captureStacks", &captureStacks_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_enablePromiseTrackerCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->enablePromiseTracker(&error, captureStacks_valueFound ? &in_captureStacks : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_disablePromiseTracker(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_disablePromiseTrackerCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->disablePromiseTracker(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_getPromiseById(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_promiseId = getInt(paramsContainerPtr, "promiseId", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_promise;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_getPromiseByIdCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_debuggerAgent->getPromiseById(&error, in_promiseId, objectGroup_valueFound ? &in_objectGroup : 0, out_promise);
    if (!error.length()) {
        result->setValue("promise", static_pointer_cast<JSONValue>(out_promise));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Debugger_flushAsyncOperationEvents(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_flushAsyncOperationEventsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->flushAsyncOperationEvents(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_setAsyncOperationBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_operationId = getInt(paramsContainerPtr, "operationId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setAsyncOperationBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setAsyncOperationBreakpoint(&error, in_operationId);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_removeAsyncOperationBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_operationId = getInt(paramsContainerPtr, "operationId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_removeAsyncOperationBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->removeAsyncOperationBreakpoint(&error, in_operationId);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Debugger_setBlackboxedRanges(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_debuggerAgent)
        protocolErrors->pushString("Debugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_scriptId = getString(paramsContainerPtr, "scriptId", 0, protocolErrors);
    RefPtr<JSONArray> in_positions = getArray(paramsContainerPtr, "positions", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDebugger_setBlackboxedRangesCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_debuggerAgent->setBlackboxedRanges(&error, in_scriptId, in_positions);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_setDOMBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_setDOMBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->setDOMBreakpoint(&error, in_nodeId, in_type);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_removeDOMBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_removeDOMBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->removeDOMBreakpoint(&error, in_nodeId, in_type);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_setEventListenerBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_eventName = getString(paramsContainerPtr, "eventName", 0, protocolErrors);
    bool targetName_valueFound = false;
    String in_targetName = getString(paramsContainerPtr, "targetName", &targetName_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_setEventListenerBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->setEventListenerBreakpoint(&error, in_eventName, targetName_valueFound ? &in_targetName : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_removeEventListenerBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_eventName = getString(paramsContainerPtr, "eventName", 0, protocolErrors);
    bool targetName_valueFound = false;
    String in_targetName = getString(paramsContainerPtr, "targetName", &targetName_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_removeEventListenerBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->removeEventListenerBreakpoint(&error, in_eventName, targetName_valueFound ? &in_targetName : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_setInstrumentationBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_eventName = getString(paramsContainerPtr, "eventName", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_setInstrumentationBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->setInstrumentationBreakpoint(&error, in_eventName);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_removeInstrumentationBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_eventName = getString(paramsContainerPtr, "eventName", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_removeInstrumentationBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->removeInstrumentationBreakpoint(&error, in_eventName);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_setXHRBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_setXHRBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->setXHRBreakpoint(&error, in_url);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_removeXHRBreakpoint(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_url = getString(paramsContainerPtr, "url", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_removeXHRBreakpointCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_domDebuggerAgent->removeXHRBreakpoint(&error, in_url);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DOMDebugger_getEventListeners(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_domDebuggerAgent)
        protocolErrors->pushString("DOMDebugger handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::DOMDebugger::EventListener> > out_listeners;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDOMDebugger_getEventListenersCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_domDebuggerAgent->getEventListeners(&error, in_objectId, out_listeners);
    if (!error.length()) {
        result->setValue("listeners", out_listeners);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Profiler_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kProfiler_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_profilerAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Profiler_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kProfiler_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_profilerAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Profiler_setSamplingInterval(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_interval = getInt(paramsContainerPtr, "interval", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kProfiler_setSamplingIntervalCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_profilerAgent->setSamplingInterval(&error, in_interval);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Profiler_start(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kProfiler_startCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_profilerAgent->start(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Profiler_stop(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_profilerAgent)
        protocolErrors->pushString("Profiler handler is not available.");

    RefPtr<TypeBuilder::Profiler::CPUProfile> out_profile;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kProfiler_stopCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_profilerAgent->stop(&error, out_profile);
    if (!error.length()) {
        result->setValue("profile", static_pointer_cast<JSONValue>(out_profile));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::HeapProfiler_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_startTrackingHeapObjects(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool trackAllocations_valueFound = false;
    bool in_trackAllocations = getBoolean(paramsContainerPtr, "trackAllocations", &trackAllocations_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_startTrackingHeapObjectsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->startTrackingHeapObjects(&error, trackAllocations_valueFound ? &in_trackAllocations : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_stopTrackingHeapObjects(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool reportProgress_valueFound = false;
    bool in_reportProgress = getBoolean(paramsContainerPtr, "reportProgress", &reportProgress_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_stopTrackingHeapObjectsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->stopTrackingHeapObjects(&error, reportProgress_valueFound ? &in_reportProgress : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_takeHeapSnapshot(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool reportProgress_valueFound = false;
    bool in_reportProgress = getBoolean(paramsContainerPtr, "reportProgress", &reportProgress_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_takeHeapSnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->takeHeapSnapshot(&error, reportProgress_valueFound ? &in_reportProgress : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_collectGarbage(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_collectGarbageCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->collectGarbage(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_getObjectByHeapObjectId(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);
    bool objectGroup_valueFound = false;
    String in_objectGroup = getString(paramsContainerPtr, "objectGroup", &objectGroup_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_result;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_getObjectByHeapObjectIdCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_heapProfilerAgent->getObjectByHeapObjectId(&error, in_objectId, objectGroup_valueFound ? &in_objectGroup : 0, out_result);
    if (!error.length()) {
        result->setValue("result", static_pointer_cast<JSONValue>(out_result));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::HeapProfiler_addInspectedHeapObject(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_heapObjectId = getString(paramsContainerPtr, "heapObjectId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_addInspectedHeapObjectCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_heapProfilerAgent->addInspectedHeapObject(&error, in_heapObjectId);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::HeapProfiler_getHeapObjectId(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_heapProfilerAgent)
        protocolErrors->pushString("HeapProfiler handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_objectId = getString(paramsContainerPtr, "objectId", 0, protocolErrors);

    TypeBuilder::HeapProfiler::HeapSnapshotObjectId out_heapSnapshotObjectId;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kHeapProfiler_getHeapObjectIdCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_heapProfilerAgent->getHeapObjectId(&error, in_objectId, &out_heapSnapshotObjectId);
    if (!error.length()) {
        result->setString("heapSnapshotObjectId", out_heapSnapshotObjectId);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Worker_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Worker_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Worker_sendMessageToWorker(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_workerId = getString(paramsContainerPtr, "workerId", 0, protocolErrors);
    String in_message = getString(paramsContainerPtr, "message", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_sendMessageToWorkerCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->sendMessageToWorker(&error, in_workerId, in_message);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Worker_connectToWorker(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_workerId = getString(paramsContainerPtr, "workerId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_connectToWorkerCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->connectToWorker(&error, in_workerId);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Worker_disconnectFromWorker(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_workerId = getString(paramsContainerPtr, "workerId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_disconnectFromWorkerCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->disconnectFromWorker(&error, in_workerId);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Worker_setAutoconnectToWorkers(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_workerAgent)
        protocolErrors->pushString("Worker handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool in_value = getBoolean(paramsContainerPtr, "value", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kWorker_setAutoconnectToWorkersCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_workerAgent->setAutoconnectToWorkers(&error, in_value);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Input_dispatchTouchEvent(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_inputAgent)
        protocolErrors->pushString("Input handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrors);
    RefPtr<JSONArray> in_touchPoints = getArray(paramsContainerPtr, "touchPoints", 0, protocolErrors);
    bool modifiers_valueFound = false;
    int in_modifiers = getInt(paramsContainerPtr, "modifiers", &modifiers_valueFound, protocolErrors);
    bool timestamp_valueFound = false;
    double in_timestamp = getDouble(paramsContainerPtr, "timestamp", &timestamp_valueFound, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kInput_dispatchTouchEventCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_inputAgent->dispatchTouchEvent(&error, in_type, in_touchPoints, modifiers_valueFound ? &in_modifiers : 0, timestamp_valueFound ? &in_timestamp : 0);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::LayerTree_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_layerTreeAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::LayerTree_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_layerTreeAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::LayerTree_compositingReasons(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_layerId = getString(paramsContainerPtr, "layerId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<String> > out_compositingReasons;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_compositingReasonsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->compositingReasons(&error, in_layerId, out_compositingReasons);
    if (!error.length()) {
        result->setValue("compositingReasons", out_compositingReasons);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::LayerTree_makeSnapshot(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_layerId = getString(paramsContainerPtr, "layerId", 0, protocolErrors);

    TypeBuilder::LayerTree::SnapshotId out_snapshotId;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_makeSnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->makeSnapshot(&error, in_layerId, &out_snapshotId);
    if (!error.length()) {
        result->setString("snapshotId", out_snapshotId);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::LayerTree_loadSnapshot(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONArray> in_tiles = getArray(paramsContainerPtr, "tiles", 0, protocolErrors);

    TypeBuilder::LayerTree::SnapshotId out_snapshotId;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_loadSnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->loadSnapshot(&error, in_tiles, &out_snapshotId);
    if (!error.length()) {
        result->setString("snapshotId", out_snapshotId);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::LayerTree_releaseSnapshot(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_snapshotId = getString(paramsContainerPtr, "snapshotId", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_releaseSnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_layerTreeAgent->releaseSnapshot(&error, in_snapshotId);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::LayerTree_profileSnapshot(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_snapshotId = getString(paramsContainerPtr, "snapshotId", 0, protocolErrors);
    bool minRepeatCount_valueFound = false;
    int in_minRepeatCount = getInt(paramsContainerPtr, "minRepeatCount", &minRepeatCount_valueFound, protocolErrors);
    bool minDuration_valueFound = false;
    double in_minDuration = getDouble(paramsContainerPtr, "minDuration", &minDuration_valueFound, protocolErrors);
    bool clipRect_valueFound = false;
    RefPtr<JSONObject> in_clipRect = getObject(paramsContainerPtr, "clipRect", &clipRect_valueFound, protocolErrors);

    RefPtr<TypeBuilder::Array<TypeBuilder::Array<double> > > out_timings;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_profileSnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->profileSnapshot(&error, in_snapshotId, minRepeatCount_valueFound ? &in_minRepeatCount : 0, minDuration_valueFound ? &in_minDuration : 0, clipRect_valueFound ? &in_clipRect : 0, out_timings);
    if (!error.length()) {
        result->setValue("timings", out_timings);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::LayerTree_replaySnapshot(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_snapshotId = getString(paramsContainerPtr, "snapshotId", 0, protocolErrors);
    bool fromStep_valueFound = false;
    int in_fromStep = getInt(paramsContainerPtr, "fromStep", &fromStep_valueFound, protocolErrors);
    bool toStep_valueFound = false;
    int in_toStep = getInt(paramsContainerPtr, "toStep", &toStep_valueFound, protocolErrors);
    bool scale_valueFound = false;
    double in_scale = getDouble(paramsContainerPtr, "scale", &scale_valueFound, protocolErrors);

    String out_dataURL;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_replaySnapshotCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->replaySnapshot(&error, in_snapshotId, fromStep_valueFound ? &in_fromStep : 0, toStep_valueFound ? &in_toStep : 0, scale_valueFound ? &in_scale : 0, &out_dataURL);
    if (!error.length()) {
        result->setString("dataURL", out_dataURL);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::LayerTree_snapshotCommandLog(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_layerTreeAgent)
        protocolErrors->pushString("LayerTree handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_snapshotId = getString(paramsContainerPtr, "snapshotId", 0, protocolErrors);

    RefPtr<TypeBuilder::Array<JSONObject> > out_commandLog;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kLayerTree_snapshotCommandLogCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_layerTreeAgent->snapshotCommandLog(&error, in_snapshotId, out_commandLog);
    if (!error.length()) {
        result->setValue("commandLog", out_commandLog);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::DeviceOrientation_setDeviceOrientationOverride(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_deviceOrientationAgent)
        protocolErrors->pushString("DeviceOrientation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    double in_alpha = getDouble(paramsContainerPtr, "alpha", 0, protocolErrors);
    double in_beta = getDouble(paramsContainerPtr, "beta", 0, protocolErrors);
    double in_gamma = getDouble(paramsContainerPtr, "gamma", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDeviceOrientation_setDeviceOrientationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_deviceOrientationAgent->setDeviceOrientationOverride(&error, in_alpha, in_beta, in_gamma);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::DeviceOrientation_clearDeviceOrientationOverride(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_deviceOrientationAgent)
        protocolErrors->pushString("DeviceOrientation handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kDeviceOrientation_clearDeviceOrientationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_deviceOrientationAgent->clearDeviceOrientationOverride(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::ScreenOrientation_setScreenOrientationOverride(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_screenOrientationAgent)
        protocolErrors->pushString("ScreenOrientation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_angle = getInt(paramsContainerPtr, "angle", 0, protocolErrors);
    String in_type = getString(paramsContainerPtr, "type", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kScreenOrientation_setScreenOrientationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_screenOrientationAgent->setScreenOrientationOverride(&error, in_angle, in_type);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::ScreenOrientation_clearScreenOrientationOverride(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_screenOrientationAgent)
        protocolErrors->pushString("ScreenOrientation handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kScreenOrientation_clearScreenOrientationOverrideCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_screenOrientationAgent->clearScreenOrientationOverride(&error);

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::TracingCommandHandler::StartCallback::StartCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::TracingCommandHandler::StartCallback::sendSuccess()
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::Tracing_start(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_tracingAgent)
        protocolErrors->pushString("Tracing handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    bool categories_valueFound = false;
    String in_categories = getString(paramsContainerPtr, "categories", &categories_valueFound, protocolErrors);
    bool options_valueFound = false;
    String in_options = getString(paramsContainerPtr, "options", &options_valueFound, protocolErrors);
    bool bufferUsageReportingInterval_valueFound = false;
    double in_bufferUsageReportingInterval = getDouble(paramsContainerPtr, "bufferUsageReportingInterval", &bufferUsageReportingInterval_valueFound, protocolErrors);
    bool transferMode_valueFound = false;
    String in_transferMode = getString(paramsContainerPtr, "transferMode", &transferMode_valueFound, protocolErrors);
    RefPtrWillBeRawPtr<TracingCommandHandler::StartCallback> callback = adoptRefWillBeNoop(new TracingCommandHandler::StartCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kTracing_startCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_tracingAgent->start(&error, categories_valueFound ? &in_categories : 0, options_valueFound ? &in_options : 0, bufferUsageReportingInterval_valueFound ? &in_bufferUsageReportingInterval : 0, transferMode_valueFound ? &in_transferMode : 0, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

InspectorBackendDispatcher::TracingCommandHandler::EndCallback::EndCallback(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id) : CallbackBase(backendImpl, sessionId, id) {}

void InspectorBackendDispatcher::TracingCommandHandler::EndCallback::sendSuccess()
{
    RefPtr<JSONObject> jsonMessage = JSONObject::create();
    sendIfActive(jsonMessage, ErrorString(), PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::Tracing_end(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_tracingAgent)
        protocolErrors->pushString("Tracing handler is not available.");
    RefPtrWillBeRawPtr<TracingCommandHandler::EndCallback> callback = adoptRefWillBeNoop(new TracingCommandHandler::EndCallback(this, sessionId, callId));

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kTracing_endCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_tracingAgent->end(&error, callback);
    if (!error.length()) 
        return;
    callback->disable();

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Animation_enable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_animationAgent)
        protocolErrors->pushString("Animation handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAnimation_enableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_animationAgent->enable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Animation_disable(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_animationAgent)
        protocolErrors->pushString("Animation handler is not available.");

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAnimation_disableCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_animationAgent->disable(&error);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Animation_getPlaybackRate(int sessionId, int callId, JSONObject*, JSONArray* protocolErrors)
{
    if (!m_animationAgent)
        protocolErrors->pushString("Animation handler is not available.");

    double out_playbackRate;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAnimation_getPlaybackRateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_animationAgent->getPlaybackRate(&error, &out_playbackRate);
    if (!error.length()) {
        result->setNumber("playbackRate", out_playbackRate);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Animation_setPlaybackRate(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_animationAgent)
        protocolErrors->pushString("Animation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    double in_playbackRate = getDouble(paramsContainerPtr, "playbackRate", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAnimation_setPlaybackRateCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_animationAgent->setPlaybackRate(&error, in_playbackRate);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Animation_getCurrentTime(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_animationAgent)
        protocolErrors->pushString("Animation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_id = getString(paramsContainerPtr, "id", 0, protocolErrors);

    double out_currentTime;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAnimation_getCurrentTimeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_animationAgent->getCurrentTime(&error, in_id, &out_currentTime);
    if (!error.length()) {
        result->setNumber("currentTime", out_currentTime);
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Animation_setPaused(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_animationAgent)
        protocolErrors->pushString("Animation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONArray> in_animations = getArray(paramsContainerPtr, "animations", 0, protocolErrors);
    bool in_paused = getBoolean(paramsContainerPtr, "paused", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAnimation_setPausedCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_animationAgent->setPaused(&error, in_animations, in_paused);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Animation_setTiming(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_animationAgent)
        protocolErrors->pushString("Animation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_animationId = getString(paramsContainerPtr, "animationId", 0, protocolErrors);
    double in_duration = getDouble(paramsContainerPtr, "duration", 0, protocolErrors);
    double in_delay = getDouble(paramsContainerPtr, "delay", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAnimation_setTimingCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_animationAgent->setTiming(&error, in_animationId, in_duration, in_delay);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Animation_seekAnimations(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_animationAgent)
        protocolErrors->pushString("Animation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONArray> in_animations = getArray(paramsContainerPtr, "animations", 0, protocolErrors);
    double in_currentTime = getDouble(paramsContainerPtr, "currentTime", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAnimation_seekAnimationsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_animationAgent->seekAnimations(&error, in_animations, in_currentTime);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Animation_releaseAnimations(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_animationAgent)
        protocolErrors->pushString("Animation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    RefPtr<JSONArray> in_animations = getArray(paramsContainerPtr, "animations", 0, protocolErrors);

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAnimation_releaseAnimationsCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    m_animationAgent->releaseAnimations(&error, in_animations);

    sendResponse(sessionId, callId, error);
}

void InspectorBackendDispatcherImpl::Animation_resolveAnimation(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_animationAgent)
        protocolErrors->pushString("Animation handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    String in_animationId = getString(paramsContainerPtr, "animationId", 0, protocolErrors);

    RefPtr<TypeBuilder::Runtime::RemoteObject> out_remoteObject;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAnimation_resolveAnimationCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_animationAgent->resolveAnimation(&error, in_animationId, out_remoteObject);
    if (!error.length()) {
        result->setValue("remoteObject", static_pointer_cast<JSONValue>(out_remoteObject));
    }
    sendResponse(sessionId, callId, error, result);
}

void InspectorBackendDispatcherImpl::Accessibility_getAXNode(int sessionId, int callId, JSONObject* requestMessageObject, JSONArray* protocolErrors)
{
    if (!m_accessibilityAgent)
        protocolErrors->pushString("Accessibility handler is not available.");

    RefPtr<JSONObject> paramsContainer = requestMessageObject->getObject("params");
    JSONObject* paramsContainerPtr = paramsContainer.get();
    int in_nodeId = getInt(paramsContainerPtr, "nodeId", 0, protocolErrors);

    RefPtr<TypeBuilder::Accessibility::AXNode> out_accessibilityNode;

    if (protocolErrors->length()) {
        reportProtocolError(sessionId, callId, InvalidParams, String::format(InvalidParamsFormatString, commandName(kAccessibility_getAXNodeCmd)), protocolErrors);
        return;
    }
    ErrorString error;
    RefPtr<JSONObject> result = JSONObject::create();
    m_accessibilityAgent->getAXNode(&error, in_nodeId, out_accessibilityNode);
    if (!error.length()) {
        if (out_accessibilityNode)
            result->setValue("accessibilityNode", static_pointer_cast<JSONValue>(out_accessibilityNode));
    }
    sendResponse(sessionId, callId, error, result);
}


PassRefPtrWillBeRawPtr<InspectorBackendDispatcher> InspectorBackendDispatcher::create(InspectorFrontendChannel* inspectorFrontendChannel)
{
    return adoptRefWillBeNoop(new InspectorBackendDispatcherImpl(inspectorFrontendChannel));
}


void InspectorBackendDispatcherImpl::dispatch(int sessionId, const String& message)
{
    RefPtrWillBeRawPtr<InspectorBackendDispatcher> protect(this);
    int callId = 0;
    RefPtr<JSONValue> parsedMessage = parseJSON(message);
    ASSERT(parsedMessage);
    RefPtr<JSONObject> messageObject = parsedMessage->asObject();
    ASSERT(messageObject);

    RefPtr<JSONValue> callIdValue = messageObject->get("id");
    bool success = callIdValue->asNumber(&callId);
    ASSERT_UNUSED(success, success);

    RefPtr<JSONValue> methodValue = messageObject->get("method");
    String method;
    success = methodValue && methodValue->asString(&method);
    ASSERT_UNUSED(success, success);

    HashMap<String, CallHandler>::iterator it = m_dispatchMap.find(method);
    if (it == m_dispatchMap.end()) {
        reportProtocolError(sessionId, callId, MethodNotFound, "'" + method + "' wasn't found");
        return;
    }

    RefPtr<JSONArray> protocolErrors = JSONArray::create();
    ((*this).*it->value)(sessionId, callId, messageObject.get(), protocolErrors.get());
}

void InspectorBackendDispatcherImpl::sendResponse(int sessionId, int callId, const ErrorString& invocationError, PassRefPtr<JSONValue> errorData, PassRefPtr<JSONObject> result)
{
    if (invocationError.length()) {
        reportProtocolError(sessionId, callId, ServerError, invocationError, errorData);
        return;
    }

    RefPtr<JSONObject> responseMessage = JSONObject::create();
    responseMessage->setNumber("id", callId);
    responseMessage->setObject("result", result);
    if (m_inspectorFrontendChannel)
        m_inspectorFrontendChannel->sendProtocolResponse(sessionId, callId, responseMessage.release());
}

void InspectorBackendDispatcher::reportProtocolError(int sessionId, int callId, CommonErrorCode code, const String& errorMessage) const
{
    reportProtocolError(sessionId, callId, code, errorMessage, PassRefPtr<JSONValue>());
}

void InspectorBackendDispatcherImpl::reportProtocolError(int sessionId, int callId, CommonErrorCode code, const String& errorMessage, PassRefPtr<JSONValue> data) const
{
    ASSERT(code >=0);
    ASSERT((unsigned)code < m_commonErrors.size());
    ASSERT(m_commonErrors[code]);
    RefPtr<JSONObject> error = JSONObject::create();
    error->setNumber("code", m_commonErrors[code]);
    error->setString("message", errorMessage);
    ASSERT(error);
    if (data)
        error->setValue("data", data);
    RefPtr<JSONObject> message = JSONObject::create();
    message->setObject("error", error);
    message->setNumber("id", callId);
    if (m_inspectorFrontendChannel)
        m_inspectorFrontendChannel->sendProtocolResponse(sessionId, callId, message.release());
}

template<typename R, typename V, typename V0>
R InspectorBackendDispatcherImpl::getPropertyValueImpl(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors, V0 initial_value, bool (*as_method)(JSONValue*, V*), const char* type_name)
{
    ASSERT(protocolErrors);

    if (valueFound)
        *valueFound = false;

    V value = initial_value;

    if (!object) {
        if (!valueFound) {
            // Required parameter in missing params container.
            protocolErrors->pushString(String::format("'params' object must contain required parameter '%s' with type '%s'.", name, type_name));
        }
        return value;
    }

    JSONObject::const_iterator end = object->end();
    JSONObject::const_iterator valueIterator = object->find(name);

    if (valueIterator == end) {
        if (!valueFound)
            protocolErrors->pushString(String::format("Parameter '%s' with type '%s' was not found.", name, type_name));
        return value;
    }

    if (!as_method(valueIterator->value.get(), &value))
        protocolErrors->pushString(String::format("Parameter '%s' has wrong type. It must be '%s'.", name, type_name));
    else
        if (valueFound)
            *valueFound = true;
    return value;
}

struct AsMethodBridges {
    static bool asInt(JSONValue* value, int* output) { return value->asNumber(output); }
    static bool asDouble(JSONValue* value, double* output) { return value->asNumber(output); }
    static bool asString(JSONValue* value, String* output) { return value->asString(output); }
    static bool asBoolean(JSONValue* value, bool* output) { return value->asBoolean(output); }
    static bool asObject(JSONValue* value, RefPtr<JSONObject>* output) { return value->asObject(output); }
    static bool asArray(JSONValue* value, RefPtr<JSONArray>* output) { return value->asArray(output); }
};

int InspectorBackendDispatcherImpl::getInt(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<int, int, int>(object, name, valueFound, protocolErrors, 0, AsMethodBridges::asInt, "Number");
}

double InspectorBackendDispatcherImpl::getDouble(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<double, double, double>(object, name, valueFound, protocolErrors, 0, AsMethodBridges::asDouble, "Number");
}

String InspectorBackendDispatcherImpl::getString(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<String, String, String>(object, name, valueFound, protocolErrors, "", AsMethodBridges::asString, "String");
}

bool InspectorBackendDispatcherImpl::getBoolean(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<bool, bool, bool>(object, name, valueFound, protocolErrors, false, AsMethodBridges::asBoolean, "Boolean");
}

PassRefPtr<JSONObject> InspectorBackendDispatcherImpl::getObject(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<PassRefPtr<JSONObject>, RefPtr<JSONObject>, JSONObject*>(object, name, valueFound, protocolErrors, 0, AsMethodBridges::asObject, "Object");
}

PassRefPtr<JSONArray> InspectorBackendDispatcherImpl::getArray(JSONObject* object, const char* name, bool* valueFound, JSONArray* protocolErrors)
{
    return getPropertyValueImpl<PassRefPtr<JSONArray>, RefPtr<JSONArray>, JSONArray*>(object, name, valueFound, protocolErrors, 0, AsMethodBridges::asArray, "Array");
}

bool InspectorBackendDispatcher::getCommandName(const String& message, String* result)
{
    RefPtr<JSONValue> value = parseJSON(message);
    if (!value)
        return false;

    RefPtr<JSONObject> object = value->asObject();
    if (!object)
        return false;

    if (!object->getString("method", result))
        return false;

    return true;
}

InspectorBackendDispatcher::CallbackBase::CallbackBase(PassRefPtrWillBeRawPtr<InspectorBackendDispatcherImpl> backendImpl, int sessionId, int id)
    : m_backendImpl(backendImpl), m_sessionId(sessionId), m_id(id), m_alreadySent(false) {}

InspectorBackendDispatcher::CallbackBase::~CallbackBase() {}

DEFINE_TRACE(InspectorBackendDispatcher::CallbackBase)
{
    visitor->trace(m_backendImpl);
}

void InspectorBackendDispatcher::CallbackBase::sendFailure(const ErrorString& error)
{
    ASSERT(error.length());
    sendIfActive(nullptr, error, PassRefPtr<JSONValue>());
}

bool InspectorBackendDispatcher::CallbackBase::isActive()
{
    return !m_alreadySent && m_backendImpl->isActive();
}

void InspectorBackendDispatcher::CallbackBase::sendIfActive(PassRefPtr<JSONObject> partialMessage, const ErrorString& invocationError, PassRefPtr<JSONValue> errorData)
{
    if (m_alreadySent)
        return;
    m_backendImpl->sendResponse(m_sessionId, m_id, invocationError, errorData, partialMessage);
    m_alreadySent = true;
}

} // namespace blink

