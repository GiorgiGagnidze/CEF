// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py. DO NOT MODIFY!

#ifndef UnionTypeCore_h
#define UnionTypeCore_h

#include "bindings/core/v8/Dictionary.h"
#include "bindings/core/v8/ExceptionState.h"
#include "bindings/core/v8/V8Binding.h"
#include "bindings/core/v8/V8EventListenerOptions.h"
#include "core/CoreExport.h"
#include "platform/heap/Handle.h"

namespace blink {

class AudioTrack;
class Blob;
class DOMArrayBuffer;
class DOMArrayBufferView;
class Document;
class EffectModel;
class Element;
class File;
class FormData;
class HTMLCanvasElement;
class HTMLElement;
class HTMLImageElement;
class HTMLOptGroupElement;
class HTMLOptionElement;
class HTMLVideoElement;
class ImageBitmap;
class ImageData;
class NodeList;
class RadioNodeList;
class StyleValue;
class TextTrack;
class URLSearchParams;
class VideoTrack;

class CORE_EXPORT ArrayBufferOrArrayBufferView final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    ArrayBufferOrArrayBufferView();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isArrayBuffer() const { return m_type == SpecificTypeArrayBuffer; }
    PassRefPtr<DOMArrayBuffer> getAsArrayBuffer() const;
    void setArrayBuffer(PassRefPtr<DOMArrayBuffer>);
    static ArrayBufferOrArrayBufferView fromArrayBuffer(PassRefPtr<DOMArrayBuffer>);

    bool isArrayBufferView() const { return m_type == SpecificTypeArrayBufferView; }
    PassRefPtr<DOMArrayBufferView> getAsArrayBufferView() const;
    void setArrayBufferView(PassRefPtr<DOMArrayBufferView>);
    static ArrayBufferOrArrayBufferView fromArrayBufferView(PassRefPtr<DOMArrayBufferView>);

    ArrayBufferOrArrayBufferView(const ArrayBufferOrArrayBufferView&);
    ~ArrayBufferOrArrayBufferView();
    ArrayBufferOrArrayBufferView& operator=(const ArrayBufferOrArrayBufferView&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeArrayBuffer,
        SpecificTypeArrayBufferView,
    };
    SpecificTypes m_type;

    RefPtr<DOMArrayBuffer> m_arrayBuffer;
    RefPtr<DOMArrayBufferView> m_arrayBufferView;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferView&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8ArrayBufferOrArrayBufferView final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, ArrayBufferOrArrayBufferView&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferView&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, ArrayBufferOrArrayBufferView& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<ArrayBufferOrArrayBufferView> {
    CORE_EXPORT static ArrayBufferOrArrayBufferView nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isArrayBuffer() const { return m_type == SpecificTypeArrayBuffer; }
    PassRefPtr<DOMArrayBuffer> getAsArrayBuffer() const;
    void setArrayBuffer(PassRefPtr<DOMArrayBuffer>);
    static ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData fromArrayBuffer(PassRefPtr<DOMArrayBuffer>);

    bool isArrayBufferView() const { return m_type == SpecificTypeArrayBufferView; }
    PassRefPtr<DOMArrayBufferView> getAsArrayBufferView() const;
    void setArrayBufferView(PassRefPtr<DOMArrayBufferView>);
    static ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData fromArrayBufferView(PassRefPtr<DOMArrayBufferView>);

    bool isBlob() const { return m_type == SpecificTypeBlob; }
    Blob* getAsBlob() const;
    void setBlob(Blob*);
    static ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData fromBlob(Blob*);

    bool isDocument() const { return m_type == SpecificTypeDocument; }
    PassRefPtrWillBeRawPtr<Document> getAsDocument() const;
    void setDocument(PassRefPtrWillBeRawPtr<Document>);
    static ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData fromDocument(PassRefPtrWillBeRawPtr<Document>);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData fromString(String);

    bool isFormData() const { return m_type == SpecificTypeFormData; }
    FormData* getAsFormData() const;
    void setFormData(FormData*);
    static ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData fromFormData(FormData*);

    ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData(const ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData&);
    ~ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData();
    ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData& operator=(const ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeArrayBuffer,
        SpecificTypeArrayBufferView,
        SpecificTypeBlob,
        SpecificTypeDocument,
        SpecificTypeString,
        SpecificTypeFormData,
    };
    SpecificTypes m_type;

    RefPtr<DOMArrayBuffer> m_arrayBuffer;
    RefPtr<DOMArrayBufferView> m_arrayBufferView;
    Member<Blob> m_blob;
    RefPtrWillBeMember<Document> m_document;
    String m_string;
    Member<FormData> m_formData;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData> {
    CORE_EXPORT static ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT ArrayBufferOrArrayBufferViewOrBlobOrString final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    ArrayBufferOrArrayBufferViewOrBlobOrString();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isArrayBuffer() const { return m_type == SpecificTypeArrayBuffer; }
    PassRefPtr<DOMArrayBuffer> getAsArrayBuffer() const;
    void setArrayBuffer(PassRefPtr<DOMArrayBuffer>);
    static ArrayBufferOrArrayBufferViewOrBlobOrString fromArrayBuffer(PassRefPtr<DOMArrayBuffer>);

    bool isArrayBufferView() const { return m_type == SpecificTypeArrayBufferView; }
    PassRefPtr<DOMArrayBufferView> getAsArrayBufferView() const;
    void setArrayBufferView(PassRefPtr<DOMArrayBufferView>);
    static ArrayBufferOrArrayBufferViewOrBlobOrString fromArrayBufferView(PassRefPtr<DOMArrayBufferView>);

    bool isBlob() const { return m_type == SpecificTypeBlob; }
    Blob* getAsBlob() const;
    void setBlob(Blob*);
    static ArrayBufferOrArrayBufferViewOrBlobOrString fromBlob(Blob*);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static ArrayBufferOrArrayBufferViewOrBlobOrString fromString(String);

    ArrayBufferOrArrayBufferViewOrBlobOrString(const ArrayBufferOrArrayBufferViewOrBlobOrString&);
    ~ArrayBufferOrArrayBufferViewOrBlobOrString();
    ArrayBufferOrArrayBufferViewOrBlobOrString& operator=(const ArrayBufferOrArrayBufferViewOrBlobOrString&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeArrayBuffer,
        SpecificTypeArrayBufferView,
        SpecificTypeBlob,
        SpecificTypeString,
    };
    SpecificTypes m_type;

    RefPtr<DOMArrayBuffer> m_arrayBuffer;
    RefPtr<DOMArrayBufferView> m_arrayBufferView;
    Member<Blob> m_blob;
    String m_string;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferViewOrBlobOrString&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8ArrayBufferOrArrayBufferViewOrBlobOrString final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, ArrayBufferOrArrayBufferViewOrBlobOrString&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const ArrayBufferOrArrayBufferViewOrBlobOrString&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, ArrayBufferOrArrayBufferViewOrBlobOrString& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<ArrayBufferOrArrayBufferViewOrBlobOrString> {
    CORE_EXPORT static ArrayBufferOrArrayBufferViewOrBlobOrString nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT BlobOrStringOrArrayBufferViewOrArrayBuffer final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    BlobOrStringOrArrayBufferViewOrArrayBuffer();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isBlob() const { return m_type == SpecificTypeBlob; }
    Blob* getAsBlob() const;
    void setBlob(Blob*);
    static BlobOrStringOrArrayBufferViewOrArrayBuffer fromBlob(Blob*);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static BlobOrStringOrArrayBufferViewOrArrayBuffer fromString(String);

    bool isArrayBufferView() const { return m_type == SpecificTypeArrayBufferView; }
    PassRefPtr<DOMArrayBufferView> getAsArrayBufferView() const;
    void setArrayBufferView(PassRefPtr<DOMArrayBufferView>);
    static BlobOrStringOrArrayBufferViewOrArrayBuffer fromArrayBufferView(PassRefPtr<DOMArrayBufferView>);

    bool isArrayBuffer() const { return m_type == SpecificTypeArrayBuffer; }
    PassRefPtr<DOMArrayBuffer> getAsArrayBuffer() const;
    void setArrayBuffer(PassRefPtr<DOMArrayBuffer>);
    static BlobOrStringOrArrayBufferViewOrArrayBuffer fromArrayBuffer(PassRefPtr<DOMArrayBuffer>);

    BlobOrStringOrArrayBufferViewOrArrayBuffer(const BlobOrStringOrArrayBufferViewOrArrayBuffer&);
    ~BlobOrStringOrArrayBufferViewOrArrayBuffer();
    BlobOrStringOrArrayBufferViewOrArrayBuffer& operator=(const BlobOrStringOrArrayBufferViewOrArrayBuffer&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeBlob,
        SpecificTypeString,
        SpecificTypeArrayBufferView,
        SpecificTypeArrayBuffer,
    };
    SpecificTypes m_type;

    Member<Blob> m_blob;
    String m_string;
    RefPtr<DOMArrayBufferView> m_arrayBufferView;
    RefPtr<DOMArrayBuffer> m_arrayBuffer;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const BlobOrStringOrArrayBufferViewOrArrayBuffer&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8BlobOrStringOrArrayBufferViewOrArrayBuffer final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, BlobOrStringOrArrayBufferViewOrArrayBuffer&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const BlobOrStringOrArrayBufferViewOrArrayBuffer&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, BlobOrStringOrArrayBufferViewOrArrayBuffer& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<BlobOrStringOrArrayBufferViewOrArrayBuffer> {
    CORE_EXPORT static BlobOrStringOrArrayBufferViewOrArrayBuffer nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT DoubleOrAutoKeyword final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    DoubleOrAutoKeyword();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isDouble() const { return m_type == SpecificTypeDouble; }
    double getAsDouble() const;
    void setDouble(double);
    static DoubleOrAutoKeyword fromDouble(double);

    bool isAutoKeyword() const { return m_type == SpecificTypeAutoKeyword; }
    String getAsAutoKeyword() const;
    void setAutoKeyword(String);
    static DoubleOrAutoKeyword fromAutoKeyword(String);

    DoubleOrAutoKeyword(const DoubleOrAutoKeyword&);
    ~DoubleOrAutoKeyword();
    DoubleOrAutoKeyword& operator=(const DoubleOrAutoKeyword&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeDouble,
        SpecificTypeAutoKeyword,
    };
    SpecificTypes m_type;

    double m_double;
    String m_autoKeyword;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrAutoKeyword&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8DoubleOrAutoKeyword final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, DoubleOrAutoKeyword&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrAutoKeyword&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, DoubleOrAutoKeyword& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<DoubleOrAutoKeyword> {
    CORE_EXPORT static DoubleOrAutoKeyword nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT DoubleOrDoubleArray final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    DoubleOrDoubleArray();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isDouble() const { return m_type == SpecificTypeDouble; }
    double getAsDouble() const;
    void setDouble(double);
    static DoubleOrDoubleArray fromDouble(double);

    bool isDoubleArray() const { return m_type == SpecificTypeDoubleArray; }
    const Vector<double>& getAsDoubleArray() const;
    void setDoubleArray(const Vector<double>&);
    static DoubleOrDoubleArray fromDoubleArray(const Vector<double>&);

    DoubleOrDoubleArray(const DoubleOrDoubleArray&);
    ~DoubleOrDoubleArray();
    DoubleOrDoubleArray& operator=(const DoubleOrDoubleArray&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeDouble,
        SpecificTypeDoubleArray,
    };
    SpecificTypes m_type;

    double m_double;
    Vector<double> m_doubleArray;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrDoubleArray&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8DoubleOrDoubleArray final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, DoubleOrDoubleArray&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrDoubleArray&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, DoubleOrDoubleArray& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<DoubleOrDoubleArray> {
    CORE_EXPORT static DoubleOrDoubleArray nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT DoubleOrInternalEnum final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    DoubleOrInternalEnum();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isDouble() const { return m_type == SpecificTypeDouble; }
    double getAsDouble() const;
    void setDouble(double);
    static DoubleOrInternalEnum fromDouble(double);

    bool isInternalEnum() const { return m_type == SpecificTypeInternalEnum; }
    String getAsInternalEnum() const;
    void setInternalEnum(String);
    static DoubleOrInternalEnum fromInternalEnum(String);

    DoubleOrInternalEnum(const DoubleOrInternalEnum&);
    ~DoubleOrInternalEnum();
    DoubleOrInternalEnum& operator=(const DoubleOrInternalEnum&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeDouble,
        SpecificTypeInternalEnum,
    };
    SpecificTypes m_type;

    double m_double;
    String m_internalEnum;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrInternalEnum&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8DoubleOrInternalEnum final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, DoubleOrInternalEnum&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrInternalEnum&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, DoubleOrInternalEnum& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<DoubleOrInternalEnum> {
    CORE_EXPORT static DoubleOrInternalEnum nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT DoubleOrString final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    DoubleOrString();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isDouble() const { return m_type == SpecificTypeDouble; }
    double getAsDouble() const;
    void setDouble(double);
    static DoubleOrString fromDouble(double);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static DoubleOrString fromString(String);

    DoubleOrString(const DoubleOrString&);
    ~DoubleOrString();
    DoubleOrString& operator=(const DoubleOrString&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeDouble,
        SpecificTypeString,
    };
    SpecificTypes m_type;

    double m_double;
    String m_string;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrString&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8DoubleOrString final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, DoubleOrString&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrString&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, DoubleOrString& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<DoubleOrString> {
    CORE_EXPORT static DoubleOrString nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT DoubleOrStringOrStringArray final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    DoubleOrStringOrStringArray();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isDouble() const { return m_type == SpecificTypeDouble; }
    double getAsDouble() const;
    void setDouble(double);
    static DoubleOrStringOrStringArray fromDouble(double);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static DoubleOrStringOrStringArray fromString(String);

    bool isStringArray() const { return m_type == SpecificTypeStringArray; }
    const Vector<String>& getAsStringArray() const;
    void setStringArray(const Vector<String>&);
    static DoubleOrStringOrStringArray fromStringArray(const Vector<String>&);

    DoubleOrStringOrStringArray(const DoubleOrStringOrStringArray&);
    ~DoubleOrStringOrStringArray();
    DoubleOrStringOrStringArray& operator=(const DoubleOrStringOrStringArray&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeDouble,
        SpecificTypeString,
        SpecificTypeStringArray,
    };
    SpecificTypes m_type;

    double m_double;
    String m_string;
    Vector<String> m_stringArray;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrStringOrStringArray&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8DoubleOrStringOrStringArray final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, DoubleOrStringOrStringArray&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrStringOrStringArray&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, DoubleOrStringOrStringArray& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<DoubleOrStringOrStringArray> {
    CORE_EXPORT static DoubleOrStringOrStringArray nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT DoubleOrStringOrStringSequence final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    DoubleOrStringOrStringSequence();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isDouble() const { return m_type == SpecificTypeDouble; }
    double getAsDouble() const;
    void setDouble(double);
    static DoubleOrStringOrStringSequence fromDouble(double);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static DoubleOrStringOrStringSequence fromString(String);

    bool isStringSequence() const { return m_type == SpecificTypeStringSequence; }
    const Vector<String>& getAsStringSequence() const;
    void setStringSequence(const Vector<String>&);
    static DoubleOrStringOrStringSequence fromStringSequence(const Vector<String>&);

    DoubleOrStringOrStringSequence(const DoubleOrStringOrStringSequence&);
    ~DoubleOrStringOrStringSequence();
    DoubleOrStringOrStringSequence& operator=(const DoubleOrStringOrStringSequence&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeDouble,
        SpecificTypeString,
        SpecificTypeStringSequence,
    };
    SpecificTypes m_type;

    double m_double;
    String m_string;
    Vector<String> m_stringSequence;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrStringOrStringSequence&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8DoubleOrStringOrStringSequence final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, DoubleOrStringOrStringSequence&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const DoubleOrStringOrStringSequence&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, DoubleOrStringOrStringSequence& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<DoubleOrStringOrStringSequence> {
    CORE_EXPORT static DoubleOrStringOrStringSequence nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT EffectModelOrDictionarySequenceOrDictionary final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    EffectModelOrDictionarySequenceOrDictionary();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isEffectModel() const { return m_type == SpecificTypeEffectModel; }
    EffectModel* getAsEffectModel() const;
    void setEffectModel(EffectModel*);
    static EffectModelOrDictionarySequenceOrDictionary fromEffectModel(EffectModel*);

    bool isDictionarySequence() const { return m_type == SpecificTypeDictionarySequence; }
    const Vector<Dictionary>& getAsDictionarySequence() const;
    void setDictionarySequence(const Vector<Dictionary>&);
    static EffectModelOrDictionarySequenceOrDictionary fromDictionarySequence(const Vector<Dictionary>&);

    bool isDictionary() const { return m_type == SpecificTypeDictionary; }
    Dictionary getAsDictionary() const;
    void setDictionary(Dictionary);
    static EffectModelOrDictionarySequenceOrDictionary fromDictionary(Dictionary);

    EffectModelOrDictionarySequenceOrDictionary(const EffectModelOrDictionarySequenceOrDictionary&);
    ~EffectModelOrDictionarySequenceOrDictionary();
    EffectModelOrDictionarySequenceOrDictionary& operator=(const EffectModelOrDictionarySequenceOrDictionary&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeEffectModel,
        SpecificTypeDictionarySequence,
        SpecificTypeDictionary,
    };
    SpecificTypes m_type;

    Member<EffectModel> m_effectModel;
    Vector<Dictionary> m_dictionarySequence;
    Dictionary m_dictionary;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const EffectModelOrDictionarySequenceOrDictionary&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8EffectModelOrDictionarySequenceOrDictionary final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, EffectModelOrDictionarySequenceOrDictionary&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const EffectModelOrDictionarySequenceOrDictionary&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, EffectModelOrDictionarySequenceOrDictionary& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<EffectModelOrDictionarySequenceOrDictionary> {
    CORE_EXPORT static EffectModelOrDictionarySequenceOrDictionary nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT EventListenerOptionsOrBoolean final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    EventListenerOptionsOrBoolean();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isEventListenerOptions() const { return m_type == SpecificTypeEventListenerOptions; }
    EventListenerOptions getAsEventListenerOptions() const;
    void setEventListenerOptions(EventListenerOptions);
    static EventListenerOptionsOrBoolean fromEventListenerOptions(EventListenerOptions);

    bool isBoolean() const { return m_type == SpecificTypeBoolean; }
    bool getAsBoolean() const;
    void setBoolean(bool);
    static EventListenerOptionsOrBoolean fromBoolean(bool);

    EventListenerOptionsOrBoolean(const EventListenerOptionsOrBoolean&);
    ~EventListenerOptionsOrBoolean();
    EventListenerOptionsOrBoolean& operator=(const EventListenerOptionsOrBoolean&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeEventListenerOptions,
        SpecificTypeBoolean,
    };
    SpecificTypes m_type;

    EventListenerOptions m_eventListenerOptions;
    bool m_boolean;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const EventListenerOptionsOrBoolean&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8EventListenerOptionsOrBoolean final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, EventListenerOptionsOrBoolean&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const EventListenerOptionsOrBoolean&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, EventListenerOptionsOrBoolean& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<EventListenerOptionsOrBoolean> {
    CORE_EXPORT static EventListenerOptionsOrBoolean nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT FileOrUSVString final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    FileOrUSVString();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isFile() const { return m_type == SpecificTypeFile; }
    File* getAsFile() const;
    void setFile(File*);
    static FileOrUSVString fromFile(File*);

    bool isUSVString() const { return m_type == SpecificTypeUSVString; }
    String getAsUSVString() const;
    void setUSVString(String);
    static FileOrUSVString fromUSVString(String);

    FileOrUSVString(const FileOrUSVString&);
    ~FileOrUSVString();
    FileOrUSVString& operator=(const FileOrUSVString&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeFile,
        SpecificTypeUSVString,
    };
    SpecificTypes m_type;

    Member<File> m_file;
    String m_uSVString;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const FileOrUSVString&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8FileOrUSVString final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, FileOrUSVString&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const FileOrUSVString&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, FileOrUSVString& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<FileOrUSVString> {
    CORE_EXPORT static FileOrUSVString nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT HTMLElementOrLong final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    HTMLElementOrLong();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isHTMLElement() const { return m_type == SpecificTypeHTMLElement; }
    PassRefPtrWillBeRawPtr<HTMLElement> getAsHTMLElement() const;
    void setHTMLElement(PassRefPtrWillBeRawPtr<HTMLElement>);
    static HTMLElementOrLong fromHTMLElement(PassRefPtrWillBeRawPtr<HTMLElement>);

    bool isLong() const { return m_type == SpecificTypeLong; }
    int getAsLong() const;
    void setLong(int);
    static HTMLElementOrLong fromLong(int);

    HTMLElementOrLong(const HTMLElementOrLong&);
    ~HTMLElementOrLong();
    HTMLElementOrLong& operator=(const HTMLElementOrLong&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeHTMLElement,
        SpecificTypeLong,
    };
    SpecificTypes m_type;

    RefPtrWillBeMember<HTMLElement> m_htmlElement;
    int m_long;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const HTMLElementOrLong&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8HTMLElementOrLong final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, HTMLElementOrLong&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const HTMLElementOrLong&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, HTMLElementOrLong& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<HTMLElementOrLong> {
    CORE_EXPORT static HTMLElementOrLong nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isHTMLImageElement() const { return m_type == SpecificTypeHTMLImageElement; }
    PassRefPtrWillBeRawPtr<HTMLImageElement> getAsHTMLImageElement() const;
    void setHTMLImageElement(PassRefPtrWillBeRawPtr<HTMLImageElement>);
    static HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap fromHTMLImageElement(PassRefPtrWillBeRawPtr<HTMLImageElement>);

    bool isHTMLVideoElement() const { return m_type == SpecificTypeHTMLVideoElement; }
    PassRefPtrWillBeRawPtr<HTMLVideoElement> getAsHTMLVideoElement() const;
    void setHTMLVideoElement(PassRefPtrWillBeRawPtr<HTMLVideoElement>);
    static HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap fromHTMLVideoElement(PassRefPtrWillBeRawPtr<HTMLVideoElement>);

    bool isHTMLCanvasElement() const { return m_type == SpecificTypeHTMLCanvasElement; }
    PassRefPtrWillBeRawPtr<HTMLCanvasElement> getAsHTMLCanvasElement() const;
    void setHTMLCanvasElement(PassRefPtrWillBeRawPtr<HTMLCanvasElement>);
    static HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap fromHTMLCanvasElement(PassRefPtrWillBeRawPtr<HTMLCanvasElement>);

    bool isBlob() const { return m_type == SpecificTypeBlob; }
    Blob* getAsBlob() const;
    void setBlob(Blob*);
    static HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap fromBlob(Blob*);

    bool isImageData() const { return m_type == SpecificTypeImageData; }
    ImageData* getAsImageData() const;
    void setImageData(ImageData*);
    static HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap fromImageData(ImageData*);

    bool isImageBitmap() const { return m_type == SpecificTypeImageBitmap; }
    PassRefPtrWillBeRawPtr<ImageBitmap> getAsImageBitmap() const;
    void setImageBitmap(PassRefPtrWillBeRawPtr<ImageBitmap>);
    static HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap fromImageBitmap(PassRefPtrWillBeRawPtr<ImageBitmap>);

    HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap(const HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap&);
    ~HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap();
    HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap& operator=(const HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeHTMLImageElement,
        SpecificTypeHTMLVideoElement,
        SpecificTypeHTMLCanvasElement,
        SpecificTypeBlob,
        SpecificTypeImageData,
        SpecificTypeImageBitmap,
    };
    SpecificTypes m_type;

    RefPtrWillBeMember<HTMLImageElement> m_htmlImageElement;
    RefPtrWillBeMember<HTMLVideoElement> m_htmlVideoElement;
    RefPtrWillBeMember<HTMLCanvasElement> m_htmlCanvasElement;
    Member<Blob> m_blob;
    Member<ImageData> m_imageData;
    RefPtrWillBeMember<ImageBitmap> m_imageBitmap;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap> {
    CORE_EXPORT static HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT HTMLOptionElementOrHTMLOptGroupElement final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    HTMLOptionElementOrHTMLOptGroupElement();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isHTMLOptionElement() const { return m_type == SpecificTypeHTMLOptionElement; }
    PassRefPtrWillBeRawPtr<HTMLOptionElement> getAsHTMLOptionElement() const;
    void setHTMLOptionElement(PassRefPtrWillBeRawPtr<HTMLOptionElement>);
    static HTMLOptionElementOrHTMLOptGroupElement fromHTMLOptionElement(PassRefPtrWillBeRawPtr<HTMLOptionElement>);

    bool isHTMLOptGroupElement() const { return m_type == SpecificTypeHTMLOptGroupElement; }
    PassRefPtrWillBeRawPtr<HTMLOptGroupElement> getAsHTMLOptGroupElement() const;
    void setHTMLOptGroupElement(PassRefPtrWillBeRawPtr<HTMLOptGroupElement>);
    static HTMLOptionElementOrHTMLOptGroupElement fromHTMLOptGroupElement(PassRefPtrWillBeRawPtr<HTMLOptGroupElement>);

    HTMLOptionElementOrHTMLOptGroupElement(const HTMLOptionElementOrHTMLOptGroupElement&);
    ~HTMLOptionElementOrHTMLOptGroupElement();
    HTMLOptionElementOrHTMLOptGroupElement& operator=(const HTMLOptionElementOrHTMLOptGroupElement&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeHTMLOptionElement,
        SpecificTypeHTMLOptGroupElement,
    };
    SpecificTypes m_type;

    RefPtrWillBeMember<HTMLOptionElement> m_htmlOptionElement;
    RefPtrWillBeMember<HTMLOptGroupElement> m_htmlOptGroupElement;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const HTMLOptionElementOrHTMLOptGroupElement&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8HTMLOptionElementOrHTMLOptGroupElement final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, HTMLOptionElementOrHTMLOptGroupElement&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const HTMLOptionElementOrHTMLOptGroupElement&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, HTMLOptionElementOrHTMLOptGroupElement& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<HTMLOptionElementOrHTMLOptGroupElement> {
    CORE_EXPORT static HTMLOptionElementOrHTMLOptGroupElement nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT NodeListOrElement final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    NodeListOrElement();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isNodeList() const { return m_type == SpecificTypeNodeList; }
    PassRefPtrWillBeRawPtr<NodeList> getAsNodeList() const;
    void setNodeList(PassRefPtrWillBeRawPtr<NodeList>);
    static NodeListOrElement fromNodeList(PassRefPtrWillBeRawPtr<NodeList>);

    bool isElement() const { return m_type == SpecificTypeElement; }
    PassRefPtrWillBeRawPtr<Element> getAsElement() const;
    void setElement(PassRefPtrWillBeRawPtr<Element>);
    static NodeListOrElement fromElement(PassRefPtrWillBeRawPtr<Element>);

    NodeListOrElement(const NodeListOrElement&);
    ~NodeListOrElement();
    NodeListOrElement& operator=(const NodeListOrElement&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeNodeList,
        SpecificTypeElement,
    };
    SpecificTypes m_type;

    RefPtrWillBeMember<NodeList> m_nodeList;
    RefPtrWillBeMember<Element> m_element;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const NodeListOrElement&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8NodeListOrElement final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, NodeListOrElement&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const NodeListOrElement&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, NodeListOrElement& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<NodeListOrElement> {
    CORE_EXPORT static NodeListOrElement nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT RadioNodeListOrElement final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    RadioNodeListOrElement();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isRadioNodeList() const { return m_type == SpecificTypeRadioNodeList; }
    PassRefPtrWillBeRawPtr<RadioNodeList> getAsRadioNodeList() const;
    void setRadioNodeList(PassRefPtrWillBeRawPtr<RadioNodeList>);
    static RadioNodeListOrElement fromRadioNodeList(PassRefPtrWillBeRawPtr<RadioNodeList>);

    bool isElement() const { return m_type == SpecificTypeElement; }
    PassRefPtrWillBeRawPtr<Element> getAsElement() const;
    void setElement(PassRefPtrWillBeRawPtr<Element>);
    static RadioNodeListOrElement fromElement(PassRefPtrWillBeRawPtr<Element>);

    RadioNodeListOrElement(const RadioNodeListOrElement&);
    ~RadioNodeListOrElement();
    RadioNodeListOrElement& operator=(const RadioNodeListOrElement&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeRadioNodeList,
        SpecificTypeElement,
    };
    SpecificTypes m_type;

    RefPtrWillBeMember<RadioNodeList> m_radioNodeList;
    RefPtrWillBeMember<Element> m_element;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const RadioNodeListOrElement&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8RadioNodeListOrElement final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, RadioNodeListOrElement&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const RadioNodeListOrElement&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, RadioNodeListOrElement& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<RadioNodeListOrElement> {
    CORE_EXPORT static RadioNodeListOrElement nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT StringOrArrayBuffer final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    StringOrArrayBuffer();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static StringOrArrayBuffer fromString(String);

    bool isArrayBuffer() const { return m_type == SpecificTypeArrayBuffer; }
    PassRefPtr<DOMArrayBuffer> getAsArrayBuffer() const;
    void setArrayBuffer(PassRefPtr<DOMArrayBuffer>);
    static StringOrArrayBuffer fromArrayBuffer(PassRefPtr<DOMArrayBuffer>);

    StringOrArrayBuffer(const StringOrArrayBuffer&);
    ~StringOrArrayBuffer();
    StringOrArrayBuffer& operator=(const StringOrArrayBuffer&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeString,
        SpecificTypeArrayBuffer,
    };
    SpecificTypes m_type;

    String m_string;
    RefPtr<DOMArrayBuffer> m_arrayBuffer;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const StringOrArrayBuffer&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8StringOrArrayBuffer final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, StringOrArrayBuffer&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const StringOrArrayBuffer&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, StringOrArrayBuffer& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<StringOrArrayBuffer> {
    CORE_EXPORT static StringOrArrayBuffer nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT StringOrArrayBufferOrArrayBufferView final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    StringOrArrayBufferOrArrayBufferView();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static StringOrArrayBufferOrArrayBufferView fromString(String);

    bool isArrayBuffer() const { return m_type == SpecificTypeArrayBuffer; }
    PassRefPtr<DOMArrayBuffer> getAsArrayBuffer() const;
    void setArrayBuffer(PassRefPtr<DOMArrayBuffer>);
    static StringOrArrayBufferOrArrayBufferView fromArrayBuffer(PassRefPtr<DOMArrayBuffer>);

    bool isArrayBufferView() const { return m_type == SpecificTypeArrayBufferView; }
    PassRefPtr<DOMArrayBufferView> getAsArrayBufferView() const;
    void setArrayBufferView(PassRefPtr<DOMArrayBufferView>);
    static StringOrArrayBufferOrArrayBufferView fromArrayBufferView(PassRefPtr<DOMArrayBufferView>);

    StringOrArrayBufferOrArrayBufferView(const StringOrArrayBufferOrArrayBufferView&);
    ~StringOrArrayBufferOrArrayBufferView();
    StringOrArrayBufferOrArrayBufferView& operator=(const StringOrArrayBufferOrArrayBufferView&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeString,
        SpecificTypeArrayBuffer,
        SpecificTypeArrayBufferView,
    };
    SpecificTypes m_type;

    String m_string;
    RefPtr<DOMArrayBuffer> m_arrayBuffer;
    RefPtr<DOMArrayBufferView> m_arrayBufferView;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const StringOrArrayBufferOrArrayBufferView&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8StringOrArrayBufferOrArrayBufferView final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, StringOrArrayBufferOrArrayBufferView&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const StringOrArrayBufferOrArrayBufferView&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, StringOrArrayBufferOrArrayBufferView& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<StringOrArrayBufferOrArrayBufferView> {
    CORE_EXPORT static StringOrArrayBufferOrArrayBufferView nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT StringOrFloat final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    StringOrFloat();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static StringOrFloat fromString(String);

    bool isFloat() const { return m_type == SpecificTypeFloat; }
    float getAsFloat() const;
    void setFloat(float);
    static StringOrFloat fromFloat(float);

    StringOrFloat(const StringOrFloat&);
    ~StringOrFloat();
    StringOrFloat& operator=(const StringOrFloat&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeString,
        SpecificTypeFloat,
    };
    SpecificTypes m_type;

    String m_string;
    float m_float;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const StringOrFloat&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8StringOrFloat final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, StringOrFloat&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const StringOrFloat&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, StringOrFloat& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<StringOrFloat> {
    CORE_EXPORT static StringOrFloat nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT StyleValueOrStyleValueSequence final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    StyleValueOrStyleValueSequence();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isStyleValue() const { return m_type == SpecificTypeStyleValue; }
    StyleValue* getAsStyleValue() const;
    void setStyleValue(StyleValue*);
    static StyleValueOrStyleValueSequence fromStyleValue(StyleValue*);

    bool isStyleValueSequence() const { return m_type == SpecificTypeStyleValueSequence; }
    const HeapVector<Member<StyleValue>>& getAsStyleValueSequence() const;
    void setStyleValueSequence(const HeapVector<Member<StyleValue>>&);
    static StyleValueOrStyleValueSequence fromStyleValueSequence(const HeapVector<Member<StyleValue>>&);

    StyleValueOrStyleValueSequence(const StyleValueOrStyleValueSequence&);
    ~StyleValueOrStyleValueSequence();
    StyleValueOrStyleValueSequence& operator=(const StyleValueOrStyleValueSequence&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeStyleValue,
        SpecificTypeStyleValueSequence,
    };
    SpecificTypes m_type;

    Member<StyleValue> m_styleValue;
    HeapVector<Member<StyleValue>> m_styleValueSequence;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const StyleValueOrStyleValueSequence&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8StyleValueOrStyleValueSequence final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, StyleValueOrStyleValueSequence&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const StyleValueOrStyleValueSequence&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, StyleValueOrStyleValueSequence& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<StyleValueOrStyleValueSequence> {
    CORE_EXPORT static StyleValueOrStyleValueSequence nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT StyleValueOrStyleValueSequenceOrString final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    StyleValueOrStyleValueSequenceOrString();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isStyleValue() const { return m_type == SpecificTypeStyleValue; }
    StyleValue* getAsStyleValue() const;
    void setStyleValue(StyleValue*);
    static StyleValueOrStyleValueSequenceOrString fromStyleValue(StyleValue*);

    bool isStyleValueSequence() const { return m_type == SpecificTypeStyleValueSequence; }
    const HeapVector<Member<StyleValue>>& getAsStyleValueSequence() const;
    void setStyleValueSequence(const HeapVector<Member<StyleValue>>&);
    static StyleValueOrStyleValueSequenceOrString fromStyleValueSequence(const HeapVector<Member<StyleValue>>&);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static StyleValueOrStyleValueSequenceOrString fromString(String);

    StyleValueOrStyleValueSequenceOrString(const StyleValueOrStyleValueSequenceOrString&);
    ~StyleValueOrStyleValueSequenceOrString();
    StyleValueOrStyleValueSequenceOrString& operator=(const StyleValueOrStyleValueSequenceOrString&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeStyleValue,
        SpecificTypeStyleValueSequence,
        SpecificTypeString,
    };
    SpecificTypes m_type;

    Member<StyleValue> m_styleValue;
    HeapVector<Member<StyleValue>> m_styleValueSequence;
    String m_string;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const StyleValueOrStyleValueSequenceOrString&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8StyleValueOrStyleValueSequenceOrString final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, StyleValueOrStyleValueSequenceOrString&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const StyleValueOrStyleValueSequenceOrString&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, StyleValueOrStyleValueSequenceOrString& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<StyleValueOrStyleValueSequenceOrString> {
    CORE_EXPORT static StyleValueOrStyleValueSequenceOrString nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT USVStringOrURLSearchParams final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    USVStringOrURLSearchParams();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isUSVString() const { return m_type == SpecificTypeUSVString; }
    String getAsUSVString() const;
    void setUSVString(String);
    static USVStringOrURLSearchParams fromUSVString(String);

    bool isURLSearchParams() const { return m_type == SpecificTypeURLSearchParams; }
    URLSearchParams* getAsURLSearchParams() const;
    void setURLSearchParams(URLSearchParams*);
    static USVStringOrURLSearchParams fromURLSearchParams(URLSearchParams*);

    USVStringOrURLSearchParams(const USVStringOrURLSearchParams&);
    ~USVStringOrURLSearchParams();
    USVStringOrURLSearchParams& operator=(const USVStringOrURLSearchParams&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeUSVString,
        SpecificTypeURLSearchParams,
    };
    SpecificTypes m_type;

    String m_uSVString;
    Member<URLSearchParams> m_urlSearchParams;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const USVStringOrURLSearchParams&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8USVStringOrURLSearchParams final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, USVStringOrURLSearchParams&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const USVStringOrURLSearchParams&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, USVStringOrURLSearchParams& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<USVStringOrURLSearchParams> {
    CORE_EXPORT static USVStringOrURLSearchParams nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT UnrestrictedDoubleOrString final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    UnrestrictedDoubleOrString();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isUnrestrictedDouble() const { return m_type == SpecificTypeUnrestrictedDouble; }
    double getAsUnrestrictedDouble() const;
    void setUnrestrictedDouble(double);
    static UnrestrictedDoubleOrString fromUnrestrictedDouble(double);

    bool isString() const { return m_type == SpecificTypeString; }
    String getAsString() const;
    void setString(String);
    static UnrestrictedDoubleOrString fromString(String);

    UnrestrictedDoubleOrString(const UnrestrictedDoubleOrString&);
    ~UnrestrictedDoubleOrString();
    UnrestrictedDoubleOrString& operator=(const UnrestrictedDoubleOrString&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeUnrestrictedDouble,
        SpecificTypeString,
    };
    SpecificTypes m_type;

    double m_unrestrictedDouble;
    String m_string;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const UnrestrictedDoubleOrString&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8UnrestrictedDoubleOrString final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, UnrestrictedDoubleOrString&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const UnrestrictedDoubleOrString&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, UnrestrictedDoubleOrString& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<UnrestrictedDoubleOrString> {
    CORE_EXPORT static UnrestrictedDoubleOrString nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

class CORE_EXPORT VideoTrackOrAudioTrackOrTextTrack final {
    DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
public:
    VideoTrackOrAudioTrackOrTextTrack();
    bool isNull() const { return m_type == SpecificTypeNone; }

    bool isVideoTrack() const { return m_type == SpecificTypeVideoTrack; }
    VideoTrack* getAsVideoTrack() const;
    void setVideoTrack(VideoTrack*);
    static VideoTrackOrAudioTrackOrTextTrack fromVideoTrack(VideoTrack*);

    bool isAudioTrack() const { return m_type == SpecificTypeAudioTrack; }
    AudioTrack* getAsAudioTrack() const;
    void setAudioTrack(AudioTrack*);
    static VideoTrackOrAudioTrackOrTextTrack fromAudioTrack(AudioTrack*);

    bool isTextTrack() const { return m_type == SpecificTypeTextTrack; }
    TextTrack* getAsTextTrack() const;
    void setTextTrack(TextTrack*);
    static VideoTrackOrAudioTrackOrTextTrack fromTextTrack(TextTrack*);

    VideoTrackOrAudioTrackOrTextTrack(const VideoTrackOrAudioTrackOrTextTrack&);
    ~VideoTrackOrAudioTrackOrTextTrack();
    VideoTrackOrAudioTrackOrTextTrack& operator=(const VideoTrackOrAudioTrackOrTextTrack&);
    DECLARE_TRACE();

private:
    enum SpecificTypes {
        SpecificTypeNone,
        SpecificTypeVideoTrack,
        SpecificTypeAudioTrack,
        SpecificTypeTextTrack,
    };
    SpecificTypes m_type;

    Member<VideoTrack> m_videoTrack;
    Member<AudioTrack> m_audioTrack;
    Member<TextTrack> m_textTrack;

    friend CORE_EXPORT v8::Local<v8::Value> toV8(const VideoTrackOrAudioTrackOrTextTrack&, v8::Local<v8::Object>, v8::Isolate*);
};

class V8VideoTrackOrAudioTrackOrTextTrack final {
public:
    CORE_EXPORT static void toImpl(v8::Isolate*, v8::Local<v8::Value>, VideoTrackOrAudioTrackOrTextTrack&, UnionTypeConversionMode, ExceptionState&);
};

CORE_EXPORT v8::Local<v8::Value> toV8(const VideoTrackOrAudioTrackOrTextTrack&, v8::Local<v8::Object>, v8::Isolate*);

template <class CallbackInfo>
inline void v8SetReturnValue(const CallbackInfo& callbackInfo, VideoTrackOrAudioTrackOrTextTrack& impl)
{
    v8SetReturnValue(callbackInfo, toV8(impl, callbackInfo.Holder(), callbackInfo.GetIsolate()));
}

template <>
struct NativeValueTraits<VideoTrackOrAudioTrackOrTextTrack> {
    CORE_EXPORT static VideoTrackOrAudioTrackOrTextTrack nativeValue(v8::Isolate*, v8::Local<v8::Value>, ExceptionState&);
};

} // namespace blink

// We need to set canInitializeWithMemset=true because HeapVector supports
// items that can initialize with memset or have a vtable. It is safe to
// set canInitializeWithMemset=true for a union type object in practice.
// See https://codereview.chromium.org/1118993002/#msg5 for more details.
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::ArrayBufferOrArrayBufferView);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::ArrayBufferOrArrayBufferViewOrBlobOrDocumentOrStringOrFormData);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::ArrayBufferOrArrayBufferViewOrBlobOrString);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::BlobOrStringOrArrayBufferViewOrArrayBuffer);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::DoubleOrAutoKeyword);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::DoubleOrDoubleArray);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::DoubleOrInternalEnum);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::DoubleOrString);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::DoubleOrStringOrStringArray);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::DoubleOrStringOrStringSequence);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::EffectModelOrDictionarySequenceOrDictionary);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::EventListenerOptionsOrBoolean);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::FileOrUSVString);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::HTMLElementOrLong);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::HTMLImageElementOrHTMLVideoElementOrHTMLCanvasElementOrBlobOrImageDataOrImageBitmap);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::HTMLOptionElementOrHTMLOptGroupElement);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::NodeListOrElement);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::RadioNodeListOrElement);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::StringOrArrayBuffer);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::StringOrArrayBufferOrArrayBufferView);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::StringOrFloat);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::StyleValueOrStyleValueSequence);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::StyleValueOrStyleValueSequenceOrString);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::USVStringOrURLSearchParams);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::UnrestrictedDoubleOrString);
WTF_ALLOW_MOVE_AND_INIT_WITH_MEM_FUNCTIONS(blink::VideoTrackOrAudioTrackOrTextTrack);

#endif // UnionTypeCore_h
