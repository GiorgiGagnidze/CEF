// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mtp_storage_info.proto

#ifndef PROTOBUF_mtp_5fstorage_5finfo_2eproto__INCLUDED
#define PROTOBUF_mtp_5fstorage_5finfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mtp_5fstorage_5finfo_2eproto();
void protobuf_AssignDesc_mtp_5fstorage_5finfo_2eproto();
void protobuf_ShutdownFile_mtp_5fstorage_5finfo_2eproto();

class MtpStorageInfo;

// ===================================================================

class MtpStorageInfo : public ::google::protobuf::MessageLite {
 public:
  MtpStorageInfo();
  virtual ~MtpStorageInfo();

  MtpStorageInfo(const MtpStorageInfo& from);

  inline MtpStorageInfo& operator=(const MtpStorageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const MtpStorageInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MtpStorageInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MtpStorageInfo* other);

  // implements Message ----------------------------------------------

  MtpStorageInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MtpStorageInfo& from);
  void MergeFrom(const MtpStorageInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string storage_name = 1;
  inline bool has_storage_name() const;
  inline void clear_storage_name();
  static const int kStorageNameFieldNumber = 1;
  inline const ::std::string& storage_name() const;
  inline void set_storage_name(const ::std::string& value);
  inline void set_storage_name(const char* value);
  inline void set_storage_name(const char* value, size_t size);
  inline ::std::string* mutable_storage_name();
  inline ::std::string* release_storage_name();
  inline void set_allocated_storage_name(::std::string* storage_name);

  // optional string vendor = 2;
  inline bool has_vendor() const;
  inline void clear_vendor();
  static const int kVendorFieldNumber = 2;
  inline const ::std::string& vendor() const;
  inline void set_vendor(const ::std::string& value);
  inline void set_vendor(const char* value);
  inline void set_vendor(const char* value, size_t size);
  inline ::std::string* mutable_vendor();
  inline ::std::string* release_vendor();
  inline void set_allocated_vendor(::std::string* vendor);

  // optional uint32 vendor_id = 3;
  inline bool has_vendor_id() const;
  inline void clear_vendor_id();
  static const int kVendorIdFieldNumber = 3;
  inline ::google::protobuf::uint32 vendor_id() const;
  inline void set_vendor_id(::google::protobuf::uint32 value);

  // optional string product = 4;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 4;
  inline const ::std::string& product() const;
  inline void set_product(const ::std::string& value);
  inline void set_product(const char* value);
  inline void set_product(const char* value, size_t size);
  inline ::std::string* mutable_product();
  inline ::std::string* release_product();
  inline void set_allocated_product(::std::string* product);

  // optional uint32 product_id = 5;
  inline bool has_product_id() const;
  inline void clear_product_id();
  static const int kProductIdFieldNumber = 5;
  inline ::google::protobuf::uint32 product_id() const;
  inline void set_product_id(::google::protobuf::uint32 value);

  // optional uint32 device_flags = 6;
  inline bool has_device_flags() const;
  inline void clear_device_flags();
  static const int kDeviceFlagsFieldNumber = 6;
  inline ::google::protobuf::uint32 device_flags() const;
  inline void set_device_flags(::google::protobuf::uint32 value);

  // optional uint32 storage_type = 7;
  inline bool has_storage_type() const;
  inline void clear_storage_type();
  static const int kStorageTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 storage_type() const;
  inline void set_storage_type(::google::protobuf::uint32 value);

  // optional uint32 filesystem_type = 8;
  inline bool has_filesystem_type() const;
  inline void clear_filesystem_type();
  static const int kFilesystemTypeFieldNumber = 8;
  inline ::google::protobuf::uint32 filesystem_type() const;
  inline void set_filesystem_type(::google::protobuf::uint32 value);

  // optional uint32 access_capability = 9;
  inline bool has_access_capability() const;
  inline void clear_access_capability();
  static const int kAccessCapabilityFieldNumber = 9;
  inline ::google::protobuf::uint32 access_capability() const;
  inline void set_access_capability(::google::protobuf::uint32 value);

  // optional uint64 max_capacity = 10;
  inline bool has_max_capacity() const;
  inline void clear_max_capacity();
  static const int kMaxCapacityFieldNumber = 10;
  inline ::google::protobuf::uint64 max_capacity() const;
  inline void set_max_capacity(::google::protobuf::uint64 value);

  // optional uint64 free_space_in_bytes = 11;
  inline bool has_free_space_in_bytes() const;
  inline void clear_free_space_in_bytes();
  static const int kFreeSpaceInBytesFieldNumber = 11;
  inline ::google::protobuf::uint64 free_space_in_bytes() const;
  inline void set_free_space_in_bytes(::google::protobuf::uint64 value);

  // optional uint64 free_space_in_objects = 12;
  inline bool has_free_space_in_objects() const;
  inline void clear_free_space_in_objects();
  static const int kFreeSpaceInObjectsFieldNumber = 12;
  inline ::google::protobuf::uint64 free_space_in_objects() const;
  inline void set_free_space_in_objects(::google::protobuf::uint64 value);

  // optional string storage_description = 13;
  inline bool has_storage_description() const;
  inline void clear_storage_description();
  static const int kStorageDescriptionFieldNumber = 13;
  inline const ::std::string& storage_description() const;
  inline void set_storage_description(const ::std::string& value);
  inline void set_storage_description(const char* value);
  inline void set_storage_description(const char* value, size_t size);
  inline ::std::string* mutable_storage_description();
  inline ::std::string* release_storage_description();
  inline void set_allocated_storage_description(::std::string* storage_description);

  // optional string volume_identifier = 14;
  inline bool has_volume_identifier() const;
  inline void clear_volume_identifier();
  static const int kVolumeIdentifierFieldNumber = 14;
  inline const ::std::string& volume_identifier() const;
  inline void set_volume_identifier(const ::std::string& value);
  inline void set_volume_identifier(const char* value);
  inline void set_volume_identifier(const char* value, size_t size);
  inline ::std::string* mutable_volume_identifier();
  inline ::std::string* release_volume_identifier();
  inline void set_allocated_volume_identifier(::std::string* volume_identifier);

  // @@protoc_insertion_point(class_scope:MtpStorageInfo)
 private:
  inline void set_has_storage_name();
  inline void clear_has_storage_name();
  inline void set_has_vendor();
  inline void clear_has_vendor();
  inline void set_has_vendor_id();
  inline void clear_has_vendor_id();
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_product_id();
  inline void clear_has_product_id();
  inline void set_has_device_flags();
  inline void clear_has_device_flags();
  inline void set_has_storage_type();
  inline void clear_has_storage_type();
  inline void set_has_filesystem_type();
  inline void clear_has_filesystem_type();
  inline void set_has_access_capability();
  inline void clear_has_access_capability();
  inline void set_has_max_capacity();
  inline void clear_has_max_capacity();
  inline void set_has_free_space_in_bytes();
  inline void clear_has_free_space_in_bytes();
  inline void set_has_free_space_in_objects();
  inline void clear_has_free_space_in_objects();
  inline void set_has_storage_description();
  inline void clear_has_storage_description();
  inline void set_has_volume_identifier();
  inline void clear_has_volume_identifier();

  ::std::string* storage_name_;
  ::std::string* vendor_;
  ::std::string* product_;
  ::google::protobuf::uint32 vendor_id_;
  ::google::protobuf::uint32 product_id_;
  ::google::protobuf::uint32 device_flags_;
  ::google::protobuf::uint32 storage_type_;
  ::google::protobuf::uint32 filesystem_type_;
  ::google::protobuf::uint32 access_capability_;
  ::google::protobuf::uint64 max_capacity_;
  ::google::protobuf::uint64 free_space_in_bytes_;
  ::google::protobuf::uint64 free_space_in_objects_;
  ::std::string* storage_description_;
  ::std::string* volume_identifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mtp_5fstorage_5finfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mtp_5fstorage_5finfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_mtp_5fstorage_5finfo_2eproto();
  friend void protobuf_ShutdownFile_mtp_5fstorage_5finfo_2eproto();

  void InitAsDefaultInstance();
  static MtpStorageInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// MtpStorageInfo

// optional string storage_name = 1;
inline bool MtpStorageInfo::has_storage_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MtpStorageInfo::set_has_storage_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MtpStorageInfo::clear_has_storage_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MtpStorageInfo::clear_storage_name() {
  if (storage_name_ != &::google::protobuf::internal::GetEmptyString()) {
    storage_name_->clear();
  }
  clear_has_storage_name();
}
inline const ::std::string& MtpStorageInfo::storage_name() const {
  return *storage_name_;
}
inline void MtpStorageInfo::set_storage_name(const ::std::string& value) {
  set_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::GetEmptyString()) {
    storage_name_ = new ::std::string;
  }
  storage_name_->assign(value);
}
inline void MtpStorageInfo::set_storage_name(const char* value) {
  set_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::GetEmptyString()) {
    storage_name_ = new ::std::string;
  }
  storage_name_->assign(value);
}
inline void MtpStorageInfo::set_storage_name(const char* value, size_t size) {
  set_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::GetEmptyString()) {
    storage_name_ = new ::std::string;
  }
  storage_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MtpStorageInfo::mutable_storage_name() {
  set_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::GetEmptyString()) {
    storage_name_ = new ::std::string;
  }
  return storage_name_;
}
inline ::std::string* MtpStorageInfo::release_storage_name() {
  clear_has_storage_name();
  if (storage_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = storage_name_;
    storage_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void MtpStorageInfo::set_allocated_storage_name(::std::string* storage_name) {
  if (storage_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete storage_name_;
  }
  if (storage_name) {
    set_has_storage_name();
    storage_name_ = storage_name;
  } else {
    clear_has_storage_name();
    storage_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string vendor = 2;
inline bool MtpStorageInfo::has_vendor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MtpStorageInfo::set_has_vendor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MtpStorageInfo::clear_has_vendor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MtpStorageInfo::clear_vendor() {
  if (vendor_ != &::google::protobuf::internal::GetEmptyString()) {
    vendor_->clear();
  }
  clear_has_vendor();
}
inline const ::std::string& MtpStorageInfo::vendor() const {
  return *vendor_;
}
inline void MtpStorageInfo::set_vendor(const ::std::string& value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyString()) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
}
inline void MtpStorageInfo::set_vendor(const char* value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyString()) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
}
inline void MtpStorageInfo::set_vendor(const char* value, size_t size) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyString()) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MtpStorageInfo::mutable_vendor() {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyString()) {
    vendor_ = new ::std::string;
  }
  return vendor_;
}
inline ::std::string* MtpStorageInfo::release_vendor() {
  clear_has_vendor();
  if (vendor_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = vendor_;
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void MtpStorageInfo::set_allocated_vendor(::std::string* vendor) {
  if (vendor_ != &::google::protobuf::internal::GetEmptyString()) {
    delete vendor_;
  }
  if (vendor) {
    set_has_vendor();
    vendor_ = vendor;
  } else {
    clear_has_vendor();
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional uint32 vendor_id = 3;
inline bool MtpStorageInfo::has_vendor_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MtpStorageInfo::set_has_vendor_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MtpStorageInfo::clear_has_vendor_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MtpStorageInfo::clear_vendor_id() {
  vendor_id_ = 0u;
  clear_has_vendor_id();
}
inline ::google::protobuf::uint32 MtpStorageInfo::vendor_id() const {
  return vendor_id_;
}
inline void MtpStorageInfo::set_vendor_id(::google::protobuf::uint32 value) {
  set_has_vendor_id();
  vendor_id_ = value;
}

// optional string product = 4;
inline bool MtpStorageInfo::has_product() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MtpStorageInfo::set_has_product() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MtpStorageInfo::clear_has_product() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MtpStorageInfo::clear_product() {
  if (product_ != &::google::protobuf::internal::GetEmptyString()) {
    product_->clear();
  }
  clear_has_product();
}
inline const ::std::string& MtpStorageInfo::product() const {
  return *product_;
}
inline void MtpStorageInfo::set_product(const ::std::string& value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyString()) {
    product_ = new ::std::string;
  }
  product_->assign(value);
}
inline void MtpStorageInfo::set_product(const char* value) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyString()) {
    product_ = new ::std::string;
  }
  product_->assign(value);
}
inline void MtpStorageInfo::set_product(const char* value, size_t size) {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyString()) {
    product_ = new ::std::string;
  }
  product_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MtpStorageInfo::mutable_product() {
  set_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyString()) {
    product_ = new ::std::string;
  }
  return product_;
}
inline ::std::string* MtpStorageInfo::release_product() {
  clear_has_product();
  if (product_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = product_;
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void MtpStorageInfo::set_allocated_product(::std::string* product) {
  if (product_ != &::google::protobuf::internal::GetEmptyString()) {
    delete product_;
  }
  if (product) {
    set_has_product();
    product_ = product;
  } else {
    clear_has_product();
    product_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional uint32 product_id = 5;
inline bool MtpStorageInfo::has_product_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MtpStorageInfo::set_has_product_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MtpStorageInfo::clear_has_product_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MtpStorageInfo::clear_product_id() {
  product_id_ = 0u;
  clear_has_product_id();
}
inline ::google::protobuf::uint32 MtpStorageInfo::product_id() const {
  return product_id_;
}
inline void MtpStorageInfo::set_product_id(::google::protobuf::uint32 value) {
  set_has_product_id();
  product_id_ = value;
}

// optional uint32 device_flags = 6;
inline bool MtpStorageInfo::has_device_flags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MtpStorageInfo::set_has_device_flags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MtpStorageInfo::clear_has_device_flags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MtpStorageInfo::clear_device_flags() {
  device_flags_ = 0u;
  clear_has_device_flags();
}
inline ::google::protobuf::uint32 MtpStorageInfo::device_flags() const {
  return device_flags_;
}
inline void MtpStorageInfo::set_device_flags(::google::protobuf::uint32 value) {
  set_has_device_flags();
  device_flags_ = value;
}

// optional uint32 storage_type = 7;
inline bool MtpStorageInfo::has_storage_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MtpStorageInfo::set_has_storage_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MtpStorageInfo::clear_has_storage_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MtpStorageInfo::clear_storage_type() {
  storage_type_ = 0u;
  clear_has_storage_type();
}
inline ::google::protobuf::uint32 MtpStorageInfo::storage_type() const {
  return storage_type_;
}
inline void MtpStorageInfo::set_storage_type(::google::protobuf::uint32 value) {
  set_has_storage_type();
  storage_type_ = value;
}

// optional uint32 filesystem_type = 8;
inline bool MtpStorageInfo::has_filesystem_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MtpStorageInfo::set_has_filesystem_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MtpStorageInfo::clear_has_filesystem_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MtpStorageInfo::clear_filesystem_type() {
  filesystem_type_ = 0u;
  clear_has_filesystem_type();
}
inline ::google::protobuf::uint32 MtpStorageInfo::filesystem_type() const {
  return filesystem_type_;
}
inline void MtpStorageInfo::set_filesystem_type(::google::protobuf::uint32 value) {
  set_has_filesystem_type();
  filesystem_type_ = value;
}

// optional uint32 access_capability = 9;
inline bool MtpStorageInfo::has_access_capability() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MtpStorageInfo::set_has_access_capability() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MtpStorageInfo::clear_has_access_capability() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MtpStorageInfo::clear_access_capability() {
  access_capability_ = 0u;
  clear_has_access_capability();
}
inline ::google::protobuf::uint32 MtpStorageInfo::access_capability() const {
  return access_capability_;
}
inline void MtpStorageInfo::set_access_capability(::google::protobuf::uint32 value) {
  set_has_access_capability();
  access_capability_ = value;
}

// optional uint64 max_capacity = 10;
inline bool MtpStorageInfo::has_max_capacity() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MtpStorageInfo::set_has_max_capacity() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MtpStorageInfo::clear_has_max_capacity() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MtpStorageInfo::clear_max_capacity() {
  max_capacity_ = GOOGLE_ULONGLONG(0);
  clear_has_max_capacity();
}
inline ::google::protobuf::uint64 MtpStorageInfo::max_capacity() const {
  return max_capacity_;
}
inline void MtpStorageInfo::set_max_capacity(::google::protobuf::uint64 value) {
  set_has_max_capacity();
  max_capacity_ = value;
}

// optional uint64 free_space_in_bytes = 11;
inline bool MtpStorageInfo::has_free_space_in_bytes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MtpStorageInfo::set_has_free_space_in_bytes() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MtpStorageInfo::clear_has_free_space_in_bytes() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MtpStorageInfo::clear_free_space_in_bytes() {
  free_space_in_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_free_space_in_bytes();
}
inline ::google::protobuf::uint64 MtpStorageInfo::free_space_in_bytes() const {
  return free_space_in_bytes_;
}
inline void MtpStorageInfo::set_free_space_in_bytes(::google::protobuf::uint64 value) {
  set_has_free_space_in_bytes();
  free_space_in_bytes_ = value;
}

// optional uint64 free_space_in_objects = 12;
inline bool MtpStorageInfo::has_free_space_in_objects() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MtpStorageInfo::set_has_free_space_in_objects() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MtpStorageInfo::clear_has_free_space_in_objects() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MtpStorageInfo::clear_free_space_in_objects() {
  free_space_in_objects_ = GOOGLE_ULONGLONG(0);
  clear_has_free_space_in_objects();
}
inline ::google::protobuf::uint64 MtpStorageInfo::free_space_in_objects() const {
  return free_space_in_objects_;
}
inline void MtpStorageInfo::set_free_space_in_objects(::google::protobuf::uint64 value) {
  set_has_free_space_in_objects();
  free_space_in_objects_ = value;
}

// optional string storage_description = 13;
inline bool MtpStorageInfo::has_storage_description() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MtpStorageInfo::set_has_storage_description() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MtpStorageInfo::clear_has_storage_description() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MtpStorageInfo::clear_storage_description() {
  if (storage_description_ != &::google::protobuf::internal::GetEmptyString()) {
    storage_description_->clear();
  }
  clear_has_storage_description();
}
inline const ::std::string& MtpStorageInfo::storage_description() const {
  return *storage_description_;
}
inline void MtpStorageInfo::set_storage_description(const ::std::string& value) {
  set_has_storage_description();
  if (storage_description_ == &::google::protobuf::internal::GetEmptyString()) {
    storage_description_ = new ::std::string;
  }
  storage_description_->assign(value);
}
inline void MtpStorageInfo::set_storage_description(const char* value) {
  set_has_storage_description();
  if (storage_description_ == &::google::protobuf::internal::GetEmptyString()) {
    storage_description_ = new ::std::string;
  }
  storage_description_->assign(value);
}
inline void MtpStorageInfo::set_storage_description(const char* value, size_t size) {
  set_has_storage_description();
  if (storage_description_ == &::google::protobuf::internal::GetEmptyString()) {
    storage_description_ = new ::std::string;
  }
  storage_description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MtpStorageInfo::mutable_storage_description() {
  set_has_storage_description();
  if (storage_description_ == &::google::protobuf::internal::GetEmptyString()) {
    storage_description_ = new ::std::string;
  }
  return storage_description_;
}
inline ::std::string* MtpStorageInfo::release_storage_description() {
  clear_has_storage_description();
  if (storage_description_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = storage_description_;
    storage_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void MtpStorageInfo::set_allocated_storage_description(::std::string* storage_description) {
  if (storage_description_ != &::google::protobuf::internal::GetEmptyString()) {
    delete storage_description_;
  }
  if (storage_description) {
    set_has_storage_description();
    storage_description_ = storage_description;
  } else {
    clear_has_storage_description();
    storage_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string volume_identifier = 14;
inline bool MtpStorageInfo::has_volume_identifier() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MtpStorageInfo::set_has_volume_identifier() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MtpStorageInfo::clear_has_volume_identifier() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MtpStorageInfo::clear_volume_identifier() {
  if (volume_identifier_ != &::google::protobuf::internal::GetEmptyString()) {
    volume_identifier_->clear();
  }
  clear_has_volume_identifier();
}
inline const ::std::string& MtpStorageInfo::volume_identifier() const {
  return *volume_identifier_;
}
inline void MtpStorageInfo::set_volume_identifier(const ::std::string& value) {
  set_has_volume_identifier();
  if (volume_identifier_ == &::google::protobuf::internal::GetEmptyString()) {
    volume_identifier_ = new ::std::string;
  }
  volume_identifier_->assign(value);
}
inline void MtpStorageInfo::set_volume_identifier(const char* value) {
  set_has_volume_identifier();
  if (volume_identifier_ == &::google::protobuf::internal::GetEmptyString()) {
    volume_identifier_ = new ::std::string;
  }
  volume_identifier_->assign(value);
}
inline void MtpStorageInfo::set_volume_identifier(const char* value, size_t size) {
  set_has_volume_identifier();
  if (volume_identifier_ == &::google::protobuf::internal::GetEmptyString()) {
    volume_identifier_ = new ::std::string;
  }
  volume_identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MtpStorageInfo::mutable_volume_identifier() {
  set_has_volume_identifier();
  if (volume_identifier_ == &::google::protobuf::internal::GetEmptyString()) {
    volume_identifier_ = new ::std::string;
  }
  return volume_identifier_;
}
inline ::std::string* MtpStorageInfo::release_volume_identifier() {
  clear_has_volume_identifier();
  if (volume_identifier_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = volume_identifier_;
    volume_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void MtpStorageInfo::set_allocated_volume_identifier(::std::string* volume_identifier) {
  if (volume_identifier_ != &::google::protobuf::internal::GetEmptyString()) {
    delete volume_identifier_;
  }
  if (volume_identifier) {
    set_has_volume_identifier();
    volume_identifier_ = volume_identifier;
  } else {
    clear_has_volume_identifier();
    volume_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mtp_5fstorage_5finfo_2eproto__INCLUDED
