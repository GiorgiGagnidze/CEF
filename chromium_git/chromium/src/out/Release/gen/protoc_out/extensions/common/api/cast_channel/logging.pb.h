// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: logging.proto

#ifndef PROTOBUF_logging_2eproto__INCLUDED
#define PROTOBUF_logging_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace extensions {
namespace api {
namespace cast_channel {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_logging_2eproto();
void protobuf_AssignDesc_logging_2eproto();
void protobuf_ShutdownFile_logging_2eproto();

class SocketEvent;
class AggregatedSocketEvent;
class Log;

enum EventType {
  EVENT_TYPE_UNKNOWN = 0,
  CAST_SOCKET_CREATED = 1,
  READY_STATE_CHANGED = 2,
  CONNECTION_STATE_CHANGED = 3,
  READ_STATE_CHANGED = 4,
  WRITE_STATE_CHANGED = 5,
  ERROR_STATE_CHANGED = 6,
  CONNECT_FAILED = 7,
  TCP_SOCKET_CONNECT = 8,
  TCP_SOCKET_SET_KEEP_ALIVE = 9,
  SSL_CERT_WHITELISTED = 10,
  SSL_SOCKET_CONNECT = 11,
  SSL_INFO_OBTAINED = 12,
  DER_ENCODED_CERT_OBTAIN = 13,
  RECEIVED_CHALLENGE_REPLY = 14,
  AUTH_CHALLENGE_REPLY = 15,
  CONNECT_TIMED_OUT = 16,
  SEND_MESSAGE_FAILED = 17,
  MESSAGE_ENQUEUED = 18,
  SOCKET_WRITE = 19,
  MESSAGE_WRITTEN = 20,
  SOCKET_READ = 21,
  MESSAGE_READ = 22,
  SOCKET_CLOSED = 25,
  SSL_CERT_EXCESSIVE_LIFETIME = 26,
  CHANNEL_POLICY_ENFORCED = 27,
  TCP_SOCKET_CONNECT_COMPLETE = 28,
  SSL_SOCKET_CONNECT_COMPLETE = 29,
  SSL_SOCKET_CONNECT_FAILED = 30,
  SEND_AUTH_CHALLENGE_FAILED = 31,
  AUTH_CHALLENGE_REPLY_INVALID = 32,
  PING_WRITE_ERROR = 33
};
bool EventType_IsValid(int value);
const EventType EventType_MIN = EVENT_TYPE_UNKNOWN;
const EventType EventType_MAX = PING_WRITE_ERROR;
const int EventType_ARRAYSIZE = EventType_MAX + 1;

enum ChannelAuth {
  SSL = 1,
  SSL_VERIFIED = 2
};
bool ChannelAuth_IsValid(int value);
const ChannelAuth ChannelAuth_MIN = SSL;
const ChannelAuth ChannelAuth_MAX = SSL_VERIFIED;
const int ChannelAuth_ARRAYSIZE = ChannelAuth_MAX + 1;

enum ReadyState {
  READY_STATE_NONE = 1,
  READY_STATE_CONNECTING = 2,
  READY_STATE_OPEN = 3,
  READY_STATE_CLOSING = 4,
  READY_STATE_CLOSED = 5
};
bool ReadyState_IsValid(int value);
const ReadyState ReadyState_MIN = READY_STATE_NONE;
const ReadyState ReadyState_MAX = READY_STATE_CLOSED;
const int ReadyState_ARRAYSIZE = ReadyState_MAX + 1;

enum ConnectionState {
  CONN_STATE_UNKNOWN = 1,
  CONN_STATE_TCP_CONNECT = 2,
  CONN_STATE_TCP_CONNECT_COMPLETE = 3,
  CONN_STATE_SSL_CONNECT = 4,
  CONN_STATE_SSL_CONNECT_COMPLETE = 5,
  CONN_STATE_AUTH_CHALLENGE_SEND = 6,
  CONN_STATE_AUTH_CHALLENGE_SEND_COMPLETE = 7,
  CONN_STATE_AUTH_CHALLENGE_REPLY_COMPLETE = 8,
  CONN_STATE_START_CONNECT = 9,
  CONN_STATE_FINISHED = 100,
  CONN_STATE_ERROR = 101,
  CONN_STATE_TIMEOUT = 102
};
bool ConnectionState_IsValid(int value);
const ConnectionState ConnectionState_MIN = CONN_STATE_UNKNOWN;
const ConnectionState ConnectionState_MAX = CONN_STATE_TIMEOUT;
const int ConnectionState_ARRAYSIZE = ConnectionState_MAX + 1;

enum ReadState {
  READ_STATE_UNKNOWN = 1,
  READ_STATE_READ = 2,
  READ_STATE_READ_COMPLETE = 3,
  READ_STATE_DO_CALLBACK = 4,
  READ_STATE_HANDLE_ERROR = 5,
  READ_STATE_ERROR = 100
};
bool ReadState_IsValid(int value);
const ReadState ReadState_MIN = READ_STATE_UNKNOWN;
const ReadState ReadState_MAX = READ_STATE_ERROR;
const int ReadState_ARRAYSIZE = ReadState_MAX + 1;

enum WriteState {
  WRITE_STATE_UNKNOWN = 1,
  WRITE_STATE_WRITE = 2,
  WRITE_STATE_WRITE_COMPLETE = 3,
  WRITE_STATE_DO_CALLBACK = 4,
  WRITE_STATE_HANDLE_ERROR = 5,
  WRITE_STATE_ERROR = 100,
  WRITE_STATE_IDLE = 101
};
bool WriteState_IsValid(int value);
const WriteState WriteState_MIN = WRITE_STATE_UNKNOWN;
const WriteState WriteState_MAX = WRITE_STATE_IDLE;
const int WriteState_ARRAYSIZE = WriteState_MAX + 1;

enum ErrorState {
  CHANNEL_ERROR_NONE = 1,
  CHANNEL_ERROR_CHANNEL_NOT_OPEN = 2,
  CHANNEL_ERROR_AUTHENTICATION_ERROR = 3,
  CHANNEL_ERROR_CONNECT_ERROR = 4,
  CHANNEL_ERROR_SOCKET_ERROR = 5,
  CHANNEL_ERROR_TRANSPORT_ERROR = 6,
  CHANNEL_ERROR_INVALID_MESSAGE = 7,
  CHANNEL_ERROR_INVALID_CHANNEL_ID = 8,
  CHANNEL_ERROR_CONNECT_TIMEOUT = 9,
  CHANNEL_ERROR_UNKNOWN = 10
};
bool ErrorState_IsValid(int value);
const ErrorState ErrorState_MIN = CHANNEL_ERROR_NONE;
const ErrorState ErrorState_MAX = CHANNEL_ERROR_UNKNOWN;
const int ErrorState_ARRAYSIZE = ErrorState_MAX + 1;

enum ChallengeReplyErrorType {
  CHALLENGE_REPLY_ERROR_NONE = 1,
  CHALLENGE_REPLY_ERROR_PEER_CERT_EMPTY = 2,
  CHALLENGE_REPLY_ERROR_WRONG_PAYLOAD_TYPE = 3,
  CHALLENGE_REPLY_ERROR_NO_PAYLOAD = 4,
  CHALLENGE_REPLY_ERROR_PAYLOAD_PARSING_FAILED = 5,
  CHALLENGE_REPLY_ERROR_MESSAGE_ERROR = 6,
  CHALLENGE_REPLY_ERROR_NO_RESPONSE = 7,
  CHALLENGE_REPLY_ERROR_FINGERPRINT_NOT_FOUND = 8,
  CHALLENGE_REPLY_ERROR_CERT_PARSING_FAILED = 9,
  CHALLENGE_REPLY_ERROR_CERT_NOT_SIGNED_BY_TRUSTED_CA = 10,
  CHALLENGE_REPLY_ERROR_CANNOT_EXTRACT_PUBLIC_KEY = 11,
  CHALLENGE_REPLY_ERROR_SIGNED_BLOBS_MISMATCH = 12
};
bool ChallengeReplyErrorType_IsValid(int value);
const ChallengeReplyErrorType ChallengeReplyErrorType_MIN = CHALLENGE_REPLY_ERROR_NONE;
const ChallengeReplyErrorType ChallengeReplyErrorType_MAX = CHALLENGE_REPLY_ERROR_SIGNED_BLOBS_MISMATCH;
const int ChallengeReplyErrorType_ARRAYSIZE = ChallengeReplyErrorType_MAX + 1;

// ===================================================================

class SocketEvent : public ::google::protobuf::MessageLite {
 public:
  SocketEvent();
  virtual ~SocketEvent();

  SocketEvent(const SocketEvent& from);

  inline SocketEvent& operator=(const SocketEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const SocketEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SocketEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SocketEvent* other);

  // implements Message ----------------------------------------------

  SocketEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SocketEvent& from);
  void MergeFrom(const SocketEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .extensions.api.cast_channel.proto.EventType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::extensions::api::cast_channel::proto::EventType type() const;
  inline void set_type(::extensions::api::cast_channel::proto::EventType value);

  // optional int64 timestamp_micros = 2;
  inline bool has_timestamp_micros() const;
  inline void clear_timestamp_micros();
  static const int kTimestampMicrosFieldNumber = 2;
  inline ::google::protobuf::int64 timestamp_micros() const;
  inline void set_timestamp_micros(::google::protobuf::int64 value);

  // optional string details = 3;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 3;
  inline const ::std::string& details() const;
  inline void set_details(const ::std::string& value);
  inline void set_details(const char* value);
  inline void set_details(const char* value, size_t size);
  inline ::std::string* mutable_details();
  inline ::std::string* release_details();
  inline void set_allocated_details(::std::string* details);

  // optional int32 net_return_value = 4;
  inline bool has_net_return_value() const;
  inline void clear_net_return_value();
  static const int kNetReturnValueFieldNumber = 4;
  inline ::google::protobuf::int32 net_return_value() const;
  inline void set_net_return_value(::google::protobuf::int32 value);

  // optional string message_namespace = 5;
  inline bool has_message_namespace() const;
  inline void clear_message_namespace();
  static const int kMessageNamespaceFieldNumber = 5;
  inline const ::std::string& message_namespace() const;
  inline void set_message_namespace(const ::std::string& value);
  inline void set_message_namespace(const char* value);
  inline void set_message_namespace(const char* value, size_t size);
  inline ::std::string* mutable_message_namespace();
  inline ::std::string* release_message_namespace();
  inline void set_allocated_message_namespace(::std::string* message_namespace);

  // optional .extensions.api.cast_channel.proto.ReadyState ready_state = 6;
  inline bool has_ready_state() const;
  inline void clear_ready_state();
  static const int kReadyStateFieldNumber = 6;
  inline ::extensions::api::cast_channel::proto::ReadyState ready_state() const;
  inline void set_ready_state(::extensions::api::cast_channel::proto::ReadyState value);

  // optional .extensions.api.cast_channel.proto.ConnectionState connection_state = 7;
  inline bool has_connection_state() const;
  inline void clear_connection_state();
  static const int kConnectionStateFieldNumber = 7;
  inline ::extensions::api::cast_channel::proto::ConnectionState connection_state() const;
  inline void set_connection_state(::extensions::api::cast_channel::proto::ConnectionState value);

  // optional .extensions.api.cast_channel.proto.ReadState read_state = 8;
  inline bool has_read_state() const;
  inline void clear_read_state();
  static const int kReadStateFieldNumber = 8;
  inline ::extensions::api::cast_channel::proto::ReadState read_state() const;
  inline void set_read_state(::extensions::api::cast_channel::proto::ReadState value);

  // optional .extensions.api.cast_channel.proto.WriteState write_state = 9;
  inline bool has_write_state() const;
  inline void clear_write_state();
  static const int kWriteStateFieldNumber = 9;
  inline ::extensions::api::cast_channel::proto::WriteState write_state() const;
  inline void set_write_state(::extensions::api::cast_channel::proto::WriteState value);

  // optional .extensions.api.cast_channel.proto.ErrorState error_state = 10;
  inline bool has_error_state() const;
  inline void clear_error_state();
  static const int kErrorStateFieldNumber = 10;
  inline ::extensions::api::cast_channel::proto::ErrorState error_state() const;
  inline void set_error_state(::extensions::api::cast_channel::proto::ErrorState value);

  // optional .extensions.api.cast_channel.proto.ChallengeReplyErrorType challenge_reply_error_type = 11;
  inline bool has_challenge_reply_error_type() const;
  inline void clear_challenge_reply_error_type();
  static const int kChallengeReplyErrorTypeFieldNumber = 11;
  inline ::extensions::api::cast_channel::proto::ChallengeReplyErrorType challenge_reply_error_type() const;
  inline void set_challenge_reply_error_type(::extensions::api::cast_channel::proto::ChallengeReplyErrorType value);

  // optional int32 nss_error_code = 12;
  inline bool has_nss_error_code() const;
  inline void clear_nss_error_code();
  static const int kNssErrorCodeFieldNumber = 12;
  inline ::google::protobuf::int32 nss_error_code() const;
  inline void set_nss_error_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:extensions.api.cast_channel.proto.SocketEvent)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_timestamp_micros();
  inline void clear_has_timestamp_micros();
  inline void set_has_details();
  inline void clear_has_details();
  inline void set_has_net_return_value();
  inline void clear_has_net_return_value();
  inline void set_has_message_namespace();
  inline void clear_has_message_namespace();
  inline void set_has_ready_state();
  inline void clear_has_ready_state();
  inline void set_has_connection_state();
  inline void clear_has_connection_state();
  inline void set_has_read_state();
  inline void clear_has_read_state();
  inline void set_has_write_state();
  inline void clear_has_write_state();
  inline void set_has_error_state();
  inline void clear_has_error_state();
  inline void set_has_challenge_reply_error_type();
  inline void clear_has_challenge_reply_error_type();
  inline void set_has_nss_error_code();
  inline void clear_has_nss_error_code();

  ::google::protobuf::int64 timestamp_micros_;
  int type_;
  ::google::protobuf::int32 net_return_value_;
  ::std::string* details_;
  ::std::string* message_namespace_;
  int ready_state_;
  int connection_state_;
  int read_state_;
  int write_state_;
  int error_state_;
  int challenge_reply_error_type_;
  ::google::protobuf::int32 nss_error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_logging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_logging_2eproto();
  #endif
  friend void protobuf_AssignDesc_logging_2eproto();
  friend void protobuf_ShutdownFile_logging_2eproto();

  void InitAsDefaultInstance();
  static SocketEvent* default_instance_;
};
// -------------------------------------------------------------------

class AggregatedSocketEvent : public ::google::protobuf::MessageLite {
 public:
  AggregatedSocketEvent();
  virtual ~AggregatedSocketEvent();

  AggregatedSocketEvent(const AggregatedSocketEvent& from);

  inline AggregatedSocketEvent& operator=(const AggregatedSocketEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const AggregatedSocketEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AggregatedSocketEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AggregatedSocketEvent* other);

  // implements Message ----------------------------------------------

  AggregatedSocketEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AggregatedSocketEvent& from);
  void MergeFrom(const AggregatedSocketEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 endpoint_id = 2;
  inline bool has_endpoint_id() const;
  inline void clear_endpoint_id();
  static const int kEndpointIdFieldNumber = 2;
  inline ::google::protobuf::int32 endpoint_id() const;
  inline void set_endpoint_id(::google::protobuf::int32 value);

  // optional .extensions.api.cast_channel.proto.ChannelAuth channel_auth_type = 3;
  inline bool has_channel_auth_type() const;
  inline void clear_channel_auth_type();
  static const int kChannelAuthTypeFieldNumber = 3;
  inline ::extensions::api::cast_channel::proto::ChannelAuth channel_auth_type() const;
  inline void set_channel_auth_type(::extensions::api::cast_channel::proto::ChannelAuth value);

  // repeated .extensions.api.cast_channel.proto.SocketEvent socket_event = 4;
  inline int socket_event_size() const;
  inline void clear_socket_event();
  static const int kSocketEventFieldNumber = 4;
  inline const ::extensions::api::cast_channel::proto::SocketEvent& socket_event(int index) const;
  inline ::extensions::api::cast_channel::proto::SocketEvent* mutable_socket_event(int index);
  inline ::extensions::api::cast_channel::proto::SocketEvent* add_socket_event();
  inline const ::google::protobuf::RepeatedPtrField< ::extensions::api::cast_channel::proto::SocketEvent >&
      socket_event() const;
  inline ::google::protobuf::RepeatedPtrField< ::extensions::api::cast_channel::proto::SocketEvent >*
      mutable_socket_event();

  // optional int64 bytes_read = 5;
  inline bool has_bytes_read() const;
  inline void clear_bytes_read();
  static const int kBytesReadFieldNumber = 5;
  inline ::google::protobuf::int64 bytes_read() const;
  inline void set_bytes_read(::google::protobuf::int64 value);

  // optional int64 bytes_written = 6;
  inline bool has_bytes_written() const;
  inline void clear_bytes_written();
  static const int kBytesWrittenFieldNumber = 6;
  inline ::google::protobuf::int64 bytes_written() const;
  inline void set_bytes_written(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:extensions.api.cast_channel.proto.AggregatedSocketEvent)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_endpoint_id();
  inline void clear_has_endpoint_id();
  inline void set_has_channel_auth_type();
  inline void clear_has_channel_auth_type();
  inline void set_has_bytes_read();
  inline void clear_has_bytes_read();
  inline void set_has_bytes_written();
  inline void clear_has_bytes_written();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 endpoint_id_;
  ::google::protobuf::RepeatedPtrField< ::extensions::api::cast_channel::proto::SocketEvent > socket_event_;
  ::google::protobuf::int64 bytes_read_;
  ::google::protobuf::int64 bytes_written_;
  int channel_auth_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_logging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_logging_2eproto();
  #endif
  friend void protobuf_AssignDesc_logging_2eproto();
  friend void protobuf_ShutdownFile_logging_2eproto();

  void InitAsDefaultInstance();
  static AggregatedSocketEvent* default_instance_;
};
// -------------------------------------------------------------------

class Log : public ::google::protobuf::MessageLite {
 public:
  Log();
  virtual ~Log();

  Log(const Log& from);

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }

  static const Log& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Log* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Log* other);

  // implements Message ----------------------------------------------

  Log* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Log& from);
  void MergeFrom(const Log& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .extensions.api.cast_channel.proto.AggregatedSocketEvent aggregated_socket_event = 1;
  inline int aggregated_socket_event_size() const;
  inline void clear_aggregated_socket_event();
  static const int kAggregatedSocketEventFieldNumber = 1;
  inline const ::extensions::api::cast_channel::proto::AggregatedSocketEvent& aggregated_socket_event(int index) const;
  inline ::extensions::api::cast_channel::proto::AggregatedSocketEvent* mutable_aggregated_socket_event(int index);
  inline ::extensions::api::cast_channel::proto::AggregatedSocketEvent* add_aggregated_socket_event();
  inline const ::google::protobuf::RepeatedPtrField< ::extensions::api::cast_channel::proto::AggregatedSocketEvent >&
      aggregated_socket_event() const;
  inline ::google::protobuf::RepeatedPtrField< ::extensions::api::cast_channel::proto::AggregatedSocketEvent >*
      mutable_aggregated_socket_event();

  // optional int32 num_evicted_aggregated_socket_events = 2;
  inline bool has_num_evicted_aggregated_socket_events() const;
  inline void clear_num_evicted_aggregated_socket_events();
  static const int kNumEvictedAggregatedSocketEventsFieldNumber = 2;
  inline ::google::protobuf::int32 num_evicted_aggregated_socket_events() const;
  inline void set_num_evicted_aggregated_socket_events(::google::protobuf::int32 value);

  // optional int32 num_evicted_socket_events = 3;
  inline bool has_num_evicted_socket_events() const;
  inline void clear_num_evicted_socket_events();
  static const int kNumEvictedSocketEventsFieldNumber = 3;
  inline ::google::protobuf::int32 num_evicted_socket_events() const;
  inline void set_num_evicted_socket_events(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:extensions.api.cast_channel.proto.Log)
 private:
  inline void set_has_num_evicted_aggregated_socket_events();
  inline void clear_has_num_evicted_aggregated_socket_events();
  inline void set_has_num_evicted_socket_events();
  inline void clear_has_num_evicted_socket_events();

  ::google::protobuf::RepeatedPtrField< ::extensions::api::cast_channel::proto::AggregatedSocketEvent > aggregated_socket_event_;
  ::google::protobuf::int32 num_evicted_aggregated_socket_events_;
  ::google::protobuf::int32 num_evicted_socket_events_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_logging_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_logging_2eproto();
  #endif
  friend void protobuf_AssignDesc_logging_2eproto();
  friend void protobuf_ShutdownFile_logging_2eproto();

  void InitAsDefaultInstance();
  static Log* default_instance_;
};
// ===================================================================


// ===================================================================

// SocketEvent

// optional .extensions.api.cast_channel.proto.EventType type = 1;
inline bool SocketEvent::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SocketEvent::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SocketEvent::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SocketEvent::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::extensions::api::cast_channel::proto::EventType SocketEvent::type() const {
  return static_cast< ::extensions::api::cast_channel::proto::EventType >(type_);
}
inline void SocketEvent::set_type(::extensions::api::cast_channel::proto::EventType value) {
  assert(::extensions::api::cast_channel::proto::EventType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int64 timestamp_micros = 2;
inline bool SocketEvent::has_timestamp_micros() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SocketEvent::set_has_timestamp_micros() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SocketEvent::clear_has_timestamp_micros() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SocketEvent::clear_timestamp_micros() {
  timestamp_micros_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp_micros();
}
inline ::google::protobuf::int64 SocketEvent::timestamp_micros() const {
  return timestamp_micros_;
}
inline void SocketEvent::set_timestamp_micros(::google::protobuf::int64 value) {
  set_has_timestamp_micros();
  timestamp_micros_ = value;
}

// optional string details = 3;
inline bool SocketEvent::has_details() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SocketEvent::set_has_details() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SocketEvent::clear_has_details() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SocketEvent::clear_details() {
  if (details_ != &::google::protobuf::internal::GetEmptyString()) {
    details_->clear();
  }
  clear_has_details();
}
inline const ::std::string& SocketEvent::details() const {
  return *details_;
}
inline void SocketEvent::set_details(const ::std::string& value) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::GetEmptyString()) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void SocketEvent::set_details(const char* value) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::GetEmptyString()) {
    details_ = new ::std::string;
  }
  details_->assign(value);
}
inline void SocketEvent::set_details(const char* value, size_t size) {
  set_has_details();
  if (details_ == &::google::protobuf::internal::GetEmptyString()) {
    details_ = new ::std::string;
  }
  details_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SocketEvent::mutable_details() {
  set_has_details();
  if (details_ == &::google::protobuf::internal::GetEmptyString()) {
    details_ = new ::std::string;
  }
  return details_;
}
inline ::std::string* SocketEvent::release_details() {
  clear_has_details();
  if (details_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = details_;
    details_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SocketEvent::set_allocated_details(::std::string* details) {
  if (details_ != &::google::protobuf::internal::GetEmptyString()) {
    delete details_;
  }
  if (details) {
    set_has_details();
    details_ = details;
  } else {
    clear_has_details();
    details_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int32 net_return_value = 4;
inline bool SocketEvent::has_net_return_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SocketEvent::set_has_net_return_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SocketEvent::clear_has_net_return_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SocketEvent::clear_net_return_value() {
  net_return_value_ = 0;
  clear_has_net_return_value();
}
inline ::google::protobuf::int32 SocketEvent::net_return_value() const {
  return net_return_value_;
}
inline void SocketEvent::set_net_return_value(::google::protobuf::int32 value) {
  set_has_net_return_value();
  net_return_value_ = value;
}

// optional string message_namespace = 5;
inline bool SocketEvent::has_message_namespace() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SocketEvent::set_has_message_namespace() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SocketEvent::clear_has_message_namespace() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SocketEvent::clear_message_namespace() {
  if (message_namespace_ != &::google::protobuf::internal::GetEmptyString()) {
    message_namespace_->clear();
  }
  clear_has_message_namespace();
}
inline const ::std::string& SocketEvent::message_namespace() const {
  return *message_namespace_;
}
inline void SocketEvent::set_message_namespace(const ::std::string& value) {
  set_has_message_namespace();
  if (message_namespace_ == &::google::protobuf::internal::GetEmptyString()) {
    message_namespace_ = new ::std::string;
  }
  message_namespace_->assign(value);
}
inline void SocketEvent::set_message_namespace(const char* value) {
  set_has_message_namespace();
  if (message_namespace_ == &::google::protobuf::internal::GetEmptyString()) {
    message_namespace_ = new ::std::string;
  }
  message_namespace_->assign(value);
}
inline void SocketEvent::set_message_namespace(const char* value, size_t size) {
  set_has_message_namespace();
  if (message_namespace_ == &::google::protobuf::internal::GetEmptyString()) {
    message_namespace_ = new ::std::string;
  }
  message_namespace_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SocketEvent::mutable_message_namespace() {
  set_has_message_namespace();
  if (message_namespace_ == &::google::protobuf::internal::GetEmptyString()) {
    message_namespace_ = new ::std::string;
  }
  return message_namespace_;
}
inline ::std::string* SocketEvent::release_message_namespace() {
  clear_has_message_namespace();
  if (message_namespace_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = message_namespace_;
    message_namespace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SocketEvent::set_allocated_message_namespace(::std::string* message_namespace) {
  if (message_namespace_ != &::google::protobuf::internal::GetEmptyString()) {
    delete message_namespace_;
  }
  if (message_namespace) {
    set_has_message_namespace();
    message_namespace_ = message_namespace;
  } else {
    clear_has_message_namespace();
    message_namespace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .extensions.api.cast_channel.proto.ReadyState ready_state = 6;
inline bool SocketEvent::has_ready_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SocketEvent::set_has_ready_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SocketEvent::clear_has_ready_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SocketEvent::clear_ready_state() {
  ready_state_ = 1;
  clear_has_ready_state();
}
inline ::extensions::api::cast_channel::proto::ReadyState SocketEvent::ready_state() const {
  return static_cast< ::extensions::api::cast_channel::proto::ReadyState >(ready_state_);
}
inline void SocketEvent::set_ready_state(::extensions::api::cast_channel::proto::ReadyState value) {
  assert(::extensions::api::cast_channel::proto::ReadyState_IsValid(value));
  set_has_ready_state();
  ready_state_ = value;
}

// optional .extensions.api.cast_channel.proto.ConnectionState connection_state = 7;
inline bool SocketEvent::has_connection_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SocketEvent::set_has_connection_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SocketEvent::clear_has_connection_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SocketEvent::clear_connection_state() {
  connection_state_ = 1;
  clear_has_connection_state();
}
inline ::extensions::api::cast_channel::proto::ConnectionState SocketEvent::connection_state() const {
  return static_cast< ::extensions::api::cast_channel::proto::ConnectionState >(connection_state_);
}
inline void SocketEvent::set_connection_state(::extensions::api::cast_channel::proto::ConnectionState value) {
  assert(::extensions::api::cast_channel::proto::ConnectionState_IsValid(value));
  set_has_connection_state();
  connection_state_ = value;
}

// optional .extensions.api.cast_channel.proto.ReadState read_state = 8;
inline bool SocketEvent::has_read_state() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SocketEvent::set_has_read_state() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SocketEvent::clear_has_read_state() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SocketEvent::clear_read_state() {
  read_state_ = 1;
  clear_has_read_state();
}
inline ::extensions::api::cast_channel::proto::ReadState SocketEvent::read_state() const {
  return static_cast< ::extensions::api::cast_channel::proto::ReadState >(read_state_);
}
inline void SocketEvent::set_read_state(::extensions::api::cast_channel::proto::ReadState value) {
  assert(::extensions::api::cast_channel::proto::ReadState_IsValid(value));
  set_has_read_state();
  read_state_ = value;
}

// optional .extensions.api.cast_channel.proto.WriteState write_state = 9;
inline bool SocketEvent::has_write_state() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SocketEvent::set_has_write_state() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SocketEvent::clear_has_write_state() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SocketEvent::clear_write_state() {
  write_state_ = 1;
  clear_has_write_state();
}
inline ::extensions::api::cast_channel::proto::WriteState SocketEvent::write_state() const {
  return static_cast< ::extensions::api::cast_channel::proto::WriteState >(write_state_);
}
inline void SocketEvent::set_write_state(::extensions::api::cast_channel::proto::WriteState value) {
  assert(::extensions::api::cast_channel::proto::WriteState_IsValid(value));
  set_has_write_state();
  write_state_ = value;
}

// optional .extensions.api.cast_channel.proto.ErrorState error_state = 10;
inline bool SocketEvent::has_error_state() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SocketEvent::set_has_error_state() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SocketEvent::clear_has_error_state() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SocketEvent::clear_error_state() {
  error_state_ = 1;
  clear_has_error_state();
}
inline ::extensions::api::cast_channel::proto::ErrorState SocketEvent::error_state() const {
  return static_cast< ::extensions::api::cast_channel::proto::ErrorState >(error_state_);
}
inline void SocketEvent::set_error_state(::extensions::api::cast_channel::proto::ErrorState value) {
  assert(::extensions::api::cast_channel::proto::ErrorState_IsValid(value));
  set_has_error_state();
  error_state_ = value;
}

// optional .extensions.api.cast_channel.proto.ChallengeReplyErrorType challenge_reply_error_type = 11;
inline bool SocketEvent::has_challenge_reply_error_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SocketEvent::set_has_challenge_reply_error_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SocketEvent::clear_has_challenge_reply_error_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SocketEvent::clear_challenge_reply_error_type() {
  challenge_reply_error_type_ = 1;
  clear_has_challenge_reply_error_type();
}
inline ::extensions::api::cast_channel::proto::ChallengeReplyErrorType SocketEvent::challenge_reply_error_type() const {
  return static_cast< ::extensions::api::cast_channel::proto::ChallengeReplyErrorType >(challenge_reply_error_type_);
}
inline void SocketEvent::set_challenge_reply_error_type(::extensions::api::cast_channel::proto::ChallengeReplyErrorType value) {
  assert(::extensions::api::cast_channel::proto::ChallengeReplyErrorType_IsValid(value));
  set_has_challenge_reply_error_type();
  challenge_reply_error_type_ = value;
}

// optional int32 nss_error_code = 12;
inline bool SocketEvent::has_nss_error_code() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SocketEvent::set_has_nss_error_code() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SocketEvent::clear_has_nss_error_code() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SocketEvent::clear_nss_error_code() {
  nss_error_code_ = 0;
  clear_has_nss_error_code();
}
inline ::google::protobuf::int32 SocketEvent::nss_error_code() const {
  return nss_error_code_;
}
inline void SocketEvent::set_nss_error_code(::google::protobuf::int32 value) {
  set_has_nss_error_code();
  nss_error_code_ = value;
}

// -------------------------------------------------------------------

// AggregatedSocketEvent

// optional int32 id = 1;
inline bool AggregatedSocketEvent::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AggregatedSocketEvent::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AggregatedSocketEvent::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AggregatedSocketEvent::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 AggregatedSocketEvent::id() const {
  return id_;
}
inline void AggregatedSocketEvent::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 endpoint_id = 2;
inline bool AggregatedSocketEvent::has_endpoint_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AggregatedSocketEvent::set_has_endpoint_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AggregatedSocketEvent::clear_has_endpoint_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AggregatedSocketEvent::clear_endpoint_id() {
  endpoint_id_ = 0;
  clear_has_endpoint_id();
}
inline ::google::protobuf::int32 AggregatedSocketEvent::endpoint_id() const {
  return endpoint_id_;
}
inline void AggregatedSocketEvent::set_endpoint_id(::google::protobuf::int32 value) {
  set_has_endpoint_id();
  endpoint_id_ = value;
}

// optional .extensions.api.cast_channel.proto.ChannelAuth channel_auth_type = 3;
inline bool AggregatedSocketEvent::has_channel_auth_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AggregatedSocketEvent::set_has_channel_auth_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AggregatedSocketEvent::clear_has_channel_auth_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AggregatedSocketEvent::clear_channel_auth_type() {
  channel_auth_type_ = 1;
  clear_has_channel_auth_type();
}
inline ::extensions::api::cast_channel::proto::ChannelAuth AggregatedSocketEvent::channel_auth_type() const {
  return static_cast< ::extensions::api::cast_channel::proto::ChannelAuth >(channel_auth_type_);
}
inline void AggregatedSocketEvent::set_channel_auth_type(::extensions::api::cast_channel::proto::ChannelAuth value) {
  assert(::extensions::api::cast_channel::proto::ChannelAuth_IsValid(value));
  set_has_channel_auth_type();
  channel_auth_type_ = value;
}

// repeated .extensions.api.cast_channel.proto.SocketEvent socket_event = 4;
inline int AggregatedSocketEvent::socket_event_size() const {
  return socket_event_.size();
}
inline void AggregatedSocketEvent::clear_socket_event() {
  socket_event_.Clear();
}
inline const ::extensions::api::cast_channel::proto::SocketEvent& AggregatedSocketEvent::socket_event(int index) const {
  return socket_event_.Get(index);
}
inline ::extensions::api::cast_channel::proto::SocketEvent* AggregatedSocketEvent::mutable_socket_event(int index) {
  return socket_event_.Mutable(index);
}
inline ::extensions::api::cast_channel::proto::SocketEvent* AggregatedSocketEvent::add_socket_event() {
  return socket_event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::extensions::api::cast_channel::proto::SocketEvent >&
AggregatedSocketEvent::socket_event() const {
  return socket_event_;
}
inline ::google::protobuf::RepeatedPtrField< ::extensions::api::cast_channel::proto::SocketEvent >*
AggregatedSocketEvent::mutable_socket_event() {
  return &socket_event_;
}

// optional int64 bytes_read = 5;
inline bool AggregatedSocketEvent::has_bytes_read() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AggregatedSocketEvent::set_has_bytes_read() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AggregatedSocketEvent::clear_has_bytes_read() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AggregatedSocketEvent::clear_bytes_read() {
  bytes_read_ = GOOGLE_LONGLONG(0);
  clear_has_bytes_read();
}
inline ::google::protobuf::int64 AggregatedSocketEvent::bytes_read() const {
  return bytes_read_;
}
inline void AggregatedSocketEvent::set_bytes_read(::google::protobuf::int64 value) {
  set_has_bytes_read();
  bytes_read_ = value;
}

// optional int64 bytes_written = 6;
inline bool AggregatedSocketEvent::has_bytes_written() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AggregatedSocketEvent::set_has_bytes_written() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AggregatedSocketEvent::clear_has_bytes_written() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AggregatedSocketEvent::clear_bytes_written() {
  bytes_written_ = GOOGLE_LONGLONG(0);
  clear_has_bytes_written();
}
inline ::google::protobuf::int64 AggregatedSocketEvent::bytes_written() const {
  return bytes_written_;
}
inline void AggregatedSocketEvent::set_bytes_written(::google::protobuf::int64 value) {
  set_has_bytes_written();
  bytes_written_ = value;
}

// -------------------------------------------------------------------

// Log

// repeated .extensions.api.cast_channel.proto.AggregatedSocketEvent aggregated_socket_event = 1;
inline int Log::aggregated_socket_event_size() const {
  return aggregated_socket_event_.size();
}
inline void Log::clear_aggregated_socket_event() {
  aggregated_socket_event_.Clear();
}
inline const ::extensions::api::cast_channel::proto::AggregatedSocketEvent& Log::aggregated_socket_event(int index) const {
  return aggregated_socket_event_.Get(index);
}
inline ::extensions::api::cast_channel::proto::AggregatedSocketEvent* Log::mutable_aggregated_socket_event(int index) {
  return aggregated_socket_event_.Mutable(index);
}
inline ::extensions::api::cast_channel::proto::AggregatedSocketEvent* Log::add_aggregated_socket_event() {
  return aggregated_socket_event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::extensions::api::cast_channel::proto::AggregatedSocketEvent >&
Log::aggregated_socket_event() const {
  return aggregated_socket_event_;
}
inline ::google::protobuf::RepeatedPtrField< ::extensions::api::cast_channel::proto::AggregatedSocketEvent >*
Log::mutable_aggregated_socket_event() {
  return &aggregated_socket_event_;
}

// optional int32 num_evicted_aggregated_socket_events = 2;
inline bool Log::has_num_evicted_aggregated_socket_events() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Log::set_has_num_evicted_aggregated_socket_events() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Log::clear_has_num_evicted_aggregated_socket_events() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Log::clear_num_evicted_aggregated_socket_events() {
  num_evicted_aggregated_socket_events_ = 0;
  clear_has_num_evicted_aggregated_socket_events();
}
inline ::google::protobuf::int32 Log::num_evicted_aggregated_socket_events() const {
  return num_evicted_aggregated_socket_events_;
}
inline void Log::set_num_evicted_aggregated_socket_events(::google::protobuf::int32 value) {
  set_has_num_evicted_aggregated_socket_events();
  num_evicted_aggregated_socket_events_ = value;
}

// optional int32 num_evicted_socket_events = 3;
inline bool Log::has_num_evicted_socket_events() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Log::set_has_num_evicted_socket_events() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Log::clear_has_num_evicted_socket_events() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Log::clear_num_evicted_socket_events() {
  num_evicted_socket_events_ = 0;
  clear_has_num_evicted_socket_events();
}
inline ::google::protobuf::int32 Log::num_evicted_socket_events() const {
  return num_evicted_socket_events_;
}
inline void Log::set_num_evicted_socket_events(::google::protobuf::int32 value) {
  set_has_num_evicted_socket_events();
  num_evicted_socket_events_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cast_channel
}  // namespace api
}  // namespace extensions

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_logging_2eproto__INCLUDED
