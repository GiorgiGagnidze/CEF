// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: property_tree.proto

#ifndef PROTOBUF_property_5ftree_2eproto__INCLUDED
#define PROTOBUF_property_5ftree_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "rectf.pb.h"
#include "scroll_offset.pb.h"
#include "transform.pb.h"
#include "vector2df.pb.h"
// @@protoc_insertion_point(includes)
#include "cc/proto/cc_proto_export.h"

namespace cc {
namespace proto {

// Internal implementation detail -- do not call these.
void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
void protobuf_AssignDesc_property_5ftree_2eproto();
void protobuf_ShutdownFile_property_5ftree_2eproto();

class TranformNodeData;
class ClipNodeData;
class EffectNodeData;
class ScrollNodeData;
class TreeNode;
class PropertyTree;
class TransformTreeData;
class PropertyTrees;

enum PropertyTree_PropertyType {
  PropertyTree_PropertyType_Transform = 1,
  PropertyTree_PropertyType_Clip = 2,
  PropertyTree_PropertyType_Effect = 3,
  PropertyTree_PropertyType_Scroll = 4
};
CC_PROTO_EXPORT bool PropertyTree_PropertyType_IsValid(int value);
const PropertyTree_PropertyType PropertyTree_PropertyType_PropertyType_MIN = PropertyTree_PropertyType_Transform;
const PropertyTree_PropertyType PropertyTree_PropertyType_PropertyType_MAX = PropertyTree_PropertyType_Scroll;
const int PropertyTree_PropertyType_PropertyType_ARRAYSIZE = PropertyTree_PropertyType_PropertyType_MAX + 1;

// ===================================================================

class CC_PROTO_EXPORT TranformNodeData : public ::google::protobuf::MessageLite {
 public:
  TranformNodeData();
  virtual ~TranformNodeData();

  TranformNodeData(const TranformNodeData& from);

  inline TranformNodeData& operator=(const TranformNodeData& from) {
    CopyFrom(from);
    return *this;
  }

  static const TranformNodeData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TranformNodeData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TranformNodeData* other);

  // implements Message ----------------------------------------------

  TranformNodeData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TranformNodeData& from);
  void MergeFrom(const TranformNodeData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cc.proto.Transform pre_local = 1;
  inline bool has_pre_local() const;
  inline void clear_pre_local();
  static const int kPreLocalFieldNumber = 1;
  inline const ::cc::proto::Transform& pre_local() const;
  inline ::cc::proto::Transform* mutable_pre_local();
  inline ::cc::proto::Transform* release_pre_local();
  inline void set_allocated_pre_local(::cc::proto::Transform* pre_local);

  // optional .cc.proto.Transform local = 2;
  inline bool has_local() const;
  inline void clear_local();
  static const int kLocalFieldNumber = 2;
  inline const ::cc::proto::Transform& local() const;
  inline ::cc::proto::Transform* mutable_local();
  inline ::cc::proto::Transform* release_local();
  inline void set_allocated_local(::cc::proto::Transform* local);

  // optional .cc.proto.Transform post_local = 3;
  inline bool has_post_local() const;
  inline void clear_post_local();
  static const int kPostLocalFieldNumber = 3;
  inline const ::cc::proto::Transform& post_local() const;
  inline ::cc::proto::Transform* mutable_post_local();
  inline ::cc::proto::Transform* release_post_local();
  inline void set_allocated_post_local(::cc::proto::Transform* post_local);

  // optional .cc.proto.Transform to_parent = 4;
  inline bool has_to_parent() const;
  inline void clear_to_parent();
  static const int kToParentFieldNumber = 4;
  inline const ::cc::proto::Transform& to_parent() const;
  inline ::cc::proto::Transform* mutable_to_parent();
  inline ::cc::proto::Transform* release_to_parent();
  inline void set_allocated_to_parent(::cc::proto::Transform* to_parent);

  // optional .cc.proto.Transform to_target = 5;
  inline bool has_to_target() const;
  inline void clear_to_target();
  static const int kToTargetFieldNumber = 5;
  inline const ::cc::proto::Transform& to_target() const;
  inline ::cc::proto::Transform* mutable_to_target();
  inline ::cc::proto::Transform* release_to_target();
  inline void set_allocated_to_target(::cc::proto::Transform* to_target);

  // optional .cc.proto.Transform from_target = 6;
  inline bool has_from_target() const;
  inline void clear_from_target();
  static const int kFromTargetFieldNumber = 6;
  inline const ::cc::proto::Transform& from_target() const;
  inline ::cc::proto::Transform* mutable_from_target();
  inline ::cc::proto::Transform* release_from_target();
  inline void set_allocated_from_target(::cc::proto::Transform* from_target);

  // optional .cc.proto.Transform to_screen = 7;
  inline bool has_to_screen() const;
  inline void clear_to_screen();
  static const int kToScreenFieldNumber = 7;
  inline const ::cc::proto::Transform& to_screen() const;
  inline ::cc::proto::Transform* mutable_to_screen();
  inline ::cc::proto::Transform* release_to_screen();
  inline void set_allocated_to_screen(::cc::proto::Transform* to_screen);

  // optional .cc.proto.Transform from_screen = 8;
  inline bool has_from_screen() const;
  inline void clear_from_screen();
  static const int kFromScreenFieldNumber = 8;
  inline const ::cc::proto::Transform& from_screen() const;
  inline ::cc::proto::Transform* mutable_from_screen();
  inline ::cc::proto::Transform* release_from_screen();
  inline void set_allocated_from_screen(::cc::proto::Transform* from_screen);

  // optional int64 target_id = 9;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 9;
  inline ::google::protobuf::int64 target_id() const;
  inline void set_target_id(::google::protobuf::int64 value);

  // optional int64 content_target_id = 10;
  inline bool has_content_target_id() const;
  inline void clear_content_target_id();
  static const int kContentTargetIdFieldNumber = 10;
  inline ::google::protobuf::int64 content_target_id() const;
  inline void set_content_target_id(::google::protobuf::int64 value);

  // optional int64 source_node_id = 11;
  inline bool has_source_node_id() const;
  inline void clear_source_node_id();
  static const int kSourceNodeIdFieldNumber = 11;
  inline ::google::protobuf::int64 source_node_id() const;
  inline void set_source_node_id(::google::protobuf::int64 value);

  // optional bool needs_local_transform_update = 12;
  inline bool has_needs_local_transform_update() const;
  inline void clear_needs_local_transform_update();
  static const int kNeedsLocalTransformUpdateFieldNumber = 12;
  inline bool needs_local_transform_update() const;
  inline void set_needs_local_transform_update(bool value);

  // optional bool is_invertible = 13;
  inline bool has_is_invertible() const;
  inline void clear_is_invertible();
  static const int kIsInvertibleFieldNumber = 13;
  inline bool is_invertible() const;
  inline void set_is_invertible(bool value);

  // optional bool ancestors_are_invertible = 14;
  inline bool has_ancestors_are_invertible() const;
  inline void clear_ancestors_are_invertible();
  static const int kAncestorsAreInvertibleFieldNumber = 14;
  inline bool ancestors_are_invertible() const;
  inline void set_ancestors_are_invertible(bool value);

  // optional bool is_animated = 15;
  inline bool has_is_animated() const;
  inline void clear_is_animated();
  static const int kIsAnimatedFieldNumber = 15;
  inline bool is_animated() const;
  inline void set_is_animated(bool value);

  // optional bool to_screen_is_animated = 16;
  inline bool has_to_screen_is_animated() const;
  inline void clear_to_screen_is_animated();
  static const int kToScreenIsAnimatedFieldNumber = 16;
  inline bool to_screen_is_animated() const;
  inline void set_to_screen_is_animated(bool value);

  // optional bool has_only_translation_animations = 17;
  inline bool has_has_only_translation_animations() const;
  inline void clear_has_only_translation_animations();
  static const int kHasOnlyTranslationAnimationsFieldNumber = 17;
  inline bool has_only_translation_animations() const;
  inline void set_has_only_translation_animations(bool value);

  // optional bool to_screen_has_scale_animation = 18;
  inline bool has_to_screen_has_scale_animation() const;
  inline void clear_to_screen_has_scale_animation();
  static const int kToScreenHasScaleAnimationFieldNumber = 18;
  inline bool to_screen_has_scale_animation() const;
  inline void set_to_screen_has_scale_animation(bool value);

  // optional bool flattens_inherited_transform = 19;
  inline bool has_flattens_inherited_transform() const;
  inline void clear_flattens_inherited_transform();
  static const int kFlattensInheritedTransformFieldNumber = 19;
  inline bool flattens_inherited_transform() const;
  inline void set_flattens_inherited_transform(bool value);

  // optional bool node_and_ancestors_are_flat = 20;
  inline bool has_node_and_ancestors_are_flat() const;
  inline void clear_node_and_ancestors_are_flat();
  static const int kNodeAndAncestorsAreFlatFieldNumber = 20;
  inline bool node_and_ancestors_are_flat() const;
  inline void set_node_and_ancestors_are_flat(bool value);

  // optional bool node_and_ancestors_have_only_integer_translation = 21;
  inline bool has_node_and_ancestors_have_only_integer_translation() const;
  inline void clear_node_and_ancestors_have_only_integer_translation();
  static const int kNodeAndAncestorsHaveOnlyIntegerTranslationFieldNumber = 21;
  inline bool node_and_ancestors_have_only_integer_translation() const;
  inline void set_node_and_ancestors_have_only_integer_translation(bool value);

  // optional bool scrolls = 22;
  inline bool has_scrolls() const;
  inline void clear_scrolls();
  static const int kScrollsFieldNumber = 22;
  inline bool scrolls() const;
  inline void set_scrolls(bool value);

  // optional bool needs_sublayer_scale = 23;
  inline bool has_needs_sublayer_scale() const;
  inline void clear_needs_sublayer_scale();
  static const int kNeedsSublayerScaleFieldNumber = 23;
  inline bool needs_sublayer_scale() const;
  inline void set_needs_sublayer_scale(bool value);

  // optional bool affected_by_inner_viewport_bounds_delta_x = 24;
  inline bool has_affected_by_inner_viewport_bounds_delta_x() const;
  inline void clear_affected_by_inner_viewport_bounds_delta_x();
  static const int kAffectedByInnerViewportBoundsDeltaXFieldNumber = 24;
  inline bool affected_by_inner_viewport_bounds_delta_x() const;
  inline void set_affected_by_inner_viewport_bounds_delta_x(bool value);

  // optional bool affected_by_inner_viewport_bounds_delta_y = 25;
  inline bool has_affected_by_inner_viewport_bounds_delta_y() const;
  inline void clear_affected_by_inner_viewport_bounds_delta_y();
  static const int kAffectedByInnerViewportBoundsDeltaYFieldNumber = 25;
  inline bool affected_by_inner_viewport_bounds_delta_y() const;
  inline void set_affected_by_inner_viewport_bounds_delta_y(bool value);

  // optional bool affected_by_outer_viewport_bounds_delta_x = 26;
  inline bool has_affected_by_outer_viewport_bounds_delta_x() const;
  inline void clear_affected_by_outer_viewport_bounds_delta_x();
  static const int kAffectedByOuterViewportBoundsDeltaXFieldNumber = 26;
  inline bool affected_by_outer_viewport_bounds_delta_x() const;
  inline void set_affected_by_outer_viewport_bounds_delta_x(bool value);

  // optional bool affected_by_outer_viewport_bounds_delta_y = 27;
  inline bool has_affected_by_outer_viewport_bounds_delta_y() const;
  inline void clear_affected_by_outer_viewport_bounds_delta_y();
  static const int kAffectedByOuterViewportBoundsDeltaYFieldNumber = 27;
  inline bool affected_by_outer_viewport_bounds_delta_y() const;
  inline void set_affected_by_outer_viewport_bounds_delta_y(bool value);

  // optional bool in_subtree_of_page_scale_layer = 28;
  inline bool has_in_subtree_of_page_scale_layer() const;
  inline void clear_in_subtree_of_page_scale_layer();
  static const int kInSubtreeOfPageScaleLayerFieldNumber = 28;
  inline bool in_subtree_of_page_scale_layer() const;
  inline void set_in_subtree_of_page_scale_layer(bool value);

  // optional float post_local_scale_factor = 29;
  inline bool has_post_local_scale_factor() const;
  inline void clear_post_local_scale_factor();
  static const int kPostLocalScaleFactorFieldNumber = 29;
  inline float post_local_scale_factor() const;
  inline void set_post_local_scale_factor(float value);

  // optional float local_maximum_animation_target_scale = 30;
  inline bool has_local_maximum_animation_target_scale() const;
  inline void clear_local_maximum_animation_target_scale();
  static const int kLocalMaximumAnimationTargetScaleFieldNumber = 30;
  inline float local_maximum_animation_target_scale() const;
  inline void set_local_maximum_animation_target_scale(float value);

  // optional float local_starting_animation_scale = 31;
  inline bool has_local_starting_animation_scale() const;
  inline void clear_local_starting_animation_scale();
  static const int kLocalStartingAnimationScaleFieldNumber = 31;
  inline float local_starting_animation_scale() const;
  inline void set_local_starting_animation_scale(float value);

  // optional float combined_maximum_animation_target_scale = 32;
  inline bool has_combined_maximum_animation_target_scale() const;
  inline void clear_combined_maximum_animation_target_scale();
  static const int kCombinedMaximumAnimationTargetScaleFieldNumber = 32;
  inline float combined_maximum_animation_target_scale() const;
  inline void set_combined_maximum_animation_target_scale(float value);

  // optional float combined_starting_animation_scale = 33;
  inline bool has_combined_starting_animation_scale() const;
  inline void clear_combined_starting_animation_scale();
  static const int kCombinedStartingAnimationScaleFieldNumber = 33;
  inline float combined_starting_animation_scale() const;
  inline void set_combined_starting_animation_scale(float value);

  // optional .cc.proto.Vector2dF sublayer_scale = 34;
  inline bool has_sublayer_scale() const;
  inline void clear_sublayer_scale();
  static const int kSublayerScaleFieldNumber = 34;
  inline const ::cc::proto::Vector2dF& sublayer_scale() const;
  inline ::cc::proto::Vector2dF* mutable_sublayer_scale();
  inline ::cc::proto::Vector2dF* release_sublayer_scale();
  inline void set_allocated_sublayer_scale(::cc::proto::Vector2dF* sublayer_scale);

  // optional .cc.proto.ScrollOffset scroll_offset = 35;
  inline bool has_scroll_offset() const;
  inline void clear_scroll_offset();
  static const int kScrollOffsetFieldNumber = 35;
  inline const ::cc::proto::ScrollOffset& scroll_offset() const;
  inline ::cc::proto::ScrollOffset* mutable_scroll_offset();
  inline ::cc::proto::ScrollOffset* release_scroll_offset();
  inline void set_allocated_scroll_offset(::cc::proto::ScrollOffset* scroll_offset);

  // optional .cc.proto.Vector2dF scroll_snap = 36;
  inline bool has_scroll_snap() const;
  inline void clear_scroll_snap();
  static const int kScrollSnapFieldNumber = 36;
  inline const ::cc::proto::Vector2dF& scroll_snap() const;
  inline ::cc::proto::Vector2dF* mutable_scroll_snap();
  inline ::cc::proto::Vector2dF* release_scroll_snap();
  inline void set_allocated_scroll_snap(::cc::proto::Vector2dF* scroll_snap);

  // optional .cc.proto.Vector2dF source_offset = 37;
  inline bool has_source_offset() const;
  inline void clear_source_offset();
  static const int kSourceOffsetFieldNumber = 37;
  inline const ::cc::proto::Vector2dF& source_offset() const;
  inline ::cc::proto::Vector2dF* mutable_source_offset();
  inline ::cc::proto::Vector2dF* release_source_offset();
  inline void set_allocated_source_offset(::cc::proto::Vector2dF* source_offset);

  // optional .cc.proto.Vector2dF source_to_parent = 38;
  inline bool has_source_to_parent() const;
  inline void clear_source_to_parent();
  static const int kSourceToParentFieldNumber = 38;
  inline const ::cc::proto::Vector2dF& source_to_parent() const;
  inline ::cc::proto::Vector2dF* mutable_source_to_parent();
  inline ::cc::proto::Vector2dF* release_source_to_parent();
  inline void set_allocated_source_to_parent(::cc::proto::Vector2dF* source_to_parent);

  // optional int64 sorting_context_id = 39;
  inline bool has_sorting_context_id() const;
  inline void clear_sorting_context_id();
  static const int kSortingContextIdFieldNumber = 39;
  inline ::google::protobuf::int64 sorting_context_id() const;
  inline void set_sorting_context_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:cc.proto.TranformNodeData)
 private:
  inline void set_has_pre_local();
  inline void clear_has_pre_local();
  inline void set_has_local();
  inline void clear_has_local();
  inline void set_has_post_local();
  inline void clear_has_post_local();
  inline void set_has_to_parent();
  inline void clear_has_to_parent();
  inline void set_has_to_target();
  inline void clear_has_to_target();
  inline void set_has_from_target();
  inline void clear_has_from_target();
  inline void set_has_to_screen();
  inline void clear_has_to_screen();
  inline void set_has_from_screen();
  inline void clear_has_from_screen();
  inline void set_has_target_id();
  inline void clear_has_target_id();
  inline void set_has_content_target_id();
  inline void clear_has_content_target_id();
  inline void set_has_source_node_id();
  inline void clear_has_source_node_id();
  inline void set_has_needs_local_transform_update();
  inline void clear_has_needs_local_transform_update();
  inline void set_has_is_invertible();
  inline void clear_has_is_invertible();
  inline void set_has_ancestors_are_invertible();
  inline void clear_has_ancestors_are_invertible();
  inline void set_has_is_animated();
  inline void clear_has_is_animated();
  inline void set_has_to_screen_is_animated();
  inline void clear_has_to_screen_is_animated();
  inline void set_has_has_only_translation_animations();
  inline void clear_has_has_only_translation_animations();
  inline void set_has_to_screen_has_scale_animation();
  inline void clear_has_to_screen_has_scale_animation();
  inline void set_has_flattens_inherited_transform();
  inline void clear_has_flattens_inherited_transform();
  inline void set_has_node_and_ancestors_are_flat();
  inline void clear_has_node_and_ancestors_are_flat();
  inline void set_has_node_and_ancestors_have_only_integer_translation();
  inline void clear_has_node_and_ancestors_have_only_integer_translation();
  inline void set_has_scrolls();
  inline void clear_has_scrolls();
  inline void set_has_needs_sublayer_scale();
  inline void clear_has_needs_sublayer_scale();
  inline void set_has_affected_by_inner_viewport_bounds_delta_x();
  inline void clear_has_affected_by_inner_viewport_bounds_delta_x();
  inline void set_has_affected_by_inner_viewport_bounds_delta_y();
  inline void clear_has_affected_by_inner_viewport_bounds_delta_y();
  inline void set_has_affected_by_outer_viewport_bounds_delta_x();
  inline void clear_has_affected_by_outer_viewport_bounds_delta_x();
  inline void set_has_affected_by_outer_viewport_bounds_delta_y();
  inline void clear_has_affected_by_outer_viewport_bounds_delta_y();
  inline void set_has_in_subtree_of_page_scale_layer();
  inline void clear_has_in_subtree_of_page_scale_layer();
  inline void set_has_post_local_scale_factor();
  inline void clear_has_post_local_scale_factor();
  inline void set_has_local_maximum_animation_target_scale();
  inline void clear_has_local_maximum_animation_target_scale();
  inline void set_has_local_starting_animation_scale();
  inline void clear_has_local_starting_animation_scale();
  inline void set_has_combined_maximum_animation_target_scale();
  inline void clear_has_combined_maximum_animation_target_scale();
  inline void set_has_combined_starting_animation_scale();
  inline void clear_has_combined_starting_animation_scale();
  inline void set_has_sublayer_scale();
  inline void clear_has_sublayer_scale();
  inline void set_has_scroll_offset();
  inline void clear_has_scroll_offset();
  inline void set_has_scroll_snap();
  inline void clear_has_scroll_snap();
  inline void set_has_source_offset();
  inline void clear_has_source_offset();
  inline void set_has_source_to_parent();
  inline void clear_has_source_to_parent();
  inline void set_has_sorting_context_id();
  inline void clear_has_sorting_context_id();

  ::cc::proto::Transform* pre_local_;
  ::cc::proto::Transform* local_;
  ::cc::proto::Transform* post_local_;
  ::cc::proto::Transform* to_parent_;
  ::cc::proto::Transform* to_target_;
  ::cc::proto::Transform* from_target_;
  ::cc::proto::Transform* to_screen_;
  ::cc::proto::Transform* from_screen_;
  ::google::protobuf::int64 target_id_;
  ::google::protobuf::int64 content_target_id_;
  ::google::protobuf::int64 source_node_id_;
  bool needs_local_transform_update_;
  bool is_invertible_;
  bool ancestors_are_invertible_;
  bool is_animated_;
  bool to_screen_is_animated_;
  bool has_only_translation_animations_;
  bool to_screen_has_scale_animation_;
  bool flattens_inherited_transform_;
  bool node_and_ancestors_are_flat_;
  bool node_and_ancestors_have_only_integer_translation_;
  bool scrolls_;
  bool needs_sublayer_scale_;
  bool affected_by_inner_viewport_bounds_delta_x_;
  bool affected_by_inner_viewport_bounds_delta_y_;
  bool affected_by_outer_viewport_bounds_delta_x_;
  bool affected_by_outer_viewport_bounds_delta_y_;
  bool in_subtree_of_page_scale_layer_;
  float post_local_scale_factor_;
  float local_maximum_animation_target_scale_;
  float local_starting_animation_scale_;
  float combined_maximum_animation_target_scale_;
  float combined_starting_animation_scale_;
  ::cc::proto::Vector2dF* sublayer_scale_;
  ::cc::proto::ScrollOffset* scroll_offset_;
  ::cc::proto::Vector2dF* scroll_snap_;
  ::cc::proto::Vector2dF* source_offset_;
  ::cc::proto::Vector2dF* source_to_parent_;
  ::google::protobuf::int64 sorting_context_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(39 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
  #endif
  friend void protobuf_AssignDesc_property_5ftree_2eproto();
  friend void protobuf_ShutdownFile_property_5ftree_2eproto();

  void InitAsDefaultInstance();
  static TranformNodeData* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT ClipNodeData : public ::google::protobuf::MessageLite {
 public:
  ClipNodeData();
  virtual ~ClipNodeData();

  ClipNodeData(const ClipNodeData& from);

  inline ClipNodeData& operator=(const ClipNodeData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClipNodeData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClipNodeData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClipNodeData* other);

  // implements Message ----------------------------------------------

  ClipNodeData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClipNodeData& from);
  void MergeFrom(const ClipNodeData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cc.proto.RectF clip = 1;
  inline bool has_clip() const;
  inline void clear_clip();
  static const int kClipFieldNumber = 1;
  inline const ::cc::proto::RectF& clip() const;
  inline ::cc::proto::RectF* mutable_clip();
  inline ::cc::proto::RectF* release_clip();
  inline void set_allocated_clip(::cc::proto::RectF* clip);

  // optional .cc.proto.RectF combined_clip_in_target_space = 2;
  inline bool has_combined_clip_in_target_space() const;
  inline void clear_combined_clip_in_target_space();
  static const int kCombinedClipInTargetSpaceFieldNumber = 2;
  inline const ::cc::proto::RectF& combined_clip_in_target_space() const;
  inline ::cc::proto::RectF* mutable_combined_clip_in_target_space();
  inline ::cc::proto::RectF* release_combined_clip_in_target_space();
  inline void set_allocated_combined_clip_in_target_space(::cc::proto::RectF* combined_clip_in_target_space);

  // optional .cc.proto.RectF clip_in_target_space = 3;
  inline bool has_clip_in_target_space() const;
  inline void clear_clip_in_target_space();
  static const int kClipInTargetSpaceFieldNumber = 3;
  inline const ::cc::proto::RectF& clip_in_target_space() const;
  inline ::cc::proto::RectF* mutable_clip_in_target_space();
  inline ::cc::proto::RectF* release_clip_in_target_space();
  inline void set_allocated_clip_in_target_space(::cc::proto::RectF* clip_in_target_space);

  // optional int64 transform_id = 4;
  inline bool has_transform_id() const;
  inline void clear_transform_id();
  static const int kTransformIdFieldNumber = 4;
  inline ::google::protobuf::int64 transform_id() const;
  inline void set_transform_id(::google::protobuf::int64 value);

  // optional int64 target_id = 5;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 5;
  inline ::google::protobuf::int64 target_id() const;
  inline void set_target_id(::google::protobuf::int64 value);

  // optional bool applies_local_clip = 6;
  inline bool has_applies_local_clip() const;
  inline void clear_applies_local_clip();
  static const int kAppliesLocalClipFieldNumber = 6;
  inline bool applies_local_clip() const;
  inline void set_applies_local_clip(bool value);

  // optional bool layer_clipping_uses_only_local_clip = 7;
  inline bool has_layer_clipping_uses_only_local_clip() const;
  inline void clear_layer_clipping_uses_only_local_clip();
  static const int kLayerClippingUsesOnlyLocalClipFieldNumber = 7;
  inline bool layer_clipping_uses_only_local_clip() const;
  inline void set_layer_clipping_uses_only_local_clip(bool value);

  // optional bool target_is_clipped = 8;
  inline bool has_target_is_clipped() const;
  inline void clear_target_is_clipped();
  static const int kTargetIsClippedFieldNumber = 8;
  inline bool target_is_clipped() const;
  inline void set_target_is_clipped(bool value);

  // optional bool layers_are_clipped = 9;
  inline bool has_layers_are_clipped() const;
  inline void clear_layers_are_clipped();
  static const int kLayersAreClippedFieldNumber = 9;
  inline bool layers_are_clipped() const;
  inline void set_layers_are_clipped(bool value);

  // optional bool layers_are_clipped_when_surfaces_disabled = 10;
  inline bool has_layers_are_clipped_when_surfaces_disabled() const;
  inline void clear_layers_are_clipped_when_surfaces_disabled();
  static const int kLayersAreClippedWhenSurfacesDisabledFieldNumber = 10;
  inline bool layers_are_clipped_when_surfaces_disabled() const;
  inline void set_layers_are_clipped_when_surfaces_disabled(bool value);

  // optional bool resets_clip = 11;
  inline bool has_resets_clip() const;
  inline void clear_resets_clip();
  static const int kResetsClipFieldNumber = 11;
  inline bool resets_clip() const;
  inline void set_resets_clip(bool value);

  // @@protoc_insertion_point(class_scope:cc.proto.ClipNodeData)
 private:
  inline void set_has_clip();
  inline void clear_has_clip();
  inline void set_has_combined_clip_in_target_space();
  inline void clear_has_combined_clip_in_target_space();
  inline void set_has_clip_in_target_space();
  inline void clear_has_clip_in_target_space();
  inline void set_has_transform_id();
  inline void clear_has_transform_id();
  inline void set_has_target_id();
  inline void clear_has_target_id();
  inline void set_has_applies_local_clip();
  inline void clear_has_applies_local_clip();
  inline void set_has_layer_clipping_uses_only_local_clip();
  inline void clear_has_layer_clipping_uses_only_local_clip();
  inline void set_has_target_is_clipped();
  inline void clear_has_target_is_clipped();
  inline void set_has_layers_are_clipped();
  inline void clear_has_layers_are_clipped();
  inline void set_has_layers_are_clipped_when_surfaces_disabled();
  inline void clear_has_layers_are_clipped_when_surfaces_disabled();
  inline void set_has_resets_clip();
  inline void clear_has_resets_clip();

  ::cc::proto::RectF* clip_;
  ::cc::proto::RectF* combined_clip_in_target_space_;
  ::cc::proto::RectF* clip_in_target_space_;
  ::google::protobuf::int64 transform_id_;
  ::google::protobuf::int64 target_id_;
  bool applies_local_clip_;
  bool layer_clipping_uses_only_local_clip_;
  bool target_is_clipped_;
  bool layers_are_clipped_;
  bool layers_are_clipped_when_surfaces_disabled_;
  bool resets_clip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
  #endif
  friend void protobuf_AssignDesc_property_5ftree_2eproto();
  friend void protobuf_ShutdownFile_property_5ftree_2eproto();

  void InitAsDefaultInstance();
  static ClipNodeData* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT EffectNodeData : public ::google::protobuf::MessageLite {
 public:
  EffectNodeData();
  virtual ~EffectNodeData();

  EffectNodeData(const EffectNodeData& from);

  inline EffectNodeData& operator=(const EffectNodeData& from) {
    CopyFrom(from);
    return *this;
  }

  static const EffectNodeData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EffectNodeData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EffectNodeData* other);

  // implements Message ----------------------------------------------

  EffectNodeData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EffectNodeData& from);
  void MergeFrom(const EffectNodeData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float opacity = 1;
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 1;
  inline float opacity() const;
  inline void set_opacity(float value);

  // optional float screen_space_opacity = 2;
  inline bool has_screen_space_opacity() const;
  inline void clear_screen_space_opacity();
  static const int kScreenSpaceOpacityFieldNumber = 2;
  inline float screen_space_opacity() const;
  inline void set_screen_space_opacity(float value);

  // optional bool has_render_surface = 3;
  inline bool has_has_render_surface() const;
  inline void clear_has_render_surface();
  static const int kHasRenderSurfaceFieldNumber = 3;
  inline bool has_render_surface() const;
  inline void set_has_render_surface(bool value);

  // optional bool has_copy_request = 4;
  inline bool has_has_copy_request() const;
  inline void clear_has_copy_request();
  static const int kHasCopyRequestFieldNumber = 4;
  inline bool has_copy_request() const;
  inline void set_has_copy_request(bool value);

  // optional bool has_background_filters = 5;
  inline bool has_has_background_filters() const;
  inline void clear_has_background_filters();
  static const int kHasBackgroundFiltersFieldNumber = 5;
  inline bool has_background_filters() const;
  inline void set_has_background_filters(bool value);

  // optional bool is_drawn = 6;
  inline bool has_is_drawn() const;
  inline void clear_is_drawn();
  static const int kIsDrawnFieldNumber = 6;
  inline bool is_drawn() const;
  inline void set_is_drawn(bool value);

  // optional bool has_animated_opacity = 7;
  inline bool has_has_animated_opacity() const;
  inline void clear_has_animated_opacity();
  static const int kHasAnimatedOpacityFieldNumber = 7;
  inline bool has_animated_opacity() const;
  inline void set_has_animated_opacity(bool value);

  // optional int64 num_copy_requests_in_subtree = 8;
  inline bool has_num_copy_requests_in_subtree() const;
  inline void clear_num_copy_requests_in_subtree();
  static const int kNumCopyRequestsInSubtreeFieldNumber = 8;
  inline ::google::protobuf::int64 num_copy_requests_in_subtree() const;
  inline void set_num_copy_requests_in_subtree(::google::protobuf::int64 value);

  // optional int64 transform_id = 9;
  inline bool has_transform_id() const;
  inline void clear_transform_id();
  static const int kTransformIdFieldNumber = 9;
  inline ::google::protobuf::int64 transform_id() const;
  inline void set_transform_id(::google::protobuf::int64 value);

  // optional int64 clip_id = 10;
  inline bool has_clip_id() const;
  inline void clear_clip_id();
  static const int kClipIdFieldNumber = 10;
  inline ::google::protobuf::int64 clip_id() const;
  inline void set_clip_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:cc.proto.EffectNodeData)
 private:
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_screen_space_opacity();
  inline void clear_has_screen_space_opacity();
  inline void set_has_has_render_surface();
  inline void clear_has_has_render_surface();
  inline void set_has_has_copy_request();
  inline void clear_has_has_copy_request();
  inline void set_has_has_background_filters();
  inline void clear_has_has_background_filters();
  inline void set_has_is_drawn();
  inline void clear_has_is_drawn();
  inline void set_has_has_animated_opacity();
  inline void clear_has_has_animated_opacity();
  inline void set_has_num_copy_requests_in_subtree();
  inline void clear_has_num_copy_requests_in_subtree();
  inline void set_has_transform_id();
  inline void clear_has_transform_id();
  inline void set_has_clip_id();
  inline void clear_has_clip_id();

  float opacity_;
  float screen_space_opacity_;
  bool has_render_surface_;
  bool has_copy_request_;
  bool has_background_filters_;
  bool is_drawn_;
  bool has_animated_opacity_;
  ::google::protobuf::int64 num_copy_requests_in_subtree_;
  ::google::protobuf::int64 transform_id_;
  ::google::protobuf::int64 clip_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
  #endif
  friend void protobuf_AssignDesc_property_5ftree_2eproto();
  friend void protobuf_ShutdownFile_property_5ftree_2eproto();

  void InitAsDefaultInstance();
  static EffectNodeData* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT ScrollNodeData : public ::google::protobuf::MessageLite {
 public:
  ScrollNodeData();
  virtual ~ScrollNodeData();

  ScrollNodeData(const ScrollNodeData& from);

  inline ScrollNodeData& operator=(const ScrollNodeData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ScrollNodeData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ScrollNodeData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ScrollNodeData* other);

  // implements Message ----------------------------------------------

  ScrollNodeData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ScrollNodeData& from);
  void MergeFrom(const ScrollNodeData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool scrollable = 1;
  inline bool has_scrollable() const;
  inline void clear_scrollable();
  static const int kScrollableFieldNumber = 1;
  inline bool scrollable() const;
  inline void set_scrollable(bool value);

  // optional int32 main_thread_scrolling_reasons = 2;
  inline bool has_main_thread_scrolling_reasons() const;
  inline void clear_main_thread_scrolling_reasons();
  static const int kMainThreadScrollingReasonsFieldNumber = 2;
  inline ::google::protobuf::int32 main_thread_scrolling_reasons() const;
  inline void set_main_thread_scrolling_reasons(::google::protobuf::int32 value);

  // optional bool contains_non_fast_scrollable_region = 3;
  inline bool has_contains_non_fast_scrollable_region() const;
  inline void clear_contains_non_fast_scrollable_region();
  static const int kContainsNonFastScrollableRegionFieldNumber = 3;
  inline bool contains_non_fast_scrollable_region() const;
  inline void set_contains_non_fast_scrollable_region(bool value);

  // optional int64 transform_id = 4;
  inline bool has_transform_id() const;
  inline void clear_transform_id();
  static const int kTransformIdFieldNumber = 4;
  inline ::google::protobuf::int64 transform_id() const;
  inline void set_transform_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:cc.proto.ScrollNodeData)
 private:
  inline void set_has_scrollable();
  inline void clear_has_scrollable();
  inline void set_has_main_thread_scrolling_reasons();
  inline void clear_has_main_thread_scrolling_reasons();
  inline void set_has_contains_non_fast_scrollable_region();
  inline void clear_has_contains_non_fast_scrollable_region();
  inline void set_has_transform_id();
  inline void clear_has_transform_id();

  ::google::protobuf::int32 main_thread_scrolling_reasons_;
  bool scrollable_;
  bool contains_non_fast_scrollable_region_;
  ::google::protobuf::int64 transform_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
  #endif
  friend void protobuf_AssignDesc_property_5ftree_2eproto();
  friend void protobuf_ShutdownFile_property_5ftree_2eproto();

  void InitAsDefaultInstance();
  static ScrollNodeData* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT TreeNode : public ::google::protobuf::MessageLite {
 public:
  TreeNode();
  virtual ~TreeNode();

  TreeNode(const TreeNode& from);

  inline TreeNode& operator=(const TreeNode& from) {
    CopyFrom(from);
    return *this;
  }

  static const TreeNode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TreeNode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TreeNode* other);

  // implements Message ----------------------------------------------

  TreeNode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TreeNode& from);
  void MergeFrom(const TreeNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // optional int64 parent_id = 2;
  inline bool has_parent_id() const;
  inline void clear_parent_id();
  static const int kParentIdFieldNumber = 2;
  inline ::google::protobuf::int64 parent_id() const;
  inline void set_parent_id(::google::protobuf::int64 value);

  // optional int64 owner_id = 3;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 3;
  inline ::google::protobuf::int64 owner_id() const;
  inline void set_owner_id(::google::protobuf::int64 value);

  // optional .cc.proto.TranformNodeData transform_node_data = 1000;
  inline bool has_transform_node_data() const;
  inline void clear_transform_node_data();
  static const int kTransformNodeDataFieldNumber = 1000;
  inline const ::cc::proto::TranformNodeData& transform_node_data() const;
  inline ::cc::proto::TranformNodeData* mutable_transform_node_data();
  inline ::cc::proto::TranformNodeData* release_transform_node_data();
  inline void set_allocated_transform_node_data(::cc::proto::TranformNodeData* transform_node_data);

  // optional .cc.proto.ClipNodeData clip_node_data = 1001;
  inline bool has_clip_node_data() const;
  inline void clear_clip_node_data();
  static const int kClipNodeDataFieldNumber = 1001;
  inline const ::cc::proto::ClipNodeData& clip_node_data() const;
  inline ::cc::proto::ClipNodeData* mutable_clip_node_data();
  inline ::cc::proto::ClipNodeData* release_clip_node_data();
  inline void set_allocated_clip_node_data(::cc::proto::ClipNodeData* clip_node_data);

  // optional .cc.proto.EffectNodeData effect_node_data = 1002;
  inline bool has_effect_node_data() const;
  inline void clear_effect_node_data();
  static const int kEffectNodeDataFieldNumber = 1002;
  inline const ::cc::proto::EffectNodeData& effect_node_data() const;
  inline ::cc::proto::EffectNodeData* mutable_effect_node_data();
  inline ::cc::proto::EffectNodeData* release_effect_node_data();
  inline void set_allocated_effect_node_data(::cc::proto::EffectNodeData* effect_node_data);

  // optional .cc.proto.ScrollNodeData scroll_node_data = 1003;
  inline bool has_scroll_node_data() const;
  inline void clear_scroll_node_data();
  static const int kScrollNodeDataFieldNumber = 1003;
  inline const ::cc::proto::ScrollNodeData& scroll_node_data() const;
  inline ::cc::proto::ScrollNodeData* mutable_scroll_node_data();
  inline ::cc::proto::ScrollNodeData* release_scroll_node_data();
  inline void set_allocated_scroll_node_data(::cc::proto::ScrollNodeData* scroll_node_data);

  // @@protoc_insertion_point(class_scope:cc.proto.TreeNode)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_parent_id();
  inline void clear_has_parent_id();
  inline void set_has_owner_id();
  inline void clear_has_owner_id();
  inline void set_has_transform_node_data();
  inline void clear_has_transform_node_data();
  inline void set_has_clip_node_data();
  inline void clear_has_clip_node_data();
  inline void set_has_effect_node_data();
  inline void clear_has_effect_node_data();
  inline void set_has_scroll_node_data();
  inline void clear_has_scroll_node_data();

  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 parent_id_;
  ::google::protobuf::int64 owner_id_;
  ::cc::proto::TranformNodeData* transform_node_data_;
  ::cc::proto::ClipNodeData* clip_node_data_;
  ::cc::proto::EffectNodeData* effect_node_data_;
  ::cc::proto::ScrollNodeData* scroll_node_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
  #endif
  friend void protobuf_AssignDesc_property_5ftree_2eproto();
  friend void protobuf_ShutdownFile_property_5ftree_2eproto();

  void InitAsDefaultInstance();
  static TreeNode* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT PropertyTree : public ::google::protobuf::MessageLite {
 public:
  PropertyTree();
  virtual ~PropertyTree();

  PropertyTree(const PropertyTree& from);

  inline PropertyTree& operator=(const PropertyTree& from) {
    CopyFrom(from);
    return *this;
  }

  static const PropertyTree& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PropertyTree* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PropertyTree* other);

  // implements Message ----------------------------------------------

  PropertyTree* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PropertyTree& from);
  void MergeFrom(const PropertyTree& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef PropertyTree_PropertyType PropertyType;
  static const PropertyType Transform = PropertyTree_PropertyType_Transform;
  static const PropertyType Clip = PropertyTree_PropertyType_Clip;
  static const PropertyType Effect = PropertyTree_PropertyType_Effect;
  static const PropertyType Scroll = PropertyTree_PropertyType_Scroll;
  static inline bool PropertyType_IsValid(int value) {
    return PropertyTree_PropertyType_IsValid(value);
  }
  static const PropertyType PropertyType_MIN =
    PropertyTree_PropertyType_PropertyType_MIN;
  static const PropertyType PropertyType_MAX =
    PropertyTree_PropertyType_PropertyType_MAX;
  static const int PropertyType_ARRAYSIZE =
    PropertyTree_PropertyType_PropertyType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .cc.proto.PropertyTree.PropertyType property_type = 1;
  inline bool has_property_type() const;
  inline void clear_property_type();
  static const int kPropertyTypeFieldNumber = 1;
  inline ::cc::proto::PropertyTree_PropertyType property_type() const;
  inline void set_property_type(::cc::proto::PropertyTree_PropertyType value);

  // repeated .cc.proto.TreeNode nodes = 2;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 2;
  inline const ::cc::proto::TreeNode& nodes(int index) const;
  inline ::cc::proto::TreeNode* mutable_nodes(int index);
  inline ::cc::proto::TreeNode* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::cc::proto::TreeNode >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::cc::proto::TreeNode >*
      mutable_nodes();

  // optional bool needs_update = 3;
  inline bool has_needs_update() const;
  inline void clear_needs_update();
  static const int kNeedsUpdateFieldNumber = 3;
  inline bool needs_update() const;
  inline void set_needs_update(bool value);

  // optional .cc.proto.TransformTreeData transform_tree_data = 1000;
  inline bool has_transform_tree_data() const;
  inline void clear_transform_tree_data();
  static const int kTransformTreeDataFieldNumber = 1000;
  inline const ::cc::proto::TransformTreeData& transform_tree_data() const;
  inline ::cc::proto::TransformTreeData* mutable_transform_tree_data();
  inline ::cc::proto::TransformTreeData* release_transform_tree_data();
  inline void set_allocated_transform_tree_data(::cc::proto::TransformTreeData* transform_tree_data);

  // @@protoc_insertion_point(class_scope:cc.proto.PropertyTree)
 private:
  inline void set_has_property_type();
  inline void clear_has_property_type();
  inline void set_has_needs_update();
  inline void clear_has_needs_update();
  inline void set_has_transform_tree_data();
  inline void clear_has_transform_tree_data();

  ::google::protobuf::RepeatedPtrField< ::cc::proto::TreeNode > nodes_;
  int property_type_;
  bool needs_update_;
  ::cc::proto::TransformTreeData* transform_tree_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
  #endif
  friend void protobuf_AssignDesc_property_5ftree_2eproto();
  friend void protobuf_ShutdownFile_property_5ftree_2eproto();

  void InitAsDefaultInstance();
  static PropertyTree* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT TransformTreeData : public ::google::protobuf::MessageLite {
 public:
  TransformTreeData();
  virtual ~TransformTreeData();

  TransformTreeData(const TransformTreeData& from);

  inline TransformTreeData& operator=(const TransformTreeData& from) {
    CopyFrom(from);
    return *this;
  }

  static const TransformTreeData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransformTreeData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransformTreeData* other);

  // implements Message ----------------------------------------------

  TransformTreeData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransformTreeData& from);
  void MergeFrom(const TransformTreeData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool source_to_parent_updates_allowed = 1;
  inline bool has_source_to_parent_updates_allowed() const;
  inline void clear_source_to_parent_updates_allowed();
  static const int kSourceToParentUpdatesAllowedFieldNumber = 1;
  inline bool source_to_parent_updates_allowed() const;
  inline void set_source_to_parent_updates_allowed(bool value);

  // optional float page_scale_factor = 2;
  inline bool has_page_scale_factor() const;
  inline void clear_page_scale_factor();
  static const int kPageScaleFactorFieldNumber = 2;
  inline float page_scale_factor() const;
  inline void set_page_scale_factor(float value);

  // optional float device_scale_factor = 3;
  inline bool has_device_scale_factor() const;
  inline void clear_device_scale_factor();
  static const int kDeviceScaleFactorFieldNumber = 3;
  inline float device_scale_factor() const;
  inline void set_device_scale_factor(float value);

  // optional float device_transform_scale_factor = 4;
  inline bool has_device_transform_scale_factor() const;
  inline void clear_device_transform_scale_factor();
  static const int kDeviceTransformScaleFactorFieldNumber = 4;
  inline float device_transform_scale_factor() const;
  inline void set_device_transform_scale_factor(float value);

  // optional .cc.proto.Vector2dF inner_viewport_bounds_delta = 5;
  inline bool has_inner_viewport_bounds_delta() const;
  inline void clear_inner_viewport_bounds_delta();
  static const int kInnerViewportBoundsDeltaFieldNumber = 5;
  inline const ::cc::proto::Vector2dF& inner_viewport_bounds_delta() const;
  inline ::cc::proto::Vector2dF* mutable_inner_viewport_bounds_delta();
  inline ::cc::proto::Vector2dF* release_inner_viewport_bounds_delta();
  inline void set_allocated_inner_viewport_bounds_delta(::cc::proto::Vector2dF* inner_viewport_bounds_delta);

  // optional .cc.proto.Vector2dF outer_viewport_bounds_delta = 6;
  inline bool has_outer_viewport_bounds_delta() const;
  inline void clear_outer_viewport_bounds_delta();
  static const int kOuterViewportBoundsDeltaFieldNumber = 6;
  inline const ::cc::proto::Vector2dF& outer_viewport_bounds_delta() const;
  inline ::cc::proto::Vector2dF* mutable_outer_viewport_bounds_delta();
  inline ::cc::proto::Vector2dF* release_outer_viewport_bounds_delta();
  inline void set_allocated_outer_viewport_bounds_delta(::cc::proto::Vector2dF* outer_viewport_bounds_delta);

  // repeated int64 nodes_affected_by_inner_viewport_bounds_delta = 7 [packed = true];
  inline int nodes_affected_by_inner_viewport_bounds_delta_size() const;
  inline void clear_nodes_affected_by_inner_viewport_bounds_delta();
  static const int kNodesAffectedByInnerViewportBoundsDeltaFieldNumber = 7;
  inline ::google::protobuf::int64 nodes_affected_by_inner_viewport_bounds_delta(int index) const;
  inline void set_nodes_affected_by_inner_viewport_bounds_delta(int index, ::google::protobuf::int64 value);
  inline void add_nodes_affected_by_inner_viewport_bounds_delta(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      nodes_affected_by_inner_viewport_bounds_delta() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_nodes_affected_by_inner_viewport_bounds_delta();

  // repeated int64 nodes_affected_by_outer_viewport_bounds_delta = 8 [packed = true];
  inline int nodes_affected_by_outer_viewport_bounds_delta_size() const;
  inline void clear_nodes_affected_by_outer_viewport_bounds_delta();
  static const int kNodesAffectedByOuterViewportBoundsDeltaFieldNumber = 8;
  inline ::google::protobuf::int64 nodes_affected_by_outer_viewport_bounds_delta(int index) const;
  inline void set_nodes_affected_by_outer_viewport_bounds_delta(int index, ::google::protobuf::int64 value);
  inline void add_nodes_affected_by_outer_viewport_bounds_delta(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      nodes_affected_by_outer_viewport_bounds_delta() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_nodes_affected_by_outer_viewport_bounds_delta();

  // @@protoc_insertion_point(class_scope:cc.proto.TransformTreeData)
 private:
  inline void set_has_source_to_parent_updates_allowed();
  inline void clear_has_source_to_parent_updates_allowed();
  inline void set_has_page_scale_factor();
  inline void clear_has_page_scale_factor();
  inline void set_has_device_scale_factor();
  inline void clear_has_device_scale_factor();
  inline void set_has_device_transform_scale_factor();
  inline void clear_has_device_transform_scale_factor();
  inline void set_has_inner_viewport_bounds_delta();
  inline void clear_has_inner_viewport_bounds_delta();
  inline void set_has_outer_viewport_bounds_delta();
  inline void clear_has_outer_viewport_bounds_delta();

  bool source_to_parent_updates_allowed_;
  float page_scale_factor_;
  float device_scale_factor_;
  float device_transform_scale_factor_;
  ::cc::proto::Vector2dF* inner_viewport_bounds_delta_;
  ::cc::proto::Vector2dF* outer_viewport_bounds_delta_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > nodes_affected_by_inner_viewport_bounds_delta_;
  mutable int _nodes_affected_by_inner_viewport_bounds_delta_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > nodes_affected_by_outer_viewport_bounds_delta_;
  mutable int _nodes_affected_by_outer_viewport_bounds_delta_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
  #endif
  friend void protobuf_AssignDesc_property_5ftree_2eproto();
  friend void protobuf_ShutdownFile_property_5ftree_2eproto();

  void InitAsDefaultInstance();
  static TransformTreeData* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT PropertyTrees : public ::google::protobuf::MessageLite {
 public:
  PropertyTrees();
  virtual ~PropertyTrees();

  PropertyTrees(const PropertyTrees& from);

  inline PropertyTrees& operator=(const PropertyTrees& from) {
    CopyFrom(from);
    return *this;
  }

  static const PropertyTrees& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PropertyTrees* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PropertyTrees* other);

  // implements Message ----------------------------------------------

  PropertyTrees* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PropertyTrees& from);
  void MergeFrom(const PropertyTrees& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cc.proto.PropertyTree transform_tree = 1;
  inline bool has_transform_tree() const;
  inline void clear_transform_tree();
  static const int kTransformTreeFieldNumber = 1;
  inline const ::cc::proto::PropertyTree& transform_tree() const;
  inline ::cc::proto::PropertyTree* mutable_transform_tree();
  inline ::cc::proto::PropertyTree* release_transform_tree();
  inline void set_allocated_transform_tree(::cc::proto::PropertyTree* transform_tree);

  // optional .cc.proto.PropertyTree effect_tree = 2;
  inline bool has_effect_tree() const;
  inline void clear_effect_tree();
  static const int kEffectTreeFieldNumber = 2;
  inline const ::cc::proto::PropertyTree& effect_tree() const;
  inline ::cc::proto::PropertyTree* mutable_effect_tree();
  inline ::cc::proto::PropertyTree* release_effect_tree();
  inline void set_allocated_effect_tree(::cc::proto::PropertyTree* effect_tree);

  // optional .cc.proto.PropertyTree clip_tree = 3;
  inline bool has_clip_tree() const;
  inline void clear_clip_tree();
  static const int kClipTreeFieldNumber = 3;
  inline const ::cc::proto::PropertyTree& clip_tree() const;
  inline ::cc::proto::PropertyTree* mutable_clip_tree();
  inline ::cc::proto::PropertyTree* release_clip_tree();
  inline void set_allocated_clip_tree(::cc::proto::PropertyTree* clip_tree);

  // optional .cc.proto.PropertyTree scroll_tree = 7;
  inline bool has_scroll_tree() const;
  inline void clear_scroll_tree();
  static const int kScrollTreeFieldNumber = 7;
  inline const ::cc::proto::PropertyTree& scroll_tree() const;
  inline ::cc::proto::PropertyTree* mutable_scroll_tree();
  inline ::cc::proto::PropertyTree* release_scroll_tree();
  inline void set_allocated_scroll_tree(::cc::proto::PropertyTree* scroll_tree);

  // optional bool needs_rebuild = 4;
  inline bool has_needs_rebuild() const;
  inline void clear_needs_rebuild();
  static const int kNeedsRebuildFieldNumber = 4;
  inline bool needs_rebuild() const;
  inline void set_needs_rebuild(bool value);

  // optional bool non_root_surfaces_enabled = 5;
  inline bool has_non_root_surfaces_enabled() const;
  inline void clear_non_root_surfaces_enabled();
  static const int kNonRootSurfacesEnabledFieldNumber = 5;
  inline bool non_root_surfaces_enabled() const;
  inline void set_non_root_surfaces_enabled(bool value);

  // optional int64 sequence_number = 6;
  inline bool has_sequence_number() const;
  inline void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 6;
  inline ::google::protobuf::int64 sequence_number() const;
  inline void set_sequence_number(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:cc.proto.PropertyTrees)
 private:
  inline void set_has_transform_tree();
  inline void clear_has_transform_tree();
  inline void set_has_effect_tree();
  inline void clear_has_effect_tree();
  inline void set_has_clip_tree();
  inline void clear_has_clip_tree();
  inline void set_has_scroll_tree();
  inline void clear_has_scroll_tree();
  inline void set_has_needs_rebuild();
  inline void clear_has_needs_rebuild();
  inline void set_has_non_root_surfaces_enabled();
  inline void clear_has_non_root_surfaces_enabled();
  inline void set_has_sequence_number();
  inline void clear_has_sequence_number();

  ::cc::proto::PropertyTree* transform_tree_;
  ::cc::proto::PropertyTree* effect_tree_;
  ::cc::proto::PropertyTree* clip_tree_;
  ::cc::proto::PropertyTree* scroll_tree_;
  ::google::protobuf::int64 sequence_number_;
  bool needs_rebuild_;
  bool non_root_surfaces_enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
  #else
  friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
  #endif
  friend void protobuf_AssignDesc_property_5ftree_2eproto();
  friend void protobuf_ShutdownFile_property_5ftree_2eproto();

  void InitAsDefaultInstance();
  static PropertyTrees* default_instance_;
};
// ===================================================================


// ===================================================================

// TranformNodeData

// optional .cc.proto.Transform pre_local = 1;
inline bool TranformNodeData::has_pre_local() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TranformNodeData::set_has_pre_local() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TranformNodeData::clear_has_pre_local() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TranformNodeData::clear_pre_local() {
  if (pre_local_ != NULL) pre_local_->::cc::proto::Transform::Clear();
  clear_has_pre_local();
}
inline const ::cc::proto::Transform& TranformNodeData::pre_local() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return pre_local_ != NULL ? *pre_local_ : *default_instance().pre_local_;
#else
  return pre_local_ != NULL ? *pre_local_ : *default_instance_->pre_local_;
#endif
}
inline ::cc::proto::Transform* TranformNodeData::mutable_pre_local() {
  set_has_pre_local();
  if (pre_local_ == NULL) pre_local_ = new ::cc::proto::Transform;
  return pre_local_;
}
inline ::cc::proto::Transform* TranformNodeData::release_pre_local() {
  clear_has_pre_local();
  ::cc::proto::Transform* temp = pre_local_;
  pre_local_ = NULL;
  return temp;
}
inline void TranformNodeData::set_allocated_pre_local(::cc::proto::Transform* pre_local) {
  delete pre_local_;
  pre_local_ = pre_local;
  if (pre_local) {
    set_has_pre_local();
  } else {
    clear_has_pre_local();
  }
}

// optional .cc.proto.Transform local = 2;
inline bool TranformNodeData::has_local() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TranformNodeData::set_has_local() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TranformNodeData::clear_has_local() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TranformNodeData::clear_local() {
  if (local_ != NULL) local_->::cc::proto::Transform::Clear();
  clear_has_local();
}
inline const ::cc::proto::Transform& TranformNodeData::local() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return local_ != NULL ? *local_ : *default_instance().local_;
#else
  return local_ != NULL ? *local_ : *default_instance_->local_;
#endif
}
inline ::cc::proto::Transform* TranformNodeData::mutable_local() {
  set_has_local();
  if (local_ == NULL) local_ = new ::cc::proto::Transform;
  return local_;
}
inline ::cc::proto::Transform* TranformNodeData::release_local() {
  clear_has_local();
  ::cc::proto::Transform* temp = local_;
  local_ = NULL;
  return temp;
}
inline void TranformNodeData::set_allocated_local(::cc::proto::Transform* local) {
  delete local_;
  local_ = local;
  if (local) {
    set_has_local();
  } else {
    clear_has_local();
  }
}

// optional .cc.proto.Transform post_local = 3;
inline bool TranformNodeData::has_post_local() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TranformNodeData::set_has_post_local() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TranformNodeData::clear_has_post_local() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TranformNodeData::clear_post_local() {
  if (post_local_ != NULL) post_local_->::cc::proto::Transform::Clear();
  clear_has_post_local();
}
inline const ::cc::proto::Transform& TranformNodeData::post_local() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return post_local_ != NULL ? *post_local_ : *default_instance().post_local_;
#else
  return post_local_ != NULL ? *post_local_ : *default_instance_->post_local_;
#endif
}
inline ::cc::proto::Transform* TranformNodeData::mutable_post_local() {
  set_has_post_local();
  if (post_local_ == NULL) post_local_ = new ::cc::proto::Transform;
  return post_local_;
}
inline ::cc::proto::Transform* TranformNodeData::release_post_local() {
  clear_has_post_local();
  ::cc::proto::Transform* temp = post_local_;
  post_local_ = NULL;
  return temp;
}
inline void TranformNodeData::set_allocated_post_local(::cc::proto::Transform* post_local) {
  delete post_local_;
  post_local_ = post_local;
  if (post_local) {
    set_has_post_local();
  } else {
    clear_has_post_local();
  }
}

// optional .cc.proto.Transform to_parent = 4;
inline bool TranformNodeData::has_to_parent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TranformNodeData::set_has_to_parent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TranformNodeData::clear_has_to_parent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TranformNodeData::clear_to_parent() {
  if (to_parent_ != NULL) to_parent_->::cc::proto::Transform::Clear();
  clear_has_to_parent();
}
inline const ::cc::proto::Transform& TranformNodeData::to_parent() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return to_parent_ != NULL ? *to_parent_ : *default_instance().to_parent_;
#else
  return to_parent_ != NULL ? *to_parent_ : *default_instance_->to_parent_;
#endif
}
inline ::cc::proto::Transform* TranformNodeData::mutable_to_parent() {
  set_has_to_parent();
  if (to_parent_ == NULL) to_parent_ = new ::cc::proto::Transform;
  return to_parent_;
}
inline ::cc::proto::Transform* TranformNodeData::release_to_parent() {
  clear_has_to_parent();
  ::cc::proto::Transform* temp = to_parent_;
  to_parent_ = NULL;
  return temp;
}
inline void TranformNodeData::set_allocated_to_parent(::cc::proto::Transform* to_parent) {
  delete to_parent_;
  to_parent_ = to_parent;
  if (to_parent) {
    set_has_to_parent();
  } else {
    clear_has_to_parent();
  }
}

// optional .cc.proto.Transform to_target = 5;
inline bool TranformNodeData::has_to_target() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TranformNodeData::set_has_to_target() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TranformNodeData::clear_has_to_target() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TranformNodeData::clear_to_target() {
  if (to_target_ != NULL) to_target_->::cc::proto::Transform::Clear();
  clear_has_to_target();
}
inline const ::cc::proto::Transform& TranformNodeData::to_target() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return to_target_ != NULL ? *to_target_ : *default_instance().to_target_;
#else
  return to_target_ != NULL ? *to_target_ : *default_instance_->to_target_;
#endif
}
inline ::cc::proto::Transform* TranformNodeData::mutable_to_target() {
  set_has_to_target();
  if (to_target_ == NULL) to_target_ = new ::cc::proto::Transform;
  return to_target_;
}
inline ::cc::proto::Transform* TranformNodeData::release_to_target() {
  clear_has_to_target();
  ::cc::proto::Transform* temp = to_target_;
  to_target_ = NULL;
  return temp;
}
inline void TranformNodeData::set_allocated_to_target(::cc::proto::Transform* to_target) {
  delete to_target_;
  to_target_ = to_target;
  if (to_target) {
    set_has_to_target();
  } else {
    clear_has_to_target();
  }
}

// optional .cc.proto.Transform from_target = 6;
inline bool TranformNodeData::has_from_target() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TranformNodeData::set_has_from_target() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TranformNodeData::clear_has_from_target() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TranformNodeData::clear_from_target() {
  if (from_target_ != NULL) from_target_->::cc::proto::Transform::Clear();
  clear_has_from_target();
}
inline const ::cc::proto::Transform& TranformNodeData::from_target() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return from_target_ != NULL ? *from_target_ : *default_instance().from_target_;
#else
  return from_target_ != NULL ? *from_target_ : *default_instance_->from_target_;
#endif
}
inline ::cc::proto::Transform* TranformNodeData::mutable_from_target() {
  set_has_from_target();
  if (from_target_ == NULL) from_target_ = new ::cc::proto::Transform;
  return from_target_;
}
inline ::cc::proto::Transform* TranformNodeData::release_from_target() {
  clear_has_from_target();
  ::cc::proto::Transform* temp = from_target_;
  from_target_ = NULL;
  return temp;
}
inline void TranformNodeData::set_allocated_from_target(::cc::proto::Transform* from_target) {
  delete from_target_;
  from_target_ = from_target;
  if (from_target) {
    set_has_from_target();
  } else {
    clear_has_from_target();
  }
}

// optional .cc.proto.Transform to_screen = 7;
inline bool TranformNodeData::has_to_screen() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TranformNodeData::set_has_to_screen() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TranformNodeData::clear_has_to_screen() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TranformNodeData::clear_to_screen() {
  if (to_screen_ != NULL) to_screen_->::cc::proto::Transform::Clear();
  clear_has_to_screen();
}
inline const ::cc::proto::Transform& TranformNodeData::to_screen() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return to_screen_ != NULL ? *to_screen_ : *default_instance().to_screen_;
#else
  return to_screen_ != NULL ? *to_screen_ : *default_instance_->to_screen_;
#endif
}
inline ::cc::proto::Transform* TranformNodeData::mutable_to_screen() {
  set_has_to_screen();
  if (to_screen_ == NULL) to_screen_ = new ::cc::proto::Transform;
  return to_screen_;
}
inline ::cc::proto::Transform* TranformNodeData::release_to_screen() {
  clear_has_to_screen();
  ::cc::proto::Transform* temp = to_screen_;
  to_screen_ = NULL;
  return temp;
}
inline void TranformNodeData::set_allocated_to_screen(::cc::proto::Transform* to_screen) {
  delete to_screen_;
  to_screen_ = to_screen;
  if (to_screen) {
    set_has_to_screen();
  } else {
    clear_has_to_screen();
  }
}

// optional .cc.proto.Transform from_screen = 8;
inline bool TranformNodeData::has_from_screen() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TranformNodeData::set_has_from_screen() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TranformNodeData::clear_has_from_screen() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TranformNodeData::clear_from_screen() {
  if (from_screen_ != NULL) from_screen_->::cc::proto::Transform::Clear();
  clear_has_from_screen();
}
inline const ::cc::proto::Transform& TranformNodeData::from_screen() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return from_screen_ != NULL ? *from_screen_ : *default_instance().from_screen_;
#else
  return from_screen_ != NULL ? *from_screen_ : *default_instance_->from_screen_;
#endif
}
inline ::cc::proto::Transform* TranformNodeData::mutable_from_screen() {
  set_has_from_screen();
  if (from_screen_ == NULL) from_screen_ = new ::cc::proto::Transform;
  return from_screen_;
}
inline ::cc::proto::Transform* TranformNodeData::release_from_screen() {
  clear_has_from_screen();
  ::cc::proto::Transform* temp = from_screen_;
  from_screen_ = NULL;
  return temp;
}
inline void TranformNodeData::set_allocated_from_screen(::cc::proto::Transform* from_screen) {
  delete from_screen_;
  from_screen_ = from_screen;
  if (from_screen) {
    set_has_from_screen();
  } else {
    clear_has_from_screen();
  }
}

// optional int64 target_id = 9;
inline bool TranformNodeData::has_target_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TranformNodeData::set_has_target_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TranformNodeData::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TranformNodeData::clear_target_id() {
  target_id_ = GOOGLE_LONGLONG(0);
  clear_has_target_id();
}
inline ::google::protobuf::int64 TranformNodeData::target_id() const {
  return target_id_;
}
inline void TranformNodeData::set_target_id(::google::protobuf::int64 value) {
  set_has_target_id();
  target_id_ = value;
}

// optional int64 content_target_id = 10;
inline bool TranformNodeData::has_content_target_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TranformNodeData::set_has_content_target_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TranformNodeData::clear_has_content_target_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TranformNodeData::clear_content_target_id() {
  content_target_id_ = GOOGLE_LONGLONG(0);
  clear_has_content_target_id();
}
inline ::google::protobuf::int64 TranformNodeData::content_target_id() const {
  return content_target_id_;
}
inline void TranformNodeData::set_content_target_id(::google::protobuf::int64 value) {
  set_has_content_target_id();
  content_target_id_ = value;
}

// optional int64 source_node_id = 11;
inline bool TranformNodeData::has_source_node_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TranformNodeData::set_has_source_node_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TranformNodeData::clear_has_source_node_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TranformNodeData::clear_source_node_id() {
  source_node_id_ = GOOGLE_LONGLONG(0);
  clear_has_source_node_id();
}
inline ::google::protobuf::int64 TranformNodeData::source_node_id() const {
  return source_node_id_;
}
inline void TranformNodeData::set_source_node_id(::google::protobuf::int64 value) {
  set_has_source_node_id();
  source_node_id_ = value;
}

// optional bool needs_local_transform_update = 12;
inline bool TranformNodeData::has_needs_local_transform_update() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TranformNodeData::set_has_needs_local_transform_update() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TranformNodeData::clear_has_needs_local_transform_update() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TranformNodeData::clear_needs_local_transform_update() {
  needs_local_transform_update_ = false;
  clear_has_needs_local_transform_update();
}
inline bool TranformNodeData::needs_local_transform_update() const {
  return needs_local_transform_update_;
}
inline void TranformNodeData::set_needs_local_transform_update(bool value) {
  set_has_needs_local_transform_update();
  needs_local_transform_update_ = value;
}

// optional bool is_invertible = 13;
inline bool TranformNodeData::has_is_invertible() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TranformNodeData::set_has_is_invertible() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TranformNodeData::clear_has_is_invertible() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TranformNodeData::clear_is_invertible() {
  is_invertible_ = false;
  clear_has_is_invertible();
}
inline bool TranformNodeData::is_invertible() const {
  return is_invertible_;
}
inline void TranformNodeData::set_is_invertible(bool value) {
  set_has_is_invertible();
  is_invertible_ = value;
}

// optional bool ancestors_are_invertible = 14;
inline bool TranformNodeData::has_ancestors_are_invertible() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TranformNodeData::set_has_ancestors_are_invertible() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TranformNodeData::clear_has_ancestors_are_invertible() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TranformNodeData::clear_ancestors_are_invertible() {
  ancestors_are_invertible_ = false;
  clear_has_ancestors_are_invertible();
}
inline bool TranformNodeData::ancestors_are_invertible() const {
  return ancestors_are_invertible_;
}
inline void TranformNodeData::set_ancestors_are_invertible(bool value) {
  set_has_ancestors_are_invertible();
  ancestors_are_invertible_ = value;
}

// optional bool is_animated = 15;
inline bool TranformNodeData::has_is_animated() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TranformNodeData::set_has_is_animated() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TranformNodeData::clear_has_is_animated() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TranformNodeData::clear_is_animated() {
  is_animated_ = false;
  clear_has_is_animated();
}
inline bool TranformNodeData::is_animated() const {
  return is_animated_;
}
inline void TranformNodeData::set_is_animated(bool value) {
  set_has_is_animated();
  is_animated_ = value;
}

// optional bool to_screen_is_animated = 16;
inline bool TranformNodeData::has_to_screen_is_animated() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TranformNodeData::set_has_to_screen_is_animated() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TranformNodeData::clear_has_to_screen_is_animated() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TranformNodeData::clear_to_screen_is_animated() {
  to_screen_is_animated_ = false;
  clear_has_to_screen_is_animated();
}
inline bool TranformNodeData::to_screen_is_animated() const {
  return to_screen_is_animated_;
}
inline void TranformNodeData::set_to_screen_is_animated(bool value) {
  set_has_to_screen_is_animated();
  to_screen_is_animated_ = value;
}

// optional bool has_only_translation_animations = 17;
inline bool TranformNodeData::has_has_only_translation_animations() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TranformNodeData::set_has_has_only_translation_animations() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TranformNodeData::clear_has_has_only_translation_animations() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TranformNodeData::clear_has_only_translation_animations() {
  has_only_translation_animations_ = false;
  clear_has_has_only_translation_animations();
}
inline bool TranformNodeData::has_only_translation_animations() const {
  return has_only_translation_animations_;
}
inline void TranformNodeData::set_has_only_translation_animations(bool value) {
  set_has_has_only_translation_animations();
  has_only_translation_animations_ = value;
}

// optional bool to_screen_has_scale_animation = 18;
inline bool TranformNodeData::has_to_screen_has_scale_animation() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TranformNodeData::set_has_to_screen_has_scale_animation() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TranformNodeData::clear_has_to_screen_has_scale_animation() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TranformNodeData::clear_to_screen_has_scale_animation() {
  to_screen_has_scale_animation_ = false;
  clear_has_to_screen_has_scale_animation();
}
inline bool TranformNodeData::to_screen_has_scale_animation() const {
  return to_screen_has_scale_animation_;
}
inline void TranformNodeData::set_to_screen_has_scale_animation(bool value) {
  set_has_to_screen_has_scale_animation();
  to_screen_has_scale_animation_ = value;
}

// optional bool flattens_inherited_transform = 19;
inline bool TranformNodeData::has_flattens_inherited_transform() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TranformNodeData::set_has_flattens_inherited_transform() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TranformNodeData::clear_has_flattens_inherited_transform() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TranformNodeData::clear_flattens_inherited_transform() {
  flattens_inherited_transform_ = false;
  clear_has_flattens_inherited_transform();
}
inline bool TranformNodeData::flattens_inherited_transform() const {
  return flattens_inherited_transform_;
}
inline void TranformNodeData::set_flattens_inherited_transform(bool value) {
  set_has_flattens_inherited_transform();
  flattens_inherited_transform_ = value;
}

// optional bool node_and_ancestors_are_flat = 20;
inline bool TranformNodeData::has_node_and_ancestors_are_flat() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TranformNodeData::set_has_node_and_ancestors_are_flat() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TranformNodeData::clear_has_node_and_ancestors_are_flat() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TranformNodeData::clear_node_and_ancestors_are_flat() {
  node_and_ancestors_are_flat_ = false;
  clear_has_node_and_ancestors_are_flat();
}
inline bool TranformNodeData::node_and_ancestors_are_flat() const {
  return node_and_ancestors_are_flat_;
}
inline void TranformNodeData::set_node_and_ancestors_are_flat(bool value) {
  set_has_node_and_ancestors_are_flat();
  node_and_ancestors_are_flat_ = value;
}

// optional bool node_and_ancestors_have_only_integer_translation = 21;
inline bool TranformNodeData::has_node_and_ancestors_have_only_integer_translation() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TranformNodeData::set_has_node_and_ancestors_have_only_integer_translation() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TranformNodeData::clear_has_node_and_ancestors_have_only_integer_translation() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TranformNodeData::clear_node_and_ancestors_have_only_integer_translation() {
  node_and_ancestors_have_only_integer_translation_ = false;
  clear_has_node_and_ancestors_have_only_integer_translation();
}
inline bool TranformNodeData::node_and_ancestors_have_only_integer_translation() const {
  return node_and_ancestors_have_only_integer_translation_;
}
inline void TranformNodeData::set_node_and_ancestors_have_only_integer_translation(bool value) {
  set_has_node_and_ancestors_have_only_integer_translation();
  node_and_ancestors_have_only_integer_translation_ = value;
}

// optional bool scrolls = 22;
inline bool TranformNodeData::has_scrolls() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TranformNodeData::set_has_scrolls() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TranformNodeData::clear_has_scrolls() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TranformNodeData::clear_scrolls() {
  scrolls_ = false;
  clear_has_scrolls();
}
inline bool TranformNodeData::scrolls() const {
  return scrolls_;
}
inline void TranformNodeData::set_scrolls(bool value) {
  set_has_scrolls();
  scrolls_ = value;
}

// optional bool needs_sublayer_scale = 23;
inline bool TranformNodeData::has_needs_sublayer_scale() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TranformNodeData::set_has_needs_sublayer_scale() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TranformNodeData::clear_has_needs_sublayer_scale() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TranformNodeData::clear_needs_sublayer_scale() {
  needs_sublayer_scale_ = false;
  clear_has_needs_sublayer_scale();
}
inline bool TranformNodeData::needs_sublayer_scale() const {
  return needs_sublayer_scale_;
}
inline void TranformNodeData::set_needs_sublayer_scale(bool value) {
  set_has_needs_sublayer_scale();
  needs_sublayer_scale_ = value;
}

// optional bool affected_by_inner_viewport_bounds_delta_x = 24;
inline bool TranformNodeData::has_affected_by_inner_viewport_bounds_delta_x() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TranformNodeData::set_has_affected_by_inner_viewport_bounds_delta_x() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TranformNodeData::clear_has_affected_by_inner_viewport_bounds_delta_x() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TranformNodeData::clear_affected_by_inner_viewport_bounds_delta_x() {
  affected_by_inner_viewport_bounds_delta_x_ = false;
  clear_has_affected_by_inner_viewport_bounds_delta_x();
}
inline bool TranformNodeData::affected_by_inner_viewport_bounds_delta_x() const {
  return affected_by_inner_viewport_bounds_delta_x_;
}
inline void TranformNodeData::set_affected_by_inner_viewport_bounds_delta_x(bool value) {
  set_has_affected_by_inner_viewport_bounds_delta_x();
  affected_by_inner_viewport_bounds_delta_x_ = value;
}

// optional bool affected_by_inner_viewport_bounds_delta_y = 25;
inline bool TranformNodeData::has_affected_by_inner_viewport_bounds_delta_y() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TranformNodeData::set_has_affected_by_inner_viewport_bounds_delta_y() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TranformNodeData::clear_has_affected_by_inner_viewport_bounds_delta_y() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TranformNodeData::clear_affected_by_inner_viewport_bounds_delta_y() {
  affected_by_inner_viewport_bounds_delta_y_ = false;
  clear_has_affected_by_inner_viewport_bounds_delta_y();
}
inline bool TranformNodeData::affected_by_inner_viewport_bounds_delta_y() const {
  return affected_by_inner_viewport_bounds_delta_y_;
}
inline void TranformNodeData::set_affected_by_inner_viewport_bounds_delta_y(bool value) {
  set_has_affected_by_inner_viewport_bounds_delta_y();
  affected_by_inner_viewport_bounds_delta_y_ = value;
}

// optional bool affected_by_outer_viewport_bounds_delta_x = 26;
inline bool TranformNodeData::has_affected_by_outer_viewport_bounds_delta_x() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TranformNodeData::set_has_affected_by_outer_viewport_bounds_delta_x() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TranformNodeData::clear_has_affected_by_outer_viewport_bounds_delta_x() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TranformNodeData::clear_affected_by_outer_viewport_bounds_delta_x() {
  affected_by_outer_viewport_bounds_delta_x_ = false;
  clear_has_affected_by_outer_viewport_bounds_delta_x();
}
inline bool TranformNodeData::affected_by_outer_viewport_bounds_delta_x() const {
  return affected_by_outer_viewport_bounds_delta_x_;
}
inline void TranformNodeData::set_affected_by_outer_viewport_bounds_delta_x(bool value) {
  set_has_affected_by_outer_viewport_bounds_delta_x();
  affected_by_outer_viewport_bounds_delta_x_ = value;
}

// optional bool affected_by_outer_viewport_bounds_delta_y = 27;
inline bool TranformNodeData::has_affected_by_outer_viewport_bounds_delta_y() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TranformNodeData::set_has_affected_by_outer_viewport_bounds_delta_y() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TranformNodeData::clear_has_affected_by_outer_viewport_bounds_delta_y() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TranformNodeData::clear_affected_by_outer_viewport_bounds_delta_y() {
  affected_by_outer_viewport_bounds_delta_y_ = false;
  clear_has_affected_by_outer_viewport_bounds_delta_y();
}
inline bool TranformNodeData::affected_by_outer_viewport_bounds_delta_y() const {
  return affected_by_outer_viewport_bounds_delta_y_;
}
inline void TranformNodeData::set_affected_by_outer_viewport_bounds_delta_y(bool value) {
  set_has_affected_by_outer_viewport_bounds_delta_y();
  affected_by_outer_viewport_bounds_delta_y_ = value;
}

// optional bool in_subtree_of_page_scale_layer = 28;
inline bool TranformNodeData::has_in_subtree_of_page_scale_layer() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TranformNodeData::set_has_in_subtree_of_page_scale_layer() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TranformNodeData::clear_has_in_subtree_of_page_scale_layer() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TranformNodeData::clear_in_subtree_of_page_scale_layer() {
  in_subtree_of_page_scale_layer_ = false;
  clear_has_in_subtree_of_page_scale_layer();
}
inline bool TranformNodeData::in_subtree_of_page_scale_layer() const {
  return in_subtree_of_page_scale_layer_;
}
inline void TranformNodeData::set_in_subtree_of_page_scale_layer(bool value) {
  set_has_in_subtree_of_page_scale_layer();
  in_subtree_of_page_scale_layer_ = value;
}

// optional float post_local_scale_factor = 29;
inline bool TranformNodeData::has_post_local_scale_factor() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TranformNodeData::set_has_post_local_scale_factor() {
  _has_bits_[0] |= 0x10000000u;
}
inline void TranformNodeData::clear_has_post_local_scale_factor() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void TranformNodeData::clear_post_local_scale_factor() {
  post_local_scale_factor_ = 0;
  clear_has_post_local_scale_factor();
}
inline float TranformNodeData::post_local_scale_factor() const {
  return post_local_scale_factor_;
}
inline void TranformNodeData::set_post_local_scale_factor(float value) {
  set_has_post_local_scale_factor();
  post_local_scale_factor_ = value;
}

// optional float local_maximum_animation_target_scale = 30;
inline bool TranformNodeData::has_local_maximum_animation_target_scale() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TranformNodeData::set_has_local_maximum_animation_target_scale() {
  _has_bits_[0] |= 0x20000000u;
}
inline void TranformNodeData::clear_has_local_maximum_animation_target_scale() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void TranformNodeData::clear_local_maximum_animation_target_scale() {
  local_maximum_animation_target_scale_ = 0;
  clear_has_local_maximum_animation_target_scale();
}
inline float TranformNodeData::local_maximum_animation_target_scale() const {
  return local_maximum_animation_target_scale_;
}
inline void TranformNodeData::set_local_maximum_animation_target_scale(float value) {
  set_has_local_maximum_animation_target_scale();
  local_maximum_animation_target_scale_ = value;
}

// optional float local_starting_animation_scale = 31;
inline bool TranformNodeData::has_local_starting_animation_scale() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void TranformNodeData::set_has_local_starting_animation_scale() {
  _has_bits_[0] |= 0x40000000u;
}
inline void TranformNodeData::clear_has_local_starting_animation_scale() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void TranformNodeData::clear_local_starting_animation_scale() {
  local_starting_animation_scale_ = 0;
  clear_has_local_starting_animation_scale();
}
inline float TranformNodeData::local_starting_animation_scale() const {
  return local_starting_animation_scale_;
}
inline void TranformNodeData::set_local_starting_animation_scale(float value) {
  set_has_local_starting_animation_scale();
  local_starting_animation_scale_ = value;
}

// optional float combined_maximum_animation_target_scale = 32;
inline bool TranformNodeData::has_combined_maximum_animation_target_scale() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void TranformNodeData::set_has_combined_maximum_animation_target_scale() {
  _has_bits_[0] |= 0x80000000u;
}
inline void TranformNodeData::clear_has_combined_maximum_animation_target_scale() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void TranformNodeData::clear_combined_maximum_animation_target_scale() {
  combined_maximum_animation_target_scale_ = 0;
  clear_has_combined_maximum_animation_target_scale();
}
inline float TranformNodeData::combined_maximum_animation_target_scale() const {
  return combined_maximum_animation_target_scale_;
}
inline void TranformNodeData::set_combined_maximum_animation_target_scale(float value) {
  set_has_combined_maximum_animation_target_scale();
  combined_maximum_animation_target_scale_ = value;
}

// optional float combined_starting_animation_scale = 33;
inline bool TranformNodeData::has_combined_starting_animation_scale() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void TranformNodeData::set_has_combined_starting_animation_scale() {
  _has_bits_[1] |= 0x00000001u;
}
inline void TranformNodeData::clear_has_combined_starting_animation_scale() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void TranformNodeData::clear_combined_starting_animation_scale() {
  combined_starting_animation_scale_ = 0;
  clear_has_combined_starting_animation_scale();
}
inline float TranformNodeData::combined_starting_animation_scale() const {
  return combined_starting_animation_scale_;
}
inline void TranformNodeData::set_combined_starting_animation_scale(float value) {
  set_has_combined_starting_animation_scale();
  combined_starting_animation_scale_ = value;
}

// optional .cc.proto.Vector2dF sublayer_scale = 34;
inline bool TranformNodeData::has_sublayer_scale() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void TranformNodeData::set_has_sublayer_scale() {
  _has_bits_[1] |= 0x00000002u;
}
inline void TranformNodeData::clear_has_sublayer_scale() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void TranformNodeData::clear_sublayer_scale() {
  if (sublayer_scale_ != NULL) sublayer_scale_->::cc::proto::Vector2dF::Clear();
  clear_has_sublayer_scale();
}
inline const ::cc::proto::Vector2dF& TranformNodeData::sublayer_scale() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sublayer_scale_ != NULL ? *sublayer_scale_ : *default_instance().sublayer_scale_;
#else
  return sublayer_scale_ != NULL ? *sublayer_scale_ : *default_instance_->sublayer_scale_;
#endif
}
inline ::cc::proto::Vector2dF* TranformNodeData::mutable_sublayer_scale() {
  set_has_sublayer_scale();
  if (sublayer_scale_ == NULL) sublayer_scale_ = new ::cc::proto::Vector2dF;
  return sublayer_scale_;
}
inline ::cc::proto::Vector2dF* TranformNodeData::release_sublayer_scale() {
  clear_has_sublayer_scale();
  ::cc::proto::Vector2dF* temp = sublayer_scale_;
  sublayer_scale_ = NULL;
  return temp;
}
inline void TranformNodeData::set_allocated_sublayer_scale(::cc::proto::Vector2dF* sublayer_scale) {
  delete sublayer_scale_;
  sublayer_scale_ = sublayer_scale;
  if (sublayer_scale) {
    set_has_sublayer_scale();
  } else {
    clear_has_sublayer_scale();
  }
}

// optional .cc.proto.ScrollOffset scroll_offset = 35;
inline bool TranformNodeData::has_scroll_offset() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void TranformNodeData::set_has_scroll_offset() {
  _has_bits_[1] |= 0x00000004u;
}
inline void TranformNodeData::clear_has_scroll_offset() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void TranformNodeData::clear_scroll_offset() {
  if (scroll_offset_ != NULL) scroll_offset_->::cc::proto::ScrollOffset::Clear();
  clear_has_scroll_offset();
}
inline const ::cc::proto::ScrollOffset& TranformNodeData::scroll_offset() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scroll_offset_ != NULL ? *scroll_offset_ : *default_instance().scroll_offset_;
#else
  return scroll_offset_ != NULL ? *scroll_offset_ : *default_instance_->scroll_offset_;
#endif
}
inline ::cc::proto::ScrollOffset* TranformNodeData::mutable_scroll_offset() {
  set_has_scroll_offset();
  if (scroll_offset_ == NULL) scroll_offset_ = new ::cc::proto::ScrollOffset;
  return scroll_offset_;
}
inline ::cc::proto::ScrollOffset* TranformNodeData::release_scroll_offset() {
  clear_has_scroll_offset();
  ::cc::proto::ScrollOffset* temp = scroll_offset_;
  scroll_offset_ = NULL;
  return temp;
}
inline void TranformNodeData::set_allocated_scroll_offset(::cc::proto::ScrollOffset* scroll_offset) {
  delete scroll_offset_;
  scroll_offset_ = scroll_offset;
  if (scroll_offset) {
    set_has_scroll_offset();
  } else {
    clear_has_scroll_offset();
  }
}

// optional .cc.proto.Vector2dF scroll_snap = 36;
inline bool TranformNodeData::has_scroll_snap() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void TranformNodeData::set_has_scroll_snap() {
  _has_bits_[1] |= 0x00000008u;
}
inline void TranformNodeData::clear_has_scroll_snap() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void TranformNodeData::clear_scroll_snap() {
  if (scroll_snap_ != NULL) scroll_snap_->::cc::proto::Vector2dF::Clear();
  clear_has_scroll_snap();
}
inline const ::cc::proto::Vector2dF& TranformNodeData::scroll_snap() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scroll_snap_ != NULL ? *scroll_snap_ : *default_instance().scroll_snap_;
#else
  return scroll_snap_ != NULL ? *scroll_snap_ : *default_instance_->scroll_snap_;
#endif
}
inline ::cc::proto::Vector2dF* TranformNodeData::mutable_scroll_snap() {
  set_has_scroll_snap();
  if (scroll_snap_ == NULL) scroll_snap_ = new ::cc::proto::Vector2dF;
  return scroll_snap_;
}
inline ::cc::proto::Vector2dF* TranformNodeData::release_scroll_snap() {
  clear_has_scroll_snap();
  ::cc::proto::Vector2dF* temp = scroll_snap_;
  scroll_snap_ = NULL;
  return temp;
}
inline void TranformNodeData::set_allocated_scroll_snap(::cc::proto::Vector2dF* scroll_snap) {
  delete scroll_snap_;
  scroll_snap_ = scroll_snap;
  if (scroll_snap) {
    set_has_scroll_snap();
  } else {
    clear_has_scroll_snap();
  }
}

// optional .cc.proto.Vector2dF source_offset = 37;
inline bool TranformNodeData::has_source_offset() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void TranformNodeData::set_has_source_offset() {
  _has_bits_[1] |= 0x00000010u;
}
inline void TranformNodeData::clear_has_source_offset() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void TranformNodeData::clear_source_offset() {
  if (source_offset_ != NULL) source_offset_->::cc::proto::Vector2dF::Clear();
  clear_has_source_offset();
}
inline const ::cc::proto::Vector2dF& TranformNodeData::source_offset() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_offset_ != NULL ? *source_offset_ : *default_instance().source_offset_;
#else
  return source_offset_ != NULL ? *source_offset_ : *default_instance_->source_offset_;
#endif
}
inline ::cc::proto::Vector2dF* TranformNodeData::mutable_source_offset() {
  set_has_source_offset();
  if (source_offset_ == NULL) source_offset_ = new ::cc::proto::Vector2dF;
  return source_offset_;
}
inline ::cc::proto::Vector2dF* TranformNodeData::release_source_offset() {
  clear_has_source_offset();
  ::cc::proto::Vector2dF* temp = source_offset_;
  source_offset_ = NULL;
  return temp;
}
inline void TranformNodeData::set_allocated_source_offset(::cc::proto::Vector2dF* source_offset) {
  delete source_offset_;
  source_offset_ = source_offset;
  if (source_offset) {
    set_has_source_offset();
  } else {
    clear_has_source_offset();
  }
}

// optional .cc.proto.Vector2dF source_to_parent = 38;
inline bool TranformNodeData::has_source_to_parent() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void TranformNodeData::set_has_source_to_parent() {
  _has_bits_[1] |= 0x00000020u;
}
inline void TranformNodeData::clear_has_source_to_parent() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void TranformNodeData::clear_source_to_parent() {
  if (source_to_parent_ != NULL) source_to_parent_->::cc::proto::Vector2dF::Clear();
  clear_has_source_to_parent();
}
inline const ::cc::proto::Vector2dF& TranformNodeData::source_to_parent() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return source_to_parent_ != NULL ? *source_to_parent_ : *default_instance().source_to_parent_;
#else
  return source_to_parent_ != NULL ? *source_to_parent_ : *default_instance_->source_to_parent_;
#endif
}
inline ::cc::proto::Vector2dF* TranformNodeData::mutable_source_to_parent() {
  set_has_source_to_parent();
  if (source_to_parent_ == NULL) source_to_parent_ = new ::cc::proto::Vector2dF;
  return source_to_parent_;
}
inline ::cc::proto::Vector2dF* TranformNodeData::release_source_to_parent() {
  clear_has_source_to_parent();
  ::cc::proto::Vector2dF* temp = source_to_parent_;
  source_to_parent_ = NULL;
  return temp;
}
inline void TranformNodeData::set_allocated_source_to_parent(::cc::proto::Vector2dF* source_to_parent) {
  delete source_to_parent_;
  source_to_parent_ = source_to_parent;
  if (source_to_parent) {
    set_has_source_to_parent();
  } else {
    clear_has_source_to_parent();
  }
}

// optional int64 sorting_context_id = 39;
inline bool TranformNodeData::has_sorting_context_id() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void TranformNodeData::set_has_sorting_context_id() {
  _has_bits_[1] |= 0x00000040u;
}
inline void TranformNodeData::clear_has_sorting_context_id() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void TranformNodeData::clear_sorting_context_id() {
  sorting_context_id_ = GOOGLE_LONGLONG(0);
  clear_has_sorting_context_id();
}
inline ::google::protobuf::int64 TranformNodeData::sorting_context_id() const {
  return sorting_context_id_;
}
inline void TranformNodeData::set_sorting_context_id(::google::protobuf::int64 value) {
  set_has_sorting_context_id();
  sorting_context_id_ = value;
}

// -------------------------------------------------------------------

// ClipNodeData

// optional .cc.proto.RectF clip = 1;
inline bool ClipNodeData::has_clip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClipNodeData::set_has_clip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClipNodeData::clear_has_clip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClipNodeData::clear_clip() {
  if (clip_ != NULL) clip_->::cc::proto::RectF::Clear();
  clear_has_clip();
}
inline const ::cc::proto::RectF& ClipNodeData::clip() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return clip_ != NULL ? *clip_ : *default_instance().clip_;
#else
  return clip_ != NULL ? *clip_ : *default_instance_->clip_;
#endif
}
inline ::cc::proto::RectF* ClipNodeData::mutable_clip() {
  set_has_clip();
  if (clip_ == NULL) clip_ = new ::cc::proto::RectF;
  return clip_;
}
inline ::cc::proto::RectF* ClipNodeData::release_clip() {
  clear_has_clip();
  ::cc::proto::RectF* temp = clip_;
  clip_ = NULL;
  return temp;
}
inline void ClipNodeData::set_allocated_clip(::cc::proto::RectF* clip) {
  delete clip_;
  clip_ = clip;
  if (clip) {
    set_has_clip();
  } else {
    clear_has_clip();
  }
}

// optional .cc.proto.RectF combined_clip_in_target_space = 2;
inline bool ClipNodeData::has_combined_clip_in_target_space() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClipNodeData::set_has_combined_clip_in_target_space() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClipNodeData::clear_has_combined_clip_in_target_space() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClipNodeData::clear_combined_clip_in_target_space() {
  if (combined_clip_in_target_space_ != NULL) combined_clip_in_target_space_->::cc::proto::RectF::Clear();
  clear_has_combined_clip_in_target_space();
}
inline const ::cc::proto::RectF& ClipNodeData::combined_clip_in_target_space() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return combined_clip_in_target_space_ != NULL ? *combined_clip_in_target_space_ : *default_instance().combined_clip_in_target_space_;
#else
  return combined_clip_in_target_space_ != NULL ? *combined_clip_in_target_space_ : *default_instance_->combined_clip_in_target_space_;
#endif
}
inline ::cc::proto::RectF* ClipNodeData::mutable_combined_clip_in_target_space() {
  set_has_combined_clip_in_target_space();
  if (combined_clip_in_target_space_ == NULL) combined_clip_in_target_space_ = new ::cc::proto::RectF;
  return combined_clip_in_target_space_;
}
inline ::cc::proto::RectF* ClipNodeData::release_combined_clip_in_target_space() {
  clear_has_combined_clip_in_target_space();
  ::cc::proto::RectF* temp = combined_clip_in_target_space_;
  combined_clip_in_target_space_ = NULL;
  return temp;
}
inline void ClipNodeData::set_allocated_combined_clip_in_target_space(::cc::proto::RectF* combined_clip_in_target_space) {
  delete combined_clip_in_target_space_;
  combined_clip_in_target_space_ = combined_clip_in_target_space;
  if (combined_clip_in_target_space) {
    set_has_combined_clip_in_target_space();
  } else {
    clear_has_combined_clip_in_target_space();
  }
}

// optional .cc.proto.RectF clip_in_target_space = 3;
inline bool ClipNodeData::has_clip_in_target_space() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClipNodeData::set_has_clip_in_target_space() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClipNodeData::clear_has_clip_in_target_space() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClipNodeData::clear_clip_in_target_space() {
  if (clip_in_target_space_ != NULL) clip_in_target_space_->::cc::proto::RectF::Clear();
  clear_has_clip_in_target_space();
}
inline const ::cc::proto::RectF& ClipNodeData::clip_in_target_space() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return clip_in_target_space_ != NULL ? *clip_in_target_space_ : *default_instance().clip_in_target_space_;
#else
  return clip_in_target_space_ != NULL ? *clip_in_target_space_ : *default_instance_->clip_in_target_space_;
#endif
}
inline ::cc::proto::RectF* ClipNodeData::mutable_clip_in_target_space() {
  set_has_clip_in_target_space();
  if (clip_in_target_space_ == NULL) clip_in_target_space_ = new ::cc::proto::RectF;
  return clip_in_target_space_;
}
inline ::cc::proto::RectF* ClipNodeData::release_clip_in_target_space() {
  clear_has_clip_in_target_space();
  ::cc::proto::RectF* temp = clip_in_target_space_;
  clip_in_target_space_ = NULL;
  return temp;
}
inline void ClipNodeData::set_allocated_clip_in_target_space(::cc::proto::RectF* clip_in_target_space) {
  delete clip_in_target_space_;
  clip_in_target_space_ = clip_in_target_space;
  if (clip_in_target_space) {
    set_has_clip_in_target_space();
  } else {
    clear_has_clip_in_target_space();
  }
}

// optional int64 transform_id = 4;
inline bool ClipNodeData::has_transform_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClipNodeData::set_has_transform_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClipNodeData::clear_has_transform_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClipNodeData::clear_transform_id() {
  transform_id_ = GOOGLE_LONGLONG(0);
  clear_has_transform_id();
}
inline ::google::protobuf::int64 ClipNodeData::transform_id() const {
  return transform_id_;
}
inline void ClipNodeData::set_transform_id(::google::protobuf::int64 value) {
  set_has_transform_id();
  transform_id_ = value;
}

// optional int64 target_id = 5;
inline bool ClipNodeData::has_target_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClipNodeData::set_has_target_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClipNodeData::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClipNodeData::clear_target_id() {
  target_id_ = GOOGLE_LONGLONG(0);
  clear_has_target_id();
}
inline ::google::protobuf::int64 ClipNodeData::target_id() const {
  return target_id_;
}
inline void ClipNodeData::set_target_id(::google::protobuf::int64 value) {
  set_has_target_id();
  target_id_ = value;
}

// optional bool applies_local_clip = 6;
inline bool ClipNodeData::has_applies_local_clip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClipNodeData::set_has_applies_local_clip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClipNodeData::clear_has_applies_local_clip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClipNodeData::clear_applies_local_clip() {
  applies_local_clip_ = false;
  clear_has_applies_local_clip();
}
inline bool ClipNodeData::applies_local_clip() const {
  return applies_local_clip_;
}
inline void ClipNodeData::set_applies_local_clip(bool value) {
  set_has_applies_local_clip();
  applies_local_clip_ = value;
}

// optional bool layer_clipping_uses_only_local_clip = 7;
inline bool ClipNodeData::has_layer_clipping_uses_only_local_clip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClipNodeData::set_has_layer_clipping_uses_only_local_clip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClipNodeData::clear_has_layer_clipping_uses_only_local_clip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClipNodeData::clear_layer_clipping_uses_only_local_clip() {
  layer_clipping_uses_only_local_clip_ = false;
  clear_has_layer_clipping_uses_only_local_clip();
}
inline bool ClipNodeData::layer_clipping_uses_only_local_clip() const {
  return layer_clipping_uses_only_local_clip_;
}
inline void ClipNodeData::set_layer_clipping_uses_only_local_clip(bool value) {
  set_has_layer_clipping_uses_only_local_clip();
  layer_clipping_uses_only_local_clip_ = value;
}

// optional bool target_is_clipped = 8;
inline bool ClipNodeData::has_target_is_clipped() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClipNodeData::set_has_target_is_clipped() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClipNodeData::clear_has_target_is_clipped() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClipNodeData::clear_target_is_clipped() {
  target_is_clipped_ = false;
  clear_has_target_is_clipped();
}
inline bool ClipNodeData::target_is_clipped() const {
  return target_is_clipped_;
}
inline void ClipNodeData::set_target_is_clipped(bool value) {
  set_has_target_is_clipped();
  target_is_clipped_ = value;
}

// optional bool layers_are_clipped = 9;
inline bool ClipNodeData::has_layers_are_clipped() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClipNodeData::set_has_layers_are_clipped() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClipNodeData::clear_has_layers_are_clipped() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClipNodeData::clear_layers_are_clipped() {
  layers_are_clipped_ = false;
  clear_has_layers_are_clipped();
}
inline bool ClipNodeData::layers_are_clipped() const {
  return layers_are_clipped_;
}
inline void ClipNodeData::set_layers_are_clipped(bool value) {
  set_has_layers_are_clipped();
  layers_are_clipped_ = value;
}

// optional bool layers_are_clipped_when_surfaces_disabled = 10;
inline bool ClipNodeData::has_layers_are_clipped_when_surfaces_disabled() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClipNodeData::set_has_layers_are_clipped_when_surfaces_disabled() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClipNodeData::clear_has_layers_are_clipped_when_surfaces_disabled() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClipNodeData::clear_layers_are_clipped_when_surfaces_disabled() {
  layers_are_clipped_when_surfaces_disabled_ = false;
  clear_has_layers_are_clipped_when_surfaces_disabled();
}
inline bool ClipNodeData::layers_are_clipped_when_surfaces_disabled() const {
  return layers_are_clipped_when_surfaces_disabled_;
}
inline void ClipNodeData::set_layers_are_clipped_when_surfaces_disabled(bool value) {
  set_has_layers_are_clipped_when_surfaces_disabled();
  layers_are_clipped_when_surfaces_disabled_ = value;
}

// optional bool resets_clip = 11;
inline bool ClipNodeData::has_resets_clip() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClipNodeData::set_has_resets_clip() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClipNodeData::clear_has_resets_clip() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClipNodeData::clear_resets_clip() {
  resets_clip_ = false;
  clear_has_resets_clip();
}
inline bool ClipNodeData::resets_clip() const {
  return resets_clip_;
}
inline void ClipNodeData::set_resets_clip(bool value) {
  set_has_resets_clip();
  resets_clip_ = value;
}

// -------------------------------------------------------------------

// EffectNodeData

// optional float opacity = 1;
inline bool EffectNodeData::has_opacity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EffectNodeData::set_has_opacity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EffectNodeData::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EffectNodeData::clear_opacity() {
  opacity_ = 0;
  clear_has_opacity();
}
inline float EffectNodeData::opacity() const {
  return opacity_;
}
inline void EffectNodeData::set_opacity(float value) {
  set_has_opacity();
  opacity_ = value;
}

// optional float screen_space_opacity = 2;
inline bool EffectNodeData::has_screen_space_opacity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EffectNodeData::set_has_screen_space_opacity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EffectNodeData::clear_has_screen_space_opacity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EffectNodeData::clear_screen_space_opacity() {
  screen_space_opacity_ = 0;
  clear_has_screen_space_opacity();
}
inline float EffectNodeData::screen_space_opacity() const {
  return screen_space_opacity_;
}
inline void EffectNodeData::set_screen_space_opacity(float value) {
  set_has_screen_space_opacity();
  screen_space_opacity_ = value;
}

// optional bool has_render_surface = 3;
inline bool EffectNodeData::has_has_render_surface() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EffectNodeData::set_has_has_render_surface() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EffectNodeData::clear_has_has_render_surface() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EffectNodeData::clear_has_render_surface() {
  has_render_surface_ = false;
  clear_has_has_render_surface();
}
inline bool EffectNodeData::has_render_surface() const {
  return has_render_surface_;
}
inline void EffectNodeData::set_has_render_surface(bool value) {
  set_has_has_render_surface();
  has_render_surface_ = value;
}

// optional bool has_copy_request = 4;
inline bool EffectNodeData::has_has_copy_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EffectNodeData::set_has_has_copy_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EffectNodeData::clear_has_has_copy_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EffectNodeData::clear_has_copy_request() {
  has_copy_request_ = false;
  clear_has_has_copy_request();
}
inline bool EffectNodeData::has_copy_request() const {
  return has_copy_request_;
}
inline void EffectNodeData::set_has_copy_request(bool value) {
  set_has_has_copy_request();
  has_copy_request_ = value;
}

// optional bool has_background_filters = 5;
inline bool EffectNodeData::has_has_background_filters() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EffectNodeData::set_has_has_background_filters() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EffectNodeData::clear_has_has_background_filters() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EffectNodeData::clear_has_background_filters() {
  has_background_filters_ = false;
  clear_has_has_background_filters();
}
inline bool EffectNodeData::has_background_filters() const {
  return has_background_filters_;
}
inline void EffectNodeData::set_has_background_filters(bool value) {
  set_has_has_background_filters();
  has_background_filters_ = value;
}

// optional bool is_drawn = 6;
inline bool EffectNodeData::has_is_drawn() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EffectNodeData::set_has_is_drawn() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EffectNodeData::clear_has_is_drawn() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EffectNodeData::clear_is_drawn() {
  is_drawn_ = false;
  clear_has_is_drawn();
}
inline bool EffectNodeData::is_drawn() const {
  return is_drawn_;
}
inline void EffectNodeData::set_is_drawn(bool value) {
  set_has_is_drawn();
  is_drawn_ = value;
}

// optional bool has_animated_opacity = 7;
inline bool EffectNodeData::has_has_animated_opacity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EffectNodeData::set_has_has_animated_opacity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EffectNodeData::clear_has_has_animated_opacity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EffectNodeData::clear_has_animated_opacity() {
  has_animated_opacity_ = false;
  clear_has_has_animated_opacity();
}
inline bool EffectNodeData::has_animated_opacity() const {
  return has_animated_opacity_;
}
inline void EffectNodeData::set_has_animated_opacity(bool value) {
  set_has_has_animated_opacity();
  has_animated_opacity_ = value;
}

// optional int64 num_copy_requests_in_subtree = 8;
inline bool EffectNodeData::has_num_copy_requests_in_subtree() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EffectNodeData::set_has_num_copy_requests_in_subtree() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EffectNodeData::clear_has_num_copy_requests_in_subtree() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EffectNodeData::clear_num_copy_requests_in_subtree() {
  num_copy_requests_in_subtree_ = GOOGLE_LONGLONG(0);
  clear_has_num_copy_requests_in_subtree();
}
inline ::google::protobuf::int64 EffectNodeData::num_copy_requests_in_subtree() const {
  return num_copy_requests_in_subtree_;
}
inline void EffectNodeData::set_num_copy_requests_in_subtree(::google::protobuf::int64 value) {
  set_has_num_copy_requests_in_subtree();
  num_copy_requests_in_subtree_ = value;
}

// optional int64 transform_id = 9;
inline bool EffectNodeData::has_transform_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EffectNodeData::set_has_transform_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EffectNodeData::clear_has_transform_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EffectNodeData::clear_transform_id() {
  transform_id_ = GOOGLE_LONGLONG(0);
  clear_has_transform_id();
}
inline ::google::protobuf::int64 EffectNodeData::transform_id() const {
  return transform_id_;
}
inline void EffectNodeData::set_transform_id(::google::protobuf::int64 value) {
  set_has_transform_id();
  transform_id_ = value;
}

// optional int64 clip_id = 10;
inline bool EffectNodeData::has_clip_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EffectNodeData::set_has_clip_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EffectNodeData::clear_has_clip_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EffectNodeData::clear_clip_id() {
  clip_id_ = GOOGLE_LONGLONG(0);
  clear_has_clip_id();
}
inline ::google::protobuf::int64 EffectNodeData::clip_id() const {
  return clip_id_;
}
inline void EffectNodeData::set_clip_id(::google::protobuf::int64 value) {
  set_has_clip_id();
  clip_id_ = value;
}

// -------------------------------------------------------------------

// ScrollNodeData

// optional bool scrollable = 1;
inline bool ScrollNodeData::has_scrollable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScrollNodeData::set_has_scrollable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScrollNodeData::clear_has_scrollable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScrollNodeData::clear_scrollable() {
  scrollable_ = false;
  clear_has_scrollable();
}
inline bool ScrollNodeData::scrollable() const {
  return scrollable_;
}
inline void ScrollNodeData::set_scrollable(bool value) {
  set_has_scrollable();
  scrollable_ = value;
}

// optional int32 main_thread_scrolling_reasons = 2;
inline bool ScrollNodeData::has_main_thread_scrolling_reasons() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScrollNodeData::set_has_main_thread_scrolling_reasons() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScrollNodeData::clear_has_main_thread_scrolling_reasons() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScrollNodeData::clear_main_thread_scrolling_reasons() {
  main_thread_scrolling_reasons_ = 0;
  clear_has_main_thread_scrolling_reasons();
}
inline ::google::protobuf::int32 ScrollNodeData::main_thread_scrolling_reasons() const {
  return main_thread_scrolling_reasons_;
}
inline void ScrollNodeData::set_main_thread_scrolling_reasons(::google::protobuf::int32 value) {
  set_has_main_thread_scrolling_reasons();
  main_thread_scrolling_reasons_ = value;
}

// optional bool contains_non_fast_scrollable_region = 3;
inline bool ScrollNodeData::has_contains_non_fast_scrollable_region() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScrollNodeData::set_has_contains_non_fast_scrollable_region() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScrollNodeData::clear_has_contains_non_fast_scrollable_region() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScrollNodeData::clear_contains_non_fast_scrollable_region() {
  contains_non_fast_scrollable_region_ = false;
  clear_has_contains_non_fast_scrollable_region();
}
inline bool ScrollNodeData::contains_non_fast_scrollable_region() const {
  return contains_non_fast_scrollable_region_;
}
inline void ScrollNodeData::set_contains_non_fast_scrollable_region(bool value) {
  set_has_contains_non_fast_scrollable_region();
  contains_non_fast_scrollable_region_ = value;
}

// optional int64 transform_id = 4;
inline bool ScrollNodeData::has_transform_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScrollNodeData::set_has_transform_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScrollNodeData::clear_has_transform_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScrollNodeData::clear_transform_id() {
  transform_id_ = GOOGLE_LONGLONG(0);
  clear_has_transform_id();
}
inline ::google::protobuf::int64 ScrollNodeData::transform_id() const {
  return transform_id_;
}
inline void ScrollNodeData::set_transform_id(::google::protobuf::int64 value) {
  set_has_transform_id();
  transform_id_ = value;
}

// -------------------------------------------------------------------

// TreeNode

// optional int64 id = 1;
inline bool TreeNode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TreeNode::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TreeNode::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TreeNode::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 TreeNode::id() const {
  return id_;
}
inline void TreeNode::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// optional int64 parent_id = 2;
inline bool TreeNode::has_parent_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TreeNode::set_has_parent_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TreeNode::clear_has_parent_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TreeNode::clear_parent_id() {
  parent_id_ = GOOGLE_LONGLONG(0);
  clear_has_parent_id();
}
inline ::google::protobuf::int64 TreeNode::parent_id() const {
  return parent_id_;
}
inline void TreeNode::set_parent_id(::google::protobuf::int64 value) {
  set_has_parent_id();
  parent_id_ = value;
}

// optional int64 owner_id = 3;
inline bool TreeNode::has_owner_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TreeNode::set_has_owner_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TreeNode::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TreeNode::clear_owner_id() {
  owner_id_ = GOOGLE_LONGLONG(0);
  clear_has_owner_id();
}
inline ::google::protobuf::int64 TreeNode::owner_id() const {
  return owner_id_;
}
inline void TreeNode::set_owner_id(::google::protobuf::int64 value) {
  set_has_owner_id();
  owner_id_ = value;
}

// optional .cc.proto.TranformNodeData transform_node_data = 1000;
inline bool TreeNode::has_transform_node_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TreeNode::set_has_transform_node_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TreeNode::clear_has_transform_node_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TreeNode::clear_transform_node_data() {
  if (transform_node_data_ != NULL) transform_node_data_->::cc::proto::TranformNodeData::Clear();
  clear_has_transform_node_data();
}
inline const ::cc::proto::TranformNodeData& TreeNode::transform_node_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transform_node_data_ != NULL ? *transform_node_data_ : *default_instance().transform_node_data_;
#else
  return transform_node_data_ != NULL ? *transform_node_data_ : *default_instance_->transform_node_data_;
#endif
}
inline ::cc::proto::TranformNodeData* TreeNode::mutable_transform_node_data() {
  set_has_transform_node_data();
  if (transform_node_data_ == NULL) transform_node_data_ = new ::cc::proto::TranformNodeData;
  return transform_node_data_;
}
inline ::cc::proto::TranformNodeData* TreeNode::release_transform_node_data() {
  clear_has_transform_node_data();
  ::cc::proto::TranformNodeData* temp = transform_node_data_;
  transform_node_data_ = NULL;
  return temp;
}
inline void TreeNode::set_allocated_transform_node_data(::cc::proto::TranformNodeData* transform_node_data) {
  delete transform_node_data_;
  transform_node_data_ = transform_node_data;
  if (transform_node_data) {
    set_has_transform_node_data();
  } else {
    clear_has_transform_node_data();
  }
}

// optional .cc.proto.ClipNodeData clip_node_data = 1001;
inline bool TreeNode::has_clip_node_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TreeNode::set_has_clip_node_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TreeNode::clear_has_clip_node_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TreeNode::clear_clip_node_data() {
  if (clip_node_data_ != NULL) clip_node_data_->::cc::proto::ClipNodeData::Clear();
  clear_has_clip_node_data();
}
inline const ::cc::proto::ClipNodeData& TreeNode::clip_node_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return clip_node_data_ != NULL ? *clip_node_data_ : *default_instance().clip_node_data_;
#else
  return clip_node_data_ != NULL ? *clip_node_data_ : *default_instance_->clip_node_data_;
#endif
}
inline ::cc::proto::ClipNodeData* TreeNode::mutable_clip_node_data() {
  set_has_clip_node_data();
  if (clip_node_data_ == NULL) clip_node_data_ = new ::cc::proto::ClipNodeData;
  return clip_node_data_;
}
inline ::cc::proto::ClipNodeData* TreeNode::release_clip_node_data() {
  clear_has_clip_node_data();
  ::cc::proto::ClipNodeData* temp = clip_node_data_;
  clip_node_data_ = NULL;
  return temp;
}
inline void TreeNode::set_allocated_clip_node_data(::cc::proto::ClipNodeData* clip_node_data) {
  delete clip_node_data_;
  clip_node_data_ = clip_node_data;
  if (clip_node_data) {
    set_has_clip_node_data();
  } else {
    clear_has_clip_node_data();
  }
}

// optional .cc.proto.EffectNodeData effect_node_data = 1002;
inline bool TreeNode::has_effect_node_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TreeNode::set_has_effect_node_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TreeNode::clear_has_effect_node_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TreeNode::clear_effect_node_data() {
  if (effect_node_data_ != NULL) effect_node_data_->::cc::proto::EffectNodeData::Clear();
  clear_has_effect_node_data();
}
inline const ::cc::proto::EffectNodeData& TreeNode::effect_node_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return effect_node_data_ != NULL ? *effect_node_data_ : *default_instance().effect_node_data_;
#else
  return effect_node_data_ != NULL ? *effect_node_data_ : *default_instance_->effect_node_data_;
#endif
}
inline ::cc::proto::EffectNodeData* TreeNode::mutable_effect_node_data() {
  set_has_effect_node_data();
  if (effect_node_data_ == NULL) effect_node_data_ = new ::cc::proto::EffectNodeData;
  return effect_node_data_;
}
inline ::cc::proto::EffectNodeData* TreeNode::release_effect_node_data() {
  clear_has_effect_node_data();
  ::cc::proto::EffectNodeData* temp = effect_node_data_;
  effect_node_data_ = NULL;
  return temp;
}
inline void TreeNode::set_allocated_effect_node_data(::cc::proto::EffectNodeData* effect_node_data) {
  delete effect_node_data_;
  effect_node_data_ = effect_node_data;
  if (effect_node_data) {
    set_has_effect_node_data();
  } else {
    clear_has_effect_node_data();
  }
}

// optional .cc.proto.ScrollNodeData scroll_node_data = 1003;
inline bool TreeNode::has_scroll_node_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TreeNode::set_has_scroll_node_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TreeNode::clear_has_scroll_node_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TreeNode::clear_scroll_node_data() {
  if (scroll_node_data_ != NULL) scroll_node_data_->::cc::proto::ScrollNodeData::Clear();
  clear_has_scroll_node_data();
}
inline const ::cc::proto::ScrollNodeData& TreeNode::scroll_node_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scroll_node_data_ != NULL ? *scroll_node_data_ : *default_instance().scroll_node_data_;
#else
  return scroll_node_data_ != NULL ? *scroll_node_data_ : *default_instance_->scroll_node_data_;
#endif
}
inline ::cc::proto::ScrollNodeData* TreeNode::mutable_scroll_node_data() {
  set_has_scroll_node_data();
  if (scroll_node_data_ == NULL) scroll_node_data_ = new ::cc::proto::ScrollNodeData;
  return scroll_node_data_;
}
inline ::cc::proto::ScrollNodeData* TreeNode::release_scroll_node_data() {
  clear_has_scroll_node_data();
  ::cc::proto::ScrollNodeData* temp = scroll_node_data_;
  scroll_node_data_ = NULL;
  return temp;
}
inline void TreeNode::set_allocated_scroll_node_data(::cc::proto::ScrollNodeData* scroll_node_data) {
  delete scroll_node_data_;
  scroll_node_data_ = scroll_node_data;
  if (scroll_node_data) {
    set_has_scroll_node_data();
  } else {
    clear_has_scroll_node_data();
  }
}

// -------------------------------------------------------------------

// PropertyTree

// optional .cc.proto.PropertyTree.PropertyType property_type = 1;
inline bool PropertyTree::has_property_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertyTree::set_has_property_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PropertyTree::clear_has_property_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PropertyTree::clear_property_type() {
  property_type_ = 1;
  clear_has_property_type();
}
inline ::cc::proto::PropertyTree_PropertyType PropertyTree::property_type() const {
  return static_cast< ::cc::proto::PropertyTree_PropertyType >(property_type_);
}
inline void PropertyTree::set_property_type(::cc::proto::PropertyTree_PropertyType value) {
  assert(::cc::proto::PropertyTree_PropertyType_IsValid(value));
  set_has_property_type();
  property_type_ = value;
}

// repeated .cc.proto.TreeNode nodes = 2;
inline int PropertyTree::nodes_size() const {
  return nodes_.size();
}
inline void PropertyTree::clear_nodes() {
  nodes_.Clear();
}
inline const ::cc::proto::TreeNode& PropertyTree::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::cc::proto::TreeNode* PropertyTree::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::cc::proto::TreeNode* PropertyTree::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cc::proto::TreeNode >&
PropertyTree::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::cc::proto::TreeNode >*
PropertyTree::mutable_nodes() {
  return &nodes_;
}

// optional bool needs_update = 3;
inline bool PropertyTree::has_needs_update() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PropertyTree::set_has_needs_update() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PropertyTree::clear_has_needs_update() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PropertyTree::clear_needs_update() {
  needs_update_ = false;
  clear_has_needs_update();
}
inline bool PropertyTree::needs_update() const {
  return needs_update_;
}
inline void PropertyTree::set_needs_update(bool value) {
  set_has_needs_update();
  needs_update_ = value;
}

// optional .cc.proto.TransformTreeData transform_tree_data = 1000;
inline bool PropertyTree::has_transform_tree_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PropertyTree::set_has_transform_tree_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PropertyTree::clear_has_transform_tree_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PropertyTree::clear_transform_tree_data() {
  if (transform_tree_data_ != NULL) transform_tree_data_->::cc::proto::TransformTreeData::Clear();
  clear_has_transform_tree_data();
}
inline const ::cc::proto::TransformTreeData& PropertyTree::transform_tree_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transform_tree_data_ != NULL ? *transform_tree_data_ : *default_instance().transform_tree_data_;
#else
  return transform_tree_data_ != NULL ? *transform_tree_data_ : *default_instance_->transform_tree_data_;
#endif
}
inline ::cc::proto::TransformTreeData* PropertyTree::mutable_transform_tree_data() {
  set_has_transform_tree_data();
  if (transform_tree_data_ == NULL) transform_tree_data_ = new ::cc::proto::TransformTreeData;
  return transform_tree_data_;
}
inline ::cc::proto::TransformTreeData* PropertyTree::release_transform_tree_data() {
  clear_has_transform_tree_data();
  ::cc::proto::TransformTreeData* temp = transform_tree_data_;
  transform_tree_data_ = NULL;
  return temp;
}
inline void PropertyTree::set_allocated_transform_tree_data(::cc::proto::TransformTreeData* transform_tree_data) {
  delete transform_tree_data_;
  transform_tree_data_ = transform_tree_data;
  if (transform_tree_data) {
    set_has_transform_tree_data();
  } else {
    clear_has_transform_tree_data();
  }
}

// -------------------------------------------------------------------

// TransformTreeData

// optional bool source_to_parent_updates_allowed = 1;
inline bool TransformTreeData::has_source_to_parent_updates_allowed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransformTreeData::set_has_source_to_parent_updates_allowed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransformTreeData::clear_has_source_to_parent_updates_allowed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransformTreeData::clear_source_to_parent_updates_allowed() {
  source_to_parent_updates_allowed_ = false;
  clear_has_source_to_parent_updates_allowed();
}
inline bool TransformTreeData::source_to_parent_updates_allowed() const {
  return source_to_parent_updates_allowed_;
}
inline void TransformTreeData::set_source_to_parent_updates_allowed(bool value) {
  set_has_source_to_parent_updates_allowed();
  source_to_parent_updates_allowed_ = value;
}

// optional float page_scale_factor = 2;
inline bool TransformTreeData::has_page_scale_factor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransformTreeData::set_has_page_scale_factor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransformTreeData::clear_has_page_scale_factor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransformTreeData::clear_page_scale_factor() {
  page_scale_factor_ = 0;
  clear_has_page_scale_factor();
}
inline float TransformTreeData::page_scale_factor() const {
  return page_scale_factor_;
}
inline void TransformTreeData::set_page_scale_factor(float value) {
  set_has_page_scale_factor();
  page_scale_factor_ = value;
}

// optional float device_scale_factor = 3;
inline bool TransformTreeData::has_device_scale_factor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransformTreeData::set_has_device_scale_factor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransformTreeData::clear_has_device_scale_factor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransformTreeData::clear_device_scale_factor() {
  device_scale_factor_ = 0;
  clear_has_device_scale_factor();
}
inline float TransformTreeData::device_scale_factor() const {
  return device_scale_factor_;
}
inline void TransformTreeData::set_device_scale_factor(float value) {
  set_has_device_scale_factor();
  device_scale_factor_ = value;
}

// optional float device_transform_scale_factor = 4;
inline bool TransformTreeData::has_device_transform_scale_factor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransformTreeData::set_has_device_transform_scale_factor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransformTreeData::clear_has_device_transform_scale_factor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransformTreeData::clear_device_transform_scale_factor() {
  device_transform_scale_factor_ = 0;
  clear_has_device_transform_scale_factor();
}
inline float TransformTreeData::device_transform_scale_factor() const {
  return device_transform_scale_factor_;
}
inline void TransformTreeData::set_device_transform_scale_factor(float value) {
  set_has_device_transform_scale_factor();
  device_transform_scale_factor_ = value;
}

// optional .cc.proto.Vector2dF inner_viewport_bounds_delta = 5;
inline bool TransformTreeData::has_inner_viewport_bounds_delta() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransformTreeData::set_has_inner_viewport_bounds_delta() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransformTreeData::clear_has_inner_viewport_bounds_delta() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransformTreeData::clear_inner_viewport_bounds_delta() {
  if (inner_viewport_bounds_delta_ != NULL) inner_viewport_bounds_delta_->::cc::proto::Vector2dF::Clear();
  clear_has_inner_viewport_bounds_delta();
}
inline const ::cc::proto::Vector2dF& TransformTreeData::inner_viewport_bounds_delta() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return inner_viewport_bounds_delta_ != NULL ? *inner_viewport_bounds_delta_ : *default_instance().inner_viewport_bounds_delta_;
#else
  return inner_viewport_bounds_delta_ != NULL ? *inner_viewport_bounds_delta_ : *default_instance_->inner_viewport_bounds_delta_;
#endif
}
inline ::cc::proto::Vector2dF* TransformTreeData::mutable_inner_viewport_bounds_delta() {
  set_has_inner_viewport_bounds_delta();
  if (inner_viewport_bounds_delta_ == NULL) inner_viewport_bounds_delta_ = new ::cc::proto::Vector2dF;
  return inner_viewport_bounds_delta_;
}
inline ::cc::proto::Vector2dF* TransformTreeData::release_inner_viewport_bounds_delta() {
  clear_has_inner_viewport_bounds_delta();
  ::cc::proto::Vector2dF* temp = inner_viewport_bounds_delta_;
  inner_viewport_bounds_delta_ = NULL;
  return temp;
}
inline void TransformTreeData::set_allocated_inner_viewport_bounds_delta(::cc::proto::Vector2dF* inner_viewport_bounds_delta) {
  delete inner_viewport_bounds_delta_;
  inner_viewport_bounds_delta_ = inner_viewport_bounds_delta;
  if (inner_viewport_bounds_delta) {
    set_has_inner_viewport_bounds_delta();
  } else {
    clear_has_inner_viewport_bounds_delta();
  }
}

// optional .cc.proto.Vector2dF outer_viewport_bounds_delta = 6;
inline bool TransformTreeData::has_outer_viewport_bounds_delta() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransformTreeData::set_has_outer_viewport_bounds_delta() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransformTreeData::clear_has_outer_viewport_bounds_delta() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransformTreeData::clear_outer_viewport_bounds_delta() {
  if (outer_viewport_bounds_delta_ != NULL) outer_viewport_bounds_delta_->::cc::proto::Vector2dF::Clear();
  clear_has_outer_viewport_bounds_delta();
}
inline const ::cc::proto::Vector2dF& TransformTreeData::outer_viewport_bounds_delta() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return outer_viewport_bounds_delta_ != NULL ? *outer_viewport_bounds_delta_ : *default_instance().outer_viewport_bounds_delta_;
#else
  return outer_viewport_bounds_delta_ != NULL ? *outer_viewport_bounds_delta_ : *default_instance_->outer_viewport_bounds_delta_;
#endif
}
inline ::cc::proto::Vector2dF* TransformTreeData::mutable_outer_viewport_bounds_delta() {
  set_has_outer_viewport_bounds_delta();
  if (outer_viewport_bounds_delta_ == NULL) outer_viewport_bounds_delta_ = new ::cc::proto::Vector2dF;
  return outer_viewport_bounds_delta_;
}
inline ::cc::proto::Vector2dF* TransformTreeData::release_outer_viewport_bounds_delta() {
  clear_has_outer_viewport_bounds_delta();
  ::cc::proto::Vector2dF* temp = outer_viewport_bounds_delta_;
  outer_viewport_bounds_delta_ = NULL;
  return temp;
}
inline void TransformTreeData::set_allocated_outer_viewport_bounds_delta(::cc::proto::Vector2dF* outer_viewport_bounds_delta) {
  delete outer_viewport_bounds_delta_;
  outer_viewport_bounds_delta_ = outer_viewport_bounds_delta;
  if (outer_viewport_bounds_delta) {
    set_has_outer_viewport_bounds_delta();
  } else {
    clear_has_outer_viewport_bounds_delta();
  }
}

// repeated int64 nodes_affected_by_inner_viewport_bounds_delta = 7 [packed = true];
inline int TransformTreeData::nodes_affected_by_inner_viewport_bounds_delta_size() const {
  return nodes_affected_by_inner_viewport_bounds_delta_.size();
}
inline void TransformTreeData::clear_nodes_affected_by_inner_viewport_bounds_delta() {
  nodes_affected_by_inner_viewport_bounds_delta_.Clear();
}
inline ::google::protobuf::int64 TransformTreeData::nodes_affected_by_inner_viewport_bounds_delta(int index) const {
  return nodes_affected_by_inner_viewport_bounds_delta_.Get(index);
}
inline void TransformTreeData::set_nodes_affected_by_inner_viewport_bounds_delta(int index, ::google::protobuf::int64 value) {
  nodes_affected_by_inner_viewport_bounds_delta_.Set(index, value);
}
inline void TransformTreeData::add_nodes_affected_by_inner_viewport_bounds_delta(::google::protobuf::int64 value) {
  nodes_affected_by_inner_viewport_bounds_delta_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
TransformTreeData::nodes_affected_by_inner_viewport_bounds_delta() const {
  return nodes_affected_by_inner_viewport_bounds_delta_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
TransformTreeData::mutable_nodes_affected_by_inner_viewport_bounds_delta() {
  return &nodes_affected_by_inner_viewport_bounds_delta_;
}

// repeated int64 nodes_affected_by_outer_viewport_bounds_delta = 8 [packed = true];
inline int TransformTreeData::nodes_affected_by_outer_viewport_bounds_delta_size() const {
  return nodes_affected_by_outer_viewport_bounds_delta_.size();
}
inline void TransformTreeData::clear_nodes_affected_by_outer_viewport_bounds_delta() {
  nodes_affected_by_outer_viewport_bounds_delta_.Clear();
}
inline ::google::protobuf::int64 TransformTreeData::nodes_affected_by_outer_viewport_bounds_delta(int index) const {
  return nodes_affected_by_outer_viewport_bounds_delta_.Get(index);
}
inline void TransformTreeData::set_nodes_affected_by_outer_viewport_bounds_delta(int index, ::google::protobuf::int64 value) {
  nodes_affected_by_outer_viewport_bounds_delta_.Set(index, value);
}
inline void TransformTreeData::add_nodes_affected_by_outer_viewport_bounds_delta(::google::protobuf::int64 value) {
  nodes_affected_by_outer_viewport_bounds_delta_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
TransformTreeData::nodes_affected_by_outer_viewport_bounds_delta() const {
  return nodes_affected_by_outer_viewport_bounds_delta_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
TransformTreeData::mutable_nodes_affected_by_outer_viewport_bounds_delta() {
  return &nodes_affected_by_outer_viewport_bounds_delta_;
}

// -------------------------------------------------------------------

// PropertyTrees

// optional .cc.proto.PropertyTree transform_tree = 1;
inline bool PropertyTrees::has_transform_tree() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertyTrees::set_has_transform_tree() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PropertyTrees::clear_has_transform_tree() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PropertyTrees::clear_transform_tree() {
  if (transform_tree_ != NULL) transform_tree_->::cc::proto::PropertyTree::Clear();
  clear_has_transform_tree();
}
inline const ::cc::proto::PropertyTree& PropertyTrees::transform_tree() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transform_tree_ != NULL ? *transform_tree_ : *default_instance().transform_tree_;
#else
  return transform_tree_ != NULL ? *transform_tree_ : *default_instance_->transform_tree_;
#endif
}
inline ::cc::proto::PropertyTree* PropertyTrees::mutable_transform_tree() {
  set_has_transform_tree();
  if (transform_tree_ == NULL) transform_tree_ = new ::cc::proto::PropertyTree;
  return transform_tree_;
}
inline ::cc::proto::PropertyTree* PropertyTrees::release_transform_tree() {
  clear_has_transform_tree();
  ::cc::proto::PropertyTree* temp = transform_tree_;
  transform_tree_ = NULL;
  return temp;
}
inline void PropertyTrees::set_allocated_transform_tree(::cc::proto::PropertyTree* transform_tree) {
  delete transform_tree_;
  transform_tree_ = transform_tree;
  if (transform_tree) {
    set_has_transform_tree();
  } else {
    clear_has_transform_tree();
  }
}

// optional .cc.proto.PropertyTree effect_tree = 2;
inline bool PropertyTrees::has_effect_tree() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PropertyTrees::set_has_effect_tree() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PropertyTrees::clear_has_effect_tree() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PropertyTrees::clear_effect_tree() {
  if (effect_tree_ != NULL) effect_tree_->::cc::proto::PropertyTree::Clear();
  clear_has_effect_tree();
}
inline const ::cc::proto::PropertyTree& PropertyTrees::effect_tree() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return effect_tree_ != NULL ? *effect_tree_ : *default_instance().effect_tree_;
#else
  return effect_tree_ != NULL ? *effect_tree_ : *default_instance_->effect_tree_;
#endif
}
inline ::cc::proto::PropertyTree* PropertyTrees::mutable_effect_tree() {
  set_has_effect_tree();
  if (effect_tree_ == NULL) effect_tree_ = new ::cc::proto::PropertyTree;
  return effect_tree_;
}
inline ::cc::proto::PropertyTree* PropertyTrees::release_effect_tree() {
  clear_has_effect_tree();
  ::cc::proto::PropertyTree* temp = effect_tree_;
  effect_tree_ = NULL;
  return temp;
}
inline void PropertyTrees::set_allocated_effect_tree(::cc::proto::PropertyTree* effect_tree) {
  delete effect_tree_;
  effect_tree_ = effect_tree;
  if (effect_tree) {
    set_has_effect_tree();
  } else {
    clear_has_effect_tree();
  }
}

// optional .cc.proto.PropertyTree clip_tree = 3;
inline bool PropertyTrees::has_clip_tree() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PropertyTrees::set_has_clip_tree() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PropertyTrees::clear_has_clip_tree() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PropertyTrees::clear_clip_tree() {
  if (clip_tree_ != NULL) clip_tree_->::cc::proto::PropertyTree::Clear();
  clear_has_clip_tree();
}
inline const ::cc::proto::PropertyTree& PropertyTrees::clip_tree() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return clip_tree_ != NULL ? *clip_tree_ : *default_instance().clip_tree_;
#else
  return clip_tree_ != NULL ? *clip_tree_ : *default_instance_->clip_tree_;
#endif
}
inline ::cc::proto::PropertyTree* PropertyTrees::mutable_clip_tree() {
  set_has_clip_tree();
  if (clip_tree_ == NULL) clip_tree_ = new ::cc::proto::PropertyTree;
  return clip_tree_;
}
inline ::cc::proto::PropertyTree* PropertyTrees::release_clip_tree() {
  clear_has_clip_tree();
  ::cc::proto::PropertyTree* temp = clip_tree_;
  clip_tree_ = NULL;
  return temp;
}
inline void PropertyTrees::set_allocated_clip_tree(::cc::proto::PropertyTree* clip_tree) {
  delete clip_tree_;
  clip_tree_ = clip_tree;
  if (clip_tree) {
    set_has_clip_tree();
  } else {
    clear_has_clip_tree();
  }
}

// optional .cc.proto.PropertyTree scroll_tree = 7;
inline bool PropertyTrees::has_scroll_tree() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PropertyTrees::set_has_scroll_tree() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PropertyTrees::clear_has_scroll_tree() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PropertyTrees::clear_scroll_tree() {
  if (scroll_tree_ != NULL) scroll_tree_->::cc::proto::PropertyTree::Clear();
  clear_has_scroll_tree();
}
inline const ::cc::proto::PropertyTree& PropertyTrees::scroll_tree() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scroll_tree_ != NULL ? *scroll_tree_ : *default_instance().scroll_tree_;
#else
  return scroll_tree_ != NULL ? *scroll_tree_ : *default_instance_->scroll_tree_;
#endif
}
inline ::cc::proto::PropertyTree* PropertyTrees::mutable_scroll_tree() {
  set_has_scroll_tree();
  if (scroll_tree_ == NULL) scroll_tree_ = new ::cc::proto::PropertyTree;
  return scroll_tree_;
}
inline ::cc::proto::PropertyTree* PropertyTrees::release_scroll_tree() {
  clear_has_scroll_tree();
  ::cc::proto::PropertyTree* temp = scroll_tree_;
  scroll_tree_ = NULL;
  return temp;
}
inline void PropertyTrees::set_allocated_scroll_tree(::cc::proto::PropertyTree* scroll_tree) {
  delete scroll_tree_;
  scroll_tree_ = scroll_tree;
  if (scroll_tree) {
    set_has_scroll_tree();
  } else {
    clear_has_scroll_tree();
  }
}

// optional bool needs_rebuild = 4;
inline bool PropertyTrees::has_needs_rebuild() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PropertyTrees::set_has_needs_rebuild() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PropertyTrees::clear_has_needs_rebuild() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PropertyTrees::clear_needs_rebuild() {
  needs_rebuild_ = false;
  clear_has_needs_rebuild();
}
inline bool PropertyTrees::needs_rebuild() const {
  return needs_rebuild_;
}
inline void PropertyTrees::set_needs_rebuild(bool value) {
  set_has_needs_rebuild();
  needs_rebuild_ = value;
}

// optional bool non_root_surfaces_enabled = 5;
inline bool PropertyTrees::has_non_root_surfaces_enabled() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PropertyTrees::set_has_non_root_surfaces_enabled() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PropertyTrees::clear_has_non_root_surfaces_enabled() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PropertyTrees::clear_non_root_surfaces_enabled() {
  non_root_surfaces_enabled_ = false;
  clear_has_non_root_surfaces_enabled();
}
inline bool PropertyTrees::non_root_surfaces_enabled() const {
  return non_root_surfaces_enabled_;
}
inline void PropertyTrees::set_non_root_surfaces_enabled(bool value) {
  set_has_non_root_surfaces_enabled();
  non_root_surfaces_enabled_ = value;
}

// optional int64 sequence_number = 6;
inline bool PropertyTrees::has_sequence_number() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PropertyTrees::set_has_sequence_number() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PropertyTrees::clear_has_sequence_number() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PropertyTrees::clear_sequence_number() {
  sequence_number_ = GOOGLE_LONGLONG(0);
  clear_has_sequence_number();
}
inline ::google::protobuf::int64 PropertyTrees::sequence_number() const {
  return sequence_number_;
}
inline void PropertyTrees::set_sequence_number(::google::protobuf::int64 value) {
  set_has_sequence_number();
  sequence_number_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_property_5ftree_2eproto__INCLUDED
