// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: begin_main_frame_and_commit_state.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "begin_main_frame_and_commit_state.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace cc {
namespace proto {

void protobuf_ShutdownFile_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto() {
  delete ScrollUpdateInfo::default_instance_;
  delete ScrollAndScaleSet::default_instance_;
  delete BeginFrameArgs::default_instance_;
  delete BeginMainFrameAndCommitState::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::cc::proto::protobuf_AddDesc_vector2d_2eproto();
  ::cc::proto::protobuf_AddDesc_vector2df_2eproto();
  ScrollUpdateInfo::default_instance_ = new ScrollUpdateInfo();
  ScrollAndScaleSet::default_instance_ = new ScrollAndScaleSet();
  BeginFrameArgs::default_instance_ = new BeginFrameArgs();
  BeginMainFrameAndCommitState::default_instance_ = new BeginMainFrameAndCommitState();
  ScrollUpdateInfo::default_instance_->InitAsDefaultInstance();
  ScrollAndScaleSet::default_instance_->InitAsDefaultInstance();
  BeginFrameArgs::default_instance_->InitAsDefaultInstance();
  BeginMainFrameAndCommitState::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto_once_);
void protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto_once_,
                 &protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto {
  StaticDescriptorInitializer_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto() {
    protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
  }
} static_descriptor_initializer_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto_;
#endif

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScrollUpdateInfo::kLayerIdFieldNumber;
const int ScrollUpdateInfo::kScrollDeltaFieldNumber;
#endif  // !_MSC_VER

ScrollUpdateInfo::ScrollUpdateInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ScrollUpdateInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  scroll_delta_ = const_cast< ::cc::proto::Vector2d*>(
      ::cc::proto::Vector2d::internal_default_instance());
#else
  scroll_delta_ = const_cast< ::cc::proto::Vector2d*>(&::cc::proto::Vector2d::default_instance());
#endif
}

ScrollUpdateInfo::ScrollUpdateInfo(const ScrollUpdateInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ScrollUpdateInfo::SharedCtor() {
  _cached_size_ = 0;
  layer_id_ = GOOGLE_LONGLONG(0);
  scroll_delta_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScrollUpdateInfo::~ScrollUpdateInfo() {
  SharedDtor();
}

void ScrollUpdateInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete scroll_delta_;
  }
}

void ScrollUpdateInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ScrollUpdateInfo& ScrollUpdateInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#endif
  return *default_instance_;
}

ScrollUpdateInfo* ScrollUpdateInfo::default_instance_ = NULL;

ScrollUpdateInfo* ScrollUpdateInfo::New() const {
  return new ScrollUpdateInfo;
}

void ScrollUpdateInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    layer_id_ = GOOGLE_LONGLONG(0);
    if (has_scroll_delta()) {
      if (scroll_delta_ != NULL) scroll_delta_->::cc::proto::Vector2d::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ScrollUpdateInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 layer_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &layer_id_)));
          set_has_layer_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_scroll_delta;
        break;
      }

      // optional .cc.proto.Vector2d scroll_delta = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_scroll_delta:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scroll_delta()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ScrollUpdateInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 layer_id = 1;
  if (has_layer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->layer_id(), output);
  }

  // optional .cc.proto.Vector2d scroll_delta = 2;
  if (has_scroll_delta()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->scroll_delta(), output);
  }

}

int ScrollUpdateInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 layer_id = 1;
    if (has_layer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->layer_id());
    }

    // optional .cc.proto.Vector2d scroll_delta = 2;
    if (has_scroll_delta()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->scroll_delta());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScrollUpdateInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ScrollUpdateInfo*>(&from));
}

void ScrollUpdateInfo::MergeFrom(const ScrollUpdateInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_layer_id()) {
      set_layer_id(from.layer_id());
    }
    if (from.has_scroll_delta()) {
      mutable_scroll_delta()->::cc::proto::Vector2d::MergeFrom(from.scroll_delta());
    }
  }
}

void ScrollUpdateInfo::CopyFrom(const ScrollUpdateInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScrollUpdateInfo::IsInitialized() const {

  return true;
}

void ScrollUpdateInfo::Swap(ScrollUpdateInfo* other) {
  if (other != this) {
    std::swap(layer_id_, other->layer_id_);
    std::swap(scroll_delta_, other->scroll_delta_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ScrollUpdateInfo::GetTypeName() const {
  return "cc.proto.ScrollUpdateInfo";
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScrollAndScaleSet::kScrollsFieldNumber;
const int ScrollAndScaleSet::kPageScaleDeltaFieldNumber;
const int ScrollAndScaleSet::kElasticOverscrollDeltaFieldNumber;
const int ScrollAndScaleSet::kTopControlsDeltaFieldNumber;
#endif  // !_MSC_VER

ScrollAndScaleSet::ScrollAndScaleSet()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ScrollAndScaleSet::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  elastic_overscroll_delta_ = const_cast< ::cc::proto::Vector2dF*>(
      ::cc::proto::Vector2dF::internal_default_instance());
#else
  elastic_overscroll_delta_ = const_cast< ::cc::proto::Vector2dF*>(&::cc::proto::Vector2dF::default_instance());
#endif
}

ScrollAndScaleSet::ScrollAndScaleSet(const ScrollAndScaleSet& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ScrollAndScaleSet::SharedCtor() {
  _cached_size_ = 0;
  page_scale_delta_ = 0;
  elastic_overscroll_delta_ = NULL;
  top_controls_delta_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScrollAndScaleSet::~ScrollAndScaleSet() {
  SharedDtor();
}

void ScrollAndScaleSet::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete elastic_overscroll_delta_;
  }
}

void ScrollAndScaleSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ScrollAndScaleSet& ScrollAndScaleSet::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#endif
  return *default_instance_;
}

ScrollAndScaleSet* ScrollAndScaleSet::default_instance_ = NULL;

ScrollAndScaleSet* ScrollAndScaleSet::New() const {
  return new ScrollAndScaleSet;
}

void ScrollAndScaleSet::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    page_scale_delta_ = 0;
    if (has_elastic_overscroll_delta()) {
      if (elastic_overscroll_delta_ != NULL) elastic_overscroll_delta_->::cc::proto::Vector2dF::Clear();
    }
    top_controls_delta_ = 0;
  }
  scrolls_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ScrollAndScaleSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .cc.proto.ScrollUpdateInfo scrolls = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_scrolls:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_scrolls()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_scrolls;
        if (input->ExpectTag(21)) goto parse_page_scale_delta;
        break;
      }

      // optional float page_scale_delta = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_page_scale_delta:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &page_scale_delta_)));
          set_has_page_scale_delta();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_elastic_overscroll_delta;
        break;
      }

      // optional .cc.proto.Vector2dF elastic_overscroll_delta = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_elastic_overscroll_delta:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_elastic_overscroll_delta()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_top_controls_delta;
        break;
      }

      // optional float top_controls_delta = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_top_controls_delta:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &top_controls_delta_)));
          set_has_top_controls_delta();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ScrollAndScaleSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .cc.proto.ScrollUpdateInfo scrolls = 1;
  for (int i = 0; i < this->scrolls_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->scrolls(i), output);
  }

  // optional float page_scale_delta = 2;
  if (has_page_scale_delta()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->page_scale_delta(), output);
  }

  // optional .cc.proto.Vector2dF elastic_overscroll_delta = 3;
  if (has_elastic_overscroll_delta()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->elastic_overscroll_delta(), output);
  }

  // optional float top_controls_delta = 4;
  if (has_top_controls_delta()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->top_controls_delta(), output);
  }

}

int ScrollAndScaleSet::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional float page_scale_delta = 2;
    if (has_page_scale_delta()) {
      total_size += 1 + 4;
    }

    // optional .cc.proto.Vector2dF elastic_overscroll_delta = 3;
    if (has_elastic_overscroll_delta()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->elastic_overscroll_delta());
    }

    // optional float top_controls_delta = 4;
    if (has_top_controls_delta()) {
      total_size += 1 + 4;
    }

  }
  // repeated .cc.proto.ScrollUpdateInfo scrolls = 1;
  total_size += 1 * this->scrolls_size();
  for (int i = 0; i < this->scrolls_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->scrolls(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScrollAndScaleSet::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ScrollAndScaleSet*>(&from));
}

void ScrollAndScaleSet::MergeFrom(const ScrollAndScaleSet& from) {
  GOOGLE_CHECK_NE(&from, this);
  scrolls_.MergeFrom(from.scrolls_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_page_scale_delta()) {
      set_page_scale_delta(from.page_scale_delta());
    }
    if (from.has_elastic_overscroll_delta()) {
      mutable_elastic_overscroll_delta()->::cc::proto::Vector2dF::MergeFrom(from.elastic_overscroll_delta());
    }
    if (from.has_top_controls_delta()) {
      set_top_controls_delta(from.top_controls_delta());
    }
  }
}

void ScrollAndScaleSet::CopyFrom(const ScrollAndScaleSet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScrollAndScaleSet::IsInitialized() const {

  return true;
}

void ScrollAndScaleSet::Swap(ScrollAndScaleSet* other) {
  if (other != this) {
    scrolls_.Swap(&other->scrolls_);
    std::swap(page_scale_delta_, other->page_scale_delta_);
    std::swap(elastic_overscroll_delta_, other->elastic_overscroll_delta_);
    std::swap(top_controls_delta_, other->top_controls_delta_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ScrollAndScaleSet::GetTypeName() const {
  return "cc.proto.ScrollAndScaleSet";
}


// ===================================================================

bool BeginFrameArgs_BeginFrameArgsType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 100:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const BeginFrameArgs_BeginFrameArgsType BeginFrameArgs::INVALID;
const BeginFrameArgs_BeginFrameArgsType BeginFrameArgs::NORMAL;
const BeginFrameArgs_BeginFrameArgsType BeginFrameArgs::MISSED;
const BeginFrameArgs_BeginFrameArgsType BeginFrameArgs::BEGIN_FRAME_ARGS_TYPE_MAX;
const BeginFrameArgs_BeginFrameArgsType BeginFrameArgs::BeginFrameArgsType_MIN;
const BeginFrameArgs_BeginFrameArgsType BeginFrameArgs::BeginFrameArgsType_MAX;
const int BeginFrameArgs::BeginFrameArgsType_ARRAYSIZE;
#endif  // _MSC_VER
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BeginFrameArgs::kFrameTimeFieldNumber;
const int BeginFrameArgs::kDeadlineFieldNumber;
const int BeginFrameArgs::kIntervalFieldNumber;
const int BeginFrameArgs::kTypeFieldNumber;
const int BeginFrameArgs::kOnCriticalPathFieldNumber;
#endif  // !_MSC_VER

BeginFrameArgs::BeginFrameArgs()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BeginFrameArgs::InitAsDefaultInstance() {
}

BeginFrameArgs::BeginFrameArgs(const BeginFrameArgs& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BeginFrameArgs::SharedCtor() {
  _cached_size_ = 0;
  frame_time_ = GOOGLE_LONGLONG(0);
  deadline_ = GOOGLE_LONGLONG(0);
  interval_ = GOOGLE_LONGLONG(0);
  type_ = 1;
  on_critical_path_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BeginFrameArgs::~BeginFrameArgs() {
  SharedDtor();
}

void BeginFrameArgs::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BeginFrameArgs::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BeginFrameArgs& BeginFrameArgs::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#endif
  return *default_instance_;
}

BeginFrameArgs* BeginFrameArgs::default_instance_ = NULL;

BeginFrameArgs* BeginFrameArgs::New() const {
  return new BeginFrameArgs;
}

void BeginFrameArgs::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    frame_time_ = GOOGLE_LONGLONG(0);
    deadline_ = GOOGLE_LONGLONG(0);
    interval_ = GOOGLE_LONGLONG(0);
    type_ = 1;
    on_critical_path_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BeginFrameArgs::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 frame_time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &frame_time_)));
          set_has_frame_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_deadline;
        break;
      }

      // optional int64 deadline = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_deadline:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &deadline_)));
          set_has_deadline();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_interval;
        break;
      }

      // optional int64 interval = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_interval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &interval_)));
          set_has_interval();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_type;
        break;
      }

      // optional .cc.proto.BeginFrameArgs.BeginFrameArgsType type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cc::proto::BeginFrameArgs_BeginFrameArgsType_IsValid(value)) {
            set_type(static_cast< ::cc::proto::BeginFrameArgs_BeginFrameArgsType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_on_critical_path;
        break;
      }

      // optional bool on_critical_path = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_on_critical_path:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &on_critical_path_)));
          set_has_on_critical_path();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BeginFrameArgs::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 frame_time = 1;
  if (has_frame_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->frame_time(), output);
  }

  // optional int64 deadline = 2;
  if (has_deadline()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->deadline(), output);
  }

  // optional int64 interval = 3;
  if (has_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->interval(), output);
  }

  // optional .cc.proto.BeginFrameArgs.BeginFrameArgsType type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->type(), output);
  }

  // optional bool on_critical_path = 5;
  if (has_on_critical_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->on_critical_path(), output);
  }

}

int BeginFrameArgs::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 frame_time = 1;
    if (has_frame_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->frame_time());
    }

    // optional int64 deadline = 2;
    if (has_deadline()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->deadline());
    }

    // optional int64 interval = 3;
    if (has_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->interval());
    }

    // optional .cc.proto.BeginFrameArgs.BeginFrameArgsType type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional bool on_critical_path = 5;
    if (has_on_critical_path()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BeginFrameArgs::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BeginFrameArgs*>(&from));
}

void BeginFrameArgs::MergeFrom(const BeginFrameArgs& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_frame_time()) {
      set_frame_time(from.frame_time());
    }
    if (from.has_deadline()) {
      set_deadline(from.deadline());
    }
    if (from.has_interval()) {
      set_interval(from.interval());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_on_critical_path()) {
      set_on_critical_path(from.on_critical_path());
    }
  }
}

void BeginFrameArgs::CopyFrom(const BeginFrameArgs& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BeginFrameArgs::IsInitialized() const {

  return true;
}

void BeginFrameArgs::Swap(BeginFrameArgs* other) {
  if (other != this) {
    std::swap(frame_time_, other->frame_time_);
    std::swap(deadline_, other->deadline_);
    std::swap(interval_, other->interval_);
    std::swap(type_, other->type_);
    std::swap(on_critical_path_, other->on_critical_path_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BeginFrameArgs::GetTypeName() const {
  return "cc.proto.BeginFrameArgs";
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BeginMainFrameAndCommitState::kBeginFrameIdFieldNumber;
const int BeginMainFrameAndCommitState::kBeginFrameArgsFieldNumber;
const int BeginMainFrameAndCommitState::kScrollInfoFieldNumber;
const int BeginMainFrameAndCommitState::kMemoryAllocationLimitBytesFieldNumber;
const int BeginMainFrameAndCommitState::kEvictedUiResourcesFieldNumber;
#endif  // !_MSC_VER

BeginMainFrameAndCommitState::BeginMainFrameAndCommitState()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BeginMainFrameAndCommitState::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  begin_frame_args_ = const_cast< ::cc::proto::BeginFrameArgs*>(
      ::cc::proto::BeginFrameArgs::internal_default_instance());
#else
  begin_frame_args_ = const_cast< ::cc::proto::BeginFrameArgs*>(&::cc::proto::BeginFrameArgs::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  scroll_info_ = const_cast< ::cc::proto::ScrollAndScaleSet*>(
      ::cc::proto::ScrollAndScaleSet::internal_default_instance());
#else
  scroll_info_ = const_cast< ::cc::proto::ScrollAndScaleSet*>(&::cc::proto::ScrollAndScaleSet::default_instance());
#endif
}

BeginMainFrameAndCommitState::BeginMainFrameAndCommitState(const BeginMainFrameAndCommitState& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BeginMainFrameAndCommitState::SharedCtor() {
  _cached_size_ = 0;
  begin_frame_id_ = GOOGLE_LONGLONG(0);
  begin_frame_args_ = NULL;
  scroll_info_ = NULL;
  memory_allocation_limit_bytes_ = GOOGLE_LONGLONG(0);
  evicted_ui_resources_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BeginMainFrameAndCommitState::~BeginMainFrameAndCommitState() {
  SharedDtor();
}

void BeginMainFrameAndCommitState::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete begin_frame_args_;
    delete scroll_info_;
  }
}

void BeginMainFrameAndCommitState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BeginMainFrameAndCommitState& BeginMainFrameAndCommitState::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#endif
  return *default_instance_;
}

BeginMainFrameAndCommitState* BeginMainFrameAndCommitState::default_instance_ = NULL;

BeginMainFrameAndCommitState* BeginMainFrameAndCommitState::New() const {
  return new BeginMainFrameAndCommitState;
}

void BeginMainFrameAndCommitState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    begin_frame_id_ = GOOGLE_LONGLONG(0);
    if (has_begin_frame_args()) {
      if (begin_frame_args_ != NULL) begin_frame_args_->::cc::proto::BeginFrameArgs::Clear();
    }
    if (has_scroll_info()) {
      if (scroll_info_ != NULL) scroll_info_->::cc::proto::ScrollAndScaleSet::Clear();
    }
    memory_allocation_limit_bytes_ = GOOGLE_LONGLONG(0);
    evicted_ui_resources_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BeginMainFrameAndCommitState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 begin_frame_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &begin_frame_id_)));
          set_has_begin_frame_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_begin_frame_args;
        break;
      }

      // optional .cc.proto.BeginFrameArgs begin_frame_args = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_begin_frame_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_begin_frame_args()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_scroll_info;
        break;
      }

      // optional .cc.proto.ScrollAndScaleSet scroll_info = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_scroll_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scroll_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_memory_allocation_limit_bytes;
        break;
      }

      // optional int64 memory_allocation_limit_bytes = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_memory_allocation_limit_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &memory_allocation_limit_bytes_)));
          set_has_memory_allocation_limit_bytes();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_evicted_ui_resources;
        break;
      }

      // optional bool evicted_ui_resources = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_evicted_ui_resources:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &evicted_ui_resources_)));
          set_has_evicted_ui_resources();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BeginMainFrameAndCommitState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 begin_frame_id = 1;
  if (has_begin_frame_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->begin_frame_id(), output);
  }

  // optional .cc.proto.BeginFrameArgs begin_frame_args = 2;
  if (has_begin_frame_args()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->begin_frame_args(), output);
  }

  // optional .cc.proto.ScrollAndScaleSet scroll_info = 3;
  if (has_scroll_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->scroll_info(), output);
  }

  // optional int64 memory_allocation_limit_bytes = 4;
  if (has_memory_allocation_limit_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->memory_allocation_limit_bytes(), output);
  }

  // optional bool evicted_ui_resources = 5;
  if (has_evicted_ui_resources()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->evicted_ui_resources(), output);
  }

}

int BeginMainFrameAndCommitState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 begin_frame_id = 1;
    if (has_begin_frame_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->begin_frame_id());
    }

    // optional .cc.proto.BeginFrameArgs begin_frame_args = 2;
    if (has_begin_frame_args()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->begin_frame_args());
    }

    // optional .cc.proto.ScrollAndScaleSet scroll_info = 3;
    if (has_scroll_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->scroll_info());
    }

    // optional int64 memory_allocation_limit_bytes = 4;
    if (has_memory_allocation_limit_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->memory_allocation_limit_bytes());
    }

    // optional bool evicted_ui_resources = 5;
    if (has_evicted_ui_resources()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BeginMainFrameAndCommitState::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BeginMainFrameAndCommitState*>(&from));
}

void BeginMainFrameAndCommitState::MergeFrom(const BeginMainFrameAndCommitState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_begin_frame_id()) {
      set_begin_frame_id(from.begin_frame_id());
    }
    if (from.has_begin_frame_args()) {
      mutable_begin_frame_args()->::cc::proto::BeginFrameArgs::MergeFrom(from.begin_frame_args());
    }
    if (from.has_scroll_info()) {
      mutable_scroll_info()->::cc::proto::ScrollAndScaleSet::MergeFrom(from.scroll_info());
    }
    if (from.has_memory_allocation_limit_bytes()) {
      set_memory_allocation_limit_bytes(from.memory_allocation_limit_bytes());
    }
    if (from.has_evicted_ui_resources()) {
      set_evicted_ui_resources(from.evicted_ui_resources());
    }
  }
}

void BeginMainFrameAndCommitState::CopyFrom(const BeginMainFrameAndCommitState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BeginMainFrameAndCommitState::IsInitialized() const {

  return true;
}

void BeginMainFrameAndCommitState::Swap(BeginMainFrameAndCommitState* other) {
  if (other != this) {
    std::swap(begin_frame_id_, other->begin_frame_id_);
    std::swap(begin_frame_args_, other->begin_frame_args_);
    std::swap(scroll_info_, other->scroll_info_);
    std::swap(memory_allocation_limit_bytes_, other->memory_allocation_limit_bytes_);
    std::swap(evicted_ui_resources_, other->evicted_ui_resources_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BeginMainFrameAndCommitState::GetTypeName() const {
  return "cc.proto.BeginMainFrameAndCommitState";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cc

// @@protoc_insertion_point(global_scope)
